Phase: 6 - Content & Analysis Suite
Part: 6.9.1
Title: Frontend Intelligence UI Hooks
Depends On: 6.8-Backend-Intelligence-API.md
Objective: To create a set of robust, reusable React Query hooks for interacting with the backend's `/api/v1/intelligence` endpoints. These hooks will manage data fetching, caching, and state management (loading, success, error), providing a clean data layer for the UI components in the Intelligence Hub.

## 1. Core Principles

- **Encapsulation**: Each hook encapsulates the logic for fetching and mutating data for a specific intelligence feature. UI components will be simple and declarative, consuming these hooks without needing to know the underlying API details.
- **Centralized API Logic**: All direct API calls are made within a dedicated `IntelligenceService`, which is then used by the hooks. This keeps API logic separate from state management logic.
- **Robust Error Handling**: The hooks are designed to gracefully handle API errors, including standard network errors and specific business logic errors like `402 Payment Required` (Insufficient Credits), allowing the UI to display appropriate feedback to the user.
- **Type Safety**: The hooks will use the Pydantic schemas defined in the backend documentation to ensure type-safe interactions between the frontend and backend.

## 2. API Client Service Implementation

This service centralizes all API calls to the `/intelligence` endpoints.

**File Location:** `frontend/src/services/intelligence.service.ts`

**File Content:**
```typescript
import { apiClient } from '@/lib/api/client';
import { 
    KeywordAnalysisResponse,
    BacklinkAnalysisResponse,
    CompetitorAnalysisResponse,
    ContentGenerationRequest,
    GeneratedContentAsset // Assuming this schema exists
} from '@/types/api/intelligence'; // These types should be generated from backend schemas
import { APISuccessResponse } from '@/types/api/common';

export const IntelligenceService = {
  /**
   * Fetches keyword analysis for a project.
   */
  getKeywordAnalysis: async (projectId: string): Promise<APISuccessResponse<KeywordAnalysisResponse>> => {
    const response = await apiClient.get(`/intelligence/${projectId}/keyword-analysis`);
    return response.data;
  },

  /**
   * Fetches backlink analysis for a project.
   */
  getBacklinkAnalysis: async (projectId: string): Promise<APISuccessResponse<BacklinkAnalysisResponse>> => {
    const response = await apiClient.get(`/intelligence/${projectId}/backlink-analysis`);
    return response.data;
  },

  /**
   * Fetches competitor analysis for a project.
   */
  getCompetitorAnalysis: async (projectId: string): Promise<APISuccessResponse<CompetitorAnalysisResponse>> => {
    const response = await apiClient.get(`/intelligence/${projectId}/competitor-analysis`);
    return response.data;
  },

  /**
   * Sends a request to generate content.
   */
  generateContent: async (request: ContentGenerationRequest): Promise<APISuccessResponse<GeneratedContentAsset>> => {
    const response = await apiClient.post('/intelligence/generate-content', request);
    return response.data;
  },
};
```

## 3. React Query Hook Implementations

These hooks consume the `IntelligenceService` and provide data to the UI components.

**File Location:** `frontend/src/hooks/queries/useIntelligence.ts`

**File Content:**
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { IntelligenceService } from '@/services/intelligence.service';
import { ContentGenerationRequest } from '@/types/api/intelligence';
import { toast } from 'react-hot-toast';

const intelligenceKeys = {
  all: ['intelligence'] as const,
  analyses: (projectId: string) => [...intelligenceKeys.all, 'analyses', projectId] as const,
  keyword: (projectId: string) => [...intelligenceKeys.analyses(projectId), 'keyword'] as const,
  backlink: (projectId: string) => [...intelligenceKeys.analyses(projectId), 'backlink'] as const,
  competitor: (projectId: string) => [...intelligenceKeys.analyses(projectId), 'competitor'] as const,
};

/**
 * Hook to fetch keyword analysis data.
 */
export const useGetKeywordAnalysis = (projectId: string, options: { enabled?: boolean } = {}) => {
  return useQuery({
    queryKey: intelligenceKeys.keyword(projectId),
    queryFn: () => IntelligenceService.getKeywordAnalysis(projectId),
    enabled: !!projectId && (options.enabled ?? true),
    staleTime: 1000 * 60 * 5, // 5 minutes
    retry: (failureCount, error: any) => {
      // Don't retry on 402 Payment Required errors
      if (error?.response?.status === 402) return false;
      return failureCount < 3;
    },
    onError: (error: any) => {
      if (error?.response?.status === 402) {
        toast.error('Insufficient credits for keyword analysis.');
      } else {
        toast.error('Failed to fetch keyword analysis.');
      }
    },
  });
};

/**
 * Hook to fetch backlink analysis data.
 */
export const useGetBacklinkAnalysis = (projectId: string, options: { enabled?: boolean } = {}) => {
  return useQuery({
    queryKey: intelligenceKeys.backlink(projectId),
    queryFn: () => IntelligenceService.getBacklinkAnalysis(projectId),
    enabled: !!projectId && (options.enabled ?? true),
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
};

/**
 * Hook to fetch competitor analysis data.
 */
export const useGetCompetitorAnalysis = (projectId: string, options: { enabled?: boolean } = {}) => {
  return useQuery({
    queryKey: intelligenceKeys.competitor(projectId),
    queryFn: () => IntelligenceService.getCompetitorAnalysis(projectId),
    enabled: !!projectId && (options.enabled ?? true),
    staleTime: 1000 * 60 * 5, // 5 minutes
    retry: (failureCount, error: any) => {
      if (error?.response?.status === 402) return false;
      return failureCount < 3;
    },
    onError: (error: any) => {
      if (error?.response?.status === 402) {
        toast.error('Insufficient credits for competitor analysis.');
      } else {
        toast.error('Failed to fetch competitor analysis.');
      }
    },
  });
};

/**
 * Hook to generate content.
 */
export const useGenerateContent = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (request: ContentGenerationRequest) => IntelligenceService.generateContent(request),
    onSuccess: (data) => {
      toast.success(data.message || 'Content generated successfully!');
      // Optionally, invalidate queries that should be updated after new content is generated
      // queryClient.invalidateQueries(intelligenceKeys.analyses(data.data.projectId));
    },
    onError: (error: any) => {
      if (error?.response?.status === 402) {
        toast.error(error.response.data.detail || 'Insufficient credits for content generation.');
      } else {
        toast.error(error.message || 'Failed to generate content.');
      }
    },
  });
};
```
# Part: 6.9.1
# Title: Frontend Intelligence UI Hooks
# Depends On: 6.8-Backend-Intelligence-API.md, 6.9-Frontend-Intelligence-Hub-UI.md

**Objective:** To define the custom React Query hooks that will serve as the primary interface between the frontend components of the Intelligence and Content Hubs and the backend API. These hooks will encapsulate all data fetching, caching, and state management logic related to the API, providing a clean and reusable data layer.

### 1. Core Principles

*   **Encapsulation:** All API logic (endpoint URLs, request/response handling, error management) will be contained within these hooks.
*   **Declarative Fetching:** Components will use these hooks to declaratively fetch data, and React Query will handle the complexities of caching, background refetching, and state updates.
*   **Optimistic Updates:** For mutations (like content generation), the hooks will implement optimistic updates where appropriate to provide a faster user experience.

### 2. Hook Implementation (`useIntelligenceAPI.ts`)

All hooks will be consolidated into a single file, `src/hooks/useIntelligenceAPI.ts`, and will interact with the API endpoints defined in `6.8-Backend-Intelligence-API.md`.

#### `useGetKeywordAnalysis`

*   **Description:** Fetches the AI-powered keyword analysis for a given project.
*   **React Query Hook:** `useQuery`
*   **Query Key:** `['keywordAnalysis', projectId]`
*   **Function:** Makes a `GET` request to `/api/v1/intelligence/{projectId}/keyword-analysis`.
*   **Usage:**
    ```javascript
    const { data, isLoading, error } = useGetKeywordAnalysis(projectId);
    ```

#### `useGetBacklinkAnalysis`

*   **Description:** Fetches the backlink profile summary for a given project.
*   **React Query Hook:** `useQuery`
*   **Query Key:** `['backlinkAnalysis', projectId]`
*   **Function:** Makes a `GET` request to `/api/v1/intelligence/{projectId}/backlink-analysis`.
*   **Usage:**
    ```javascript
    const { data, isLoading } = useGetBacklinkAnalysis(projectId);
    ```

#### `useGetCompetitorAnalysis`

*   **Description:** Fetches the competitor analysis for a given project.
*   **React Query Hook:** `useQuery`
*   **Query Key:** `['competitorAnalysis', projectId]`
*   **Function:** Makes a `GET` request to `/api/v1/intelligence/{projectId}/competitor-analysis`.
*   **Usage:**
    ```javascript
    const { data, isLoading, error } = useGetCompetitorAnalysis(projectId);
    ```

#### `useGenerateContent`

*   **Description:** Triggers the content generation process based on a user's request.
*   **React Query Hook:** `useMutation`
*   **Function:** Makes a `POST` request to `/api/v1/intelligence/generate-content`.
*   **State Handling:** On success, it should invalidate any queries related to generated content to ensure the UI updates.
*   **Usage:**
    ```javascript
    const { mutate: generateContent, isLoading } = useGenerateContent();
    const handleGenerate = (requestData) => {
      generateContent(requestData, {
        onSuccess: (newContent) => {
          // Update UI or show success message
        },
        onError: (error) => {
          // Handle 402 Payment Required or other errors
        }
      });
    };
    ```

### 3. Error Handling

All hooks will have standardized error handling. Specifically, they will be designed to catch the `402 Payment Required` HTTP status code and translate it into a user-friendly state that the UI components can use to prompt the user to purchase more credits.

### 4. Conclusion

This document completes the final missing piece of the MartechEngine architectural blueprint. With the backend services, frontend UIs, and now the connecting data hooks all designed, the project has a complete and coherent plan for implementation.