Phase: 3 - Core Application & Project Management
Part: 3.1
Title: Backend Project Management Service
Depends On: 2.12-Data-Models-Projects.md
Objective: To implement the ProjectService, a dedicated service class that handles all business logic for project management. This includes performing CRUD operations and, crucially, enforcing project limits based on the user's subscription plan, ensuring business rules are applied correctly.
1. Core Principle: Encapsulation of Business Logic
The ProjectService is the single source of truth for all business rules related to projects. The API layer will remain "thin" and delegate all complex work to this service. This ensures that our rules are consistently applied and are easy to test and maintain.
Key Responsibilities:
Plan Limit Enforcement: Before creating a project, the service will count the user's active projects and compare it against the allowed_projects limit from their subscription plan.
Ownership & Tenancy: Every database query within this service will be filtered by user_id and/or organization_id to prevent any data leakage between tenants.
Transactional Integrity: All write operations (create, update, delete) will be handled within a database transaction to ensure data consistency.
2. Business Logic: Tier-Based Project Limits
This service directly implements the business rules for our subscription tiers. The create_project method will read the allowed_projects value from the user's associated Plan record in the database.
Free Plan: allowed_projects = 1
Paid Plan: allowed_projects = 5
If a user on the Free plan attempts to create a second project, the service will raise a ValueError. The API layer will then translate this into a 402 Payment Required response, which the frontend can use to prompt the user to upgrade.
3. ProjectService Implementation
This service contains the methods for creating, retrieving, updating, and deleting projects.
File Location: backend/app/services/project_service.py
File Content:
import logging
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import func
from typing import List, Optional
from uuid import UUID

from app.models.user import User
from app.models.project import Project, ProjectStatus
from app.models.plan import Plan # Plan model will be created in Phase 4
from app.schemas.project_schemas import ProjectCreate, ProjectUpdate # Schemas will be created next

logger = logging.getLogger(__name__)

class ProjectService:
    """Service layer for all project-related business logic."""

    def __init__(self, db: Session):
        self.db = db

    def get_project_by_id(self, project_id: UUID, user: User) -> Optional[Project]:
        """
        Retrieves a single project by its ID, ensuring the user belongs to the correct organization.
        """
        return self.db.query(Project).filter(
            Project.id == project_id,
            Project.organization_id == user.organization_id # Tenancy check
        ).first()

    def get_projects_for_user(self, user: User) -> List[Project]:
        """
        Retrieves all active projects for a given user's organization.
        """
        return self.db.query(Project).filter(
            Project.organization_id == user.organization_id,
            Project.status == ProjectStatus.ACTIVE
        ).order_by(Project.created_at.desc()).all()

    def create_project(self, project_create: ProjectCreate, user: User) -> Project:
        """
        Creates a new project for a user after validating their plan limits.
        
        Args:
            project_create (ProjectCreate): Pydantic schema with new project data.
            user (User): The user creating the project.
            
        Returns:
            Project: The newly created project object.
            
        Raises:
            ValueError: If the user has reached their project limit or has no plan.
        """
        # --- CRITICAL BUSINESS LOGIC: PLAN ENFORCEMENT ---
        
        # Eagerly load the plan associated with the user's organization
        org = self.db.query(Organization).options(joinedload(Organization.plan)).filter(Organization.id == user.organization_id).first()
        
        if not org or not org.plan:
            logger.error(f"User {user.id} in Organization {user.organization_id} has no plan assigned.")
            raise ValueError("Your organization has no active subscription plan.")

        plan = org.plan
        allowed_projects = plan.allowed_projects
        
        # Count the organization's current number of active projects.
        current_project_count = self.db.query(func.count(Project.id)).filter(
            Project.organization_id == user.organization_id,
            Project.status == ProjectStatus.ACTIVE
        ).scalar() or 0
        
        # Check if the user has reached their limit.
        if current_project_count >= allowed_projects:
            logger.warning(
                f"User {user.email} denied project creation on plan '{plan.name}'. "
                f"Limit: {allowed_projects}, Current Count: {current_project_count}"
            )
            raise ValueError(
                f"You have reached your limit of {allowed_projects} projects for the '{plan.name}' plan. "
                "Please upgrade your plan to create more."
            )

        # If all checks pass, create the new project.
        new_project = Project(
            **project_create.model_dump(),
            owner_id=user.id,
            organization_id=user.organization_id
        )
        
        self.db.add(new_project)
        self.db.commit()
        self.db.refresh(new_project)
        
        logger.info(f"Project '{new_project.name}' created for user {user.email}.")
        return new_project

    def update_project(self, project_id: UUID, project_update: ProjectUpdate, user: User) -> Optional[Project]:
        """
        Updates an existing project, ensuring user ownership.
        """
        project = self.get_project_by_id(project_id, user)
        if not project:
            return None

        update_data = project_update.model_dump(exclude_unset=True)
        for key, value in update_data.items():
            setattr(project, key, value)
            
        self.db.commit()
        self.db.refresh(project)
        
        logger.info(f"Project {project.id} updated by user {user.email}.")
        return project

    def delete_project(self, project_id: UUID, user: User) -> bool:
        """
        Deletes a project by setting its status to PENDING_DELETION (soft delete).
        Ensures the user has ownership.
        """
        project = self.get_project_by_id(project_id, user)
        if not project:
            return False
            
        project.status = ProjectStatus.PENDING_DELETION
        self.db.commit()
        
        logger.info(f"Project {project.id} marked for deletion by user {user.email}.")
        return True

4. Next Steps
With a service layer that now correctly handles our core business logic for plan limitations, we are ready to expose this functionality to the frontend.
Next File: 3.2-Backend-Project-API.md will create the FastAPI endpoints (GET /projects, POST /projects, etc.) that will use this ProjectService to handle HTTP requests.
