Phase: 2 - User Identity & Authentication
Part: 2.3
Title: Backend Security & JWT Service
Depends On: 2.2-Data-Models-Auth-and-Users.md
Objective: To implement the core security service responsible for password hashing and the creation and validation of JSON Web Tokens (JWTs). This service is a critical dependency for the main AuthService and provides the fundamental building blocks for a secure authentication system.
1. Core Security Principles
Asymmetric Hashing: Passwords are never stored in plaintext. We use a strong, one-way hashing algorithm (bcrypt) to store a secure representation of the user's password.
Hybrid Authentication: We use JWTs for stateless access tokens. The access token contains all necessary information to verify the user's identity (sub claim) and its own validity (exp claim), meaning the server does not need to store session state for API requests.
Short-Lived Access Tokens: Access tokens are designed to be short-lived (e.g., 24 hours) to limit the window of opportunity if a token is compromised.
Stateful Refresh Tokens: Refresh tokens are NOT JWTs. Instead, they are secure random strings managed by the UserSessionService with database storage. This enables session revocation, device tracking, token rotation, and enhanced security features that are impossible with stateless JWTs.
2. Dependency Installation
This service requires two key libraries for hashing and JWT management.
File to Modify: backend/requirements.txt
Content to Add:
passlib[bcrypt]>=2023.2.1
python-jose[cryptography]>=3.3.0
Installation Command (run in the backend directory's venv):

pip install "passlib[bcrypt]" "python-jose[cryptography]"
3. Security Service Implementation
This file contains the complete set of functions for handling security operations. It is a pure utility module with no database dependencies.
File Location: backend/app/core/security.py
File Content:
from datetime import datetime, timedelta, timezone
from passlib.context import CryptContext
from jose import JWTError, jwt
from typing import Optional

from app.core.config import settings

# --- Password Hashing ---

# Initialize a CryptContext for password hashing using bcrypt
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain-text password against a hashed password."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain-text password."""
    return pwd_context.hash(password)


# --- JSON Web Tokens (JWT) ---

ALGORITHM = "HS256"

def create_access_token(subject: str, expires_delta: Optional[timedelta] = None, additional_claims: Optional[dict] = None) -> str:
    """
    Creates a new access token.

    Args:
        subject (str): The subject of the token (e.g., user ID).
        expires_delta (Optional[timedelta]): The lifespan of the token. Defaults to settings.
        additional_claims (Optional[dict]): Additional claims to include in the token payload.

    Returns:
        str: The encoded JWT access token.
    """
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=getattr(settings, 'ACCESS_TOKEN_EXPIRE_MINUTES', 1440))  # Default 24 hours

    to_encode = {"exp": expire, "sub": str(subject)}
    if additional_claims:
        to_encode.update(additional_claims)

    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY.get_secret_value(), algorithm=ALGORITHM)
    return encoded_jwt

# NOTE: Refresh tokens are NOT handled as JWTs in this system.
# Instead, they are managed as secure random tokens by the UserSessionService.
# This provides better security through token rotation and session revocation capabilities.
# See: 2.5.1-Backend-User-Session-Service.md for refresh token implementation.

def decode_token(token: str) -> Optional[dict]:
    """
    Decodes a JWT token.
    
    Args:
        token (str): The JWT to decode.
        
    Returns:
        Optional[dict]: The decoded token payload if valid, otherwise None.
    """
    try:
        payload = jwt.decode(token, settings.SECRET_KEY.get_secret_value(), algorithms=[ALGORITHM])
        return payload
    except JWTError:
        # This will catch expired tokens, invalid signatures, etc.
        return None

4. Next Steps
With these fundamental security utilities in place, we are now ready to build the main service that orchestrates the entire authentication and registration process.
Next File: 2.6-Backend-Auth-and-User-API.md will implement the API endpoints that use these security functions for authentication.