Phase: 4 - Core Application & Billing
Part: 4.2
Title: Backend Subscription & Credit Services
Depends On: 4.1-Data-Models-Billing-and-Credits.md
Objective: To implement the SubscriptionService for managing the customer lifecycle and the CreditService for managing all financial transactions. These services create a secure, transactional, and auditable system for all monetization logic.
1. Core Principles
Separation of Concerns: The SubscriptionService handles the customer's relationship with a plan (trials, upgrades). The CreditService is the exclusive authority for the financial ledger and knows nothing about subscriptions.
Transactional Integrity: Service methods operate within a transactional context provided by the API layer (via the db: Session object). They do not commit transactions themselves, allowing multiple service calls to be composed into a single, atomic business operation.
Concurrency Safety: The CreditService is designed to be concurrency-safe, using database-level locking to prevent race conditions when deducting credits.

2. CreditService Implementation
This service is the sole and exclusive authority for creating transactions in the CreditLedger.
File Location: backend/app/services/credit_service.py
File Content:
import logging
from sqlalchemy.orm import Session
from sqlalchemy import func, and_
from typing import Optional

from app.models.organization import Organization
from app.models.credit_ledger import CreditLedger, CreditActionType, CreditTransactionStatus
from app.core.exceptions import InsufficientCreditsError
from app.core.sentry_utils import track_business_event, add_error_context, sentry_trace

logger = logging.getLogger(__name__)

class CreditService:
    """
    Service for managing the immutable credit ledger with reserve/consume/refund lifecycle.
    
    This service implements a robust, transactional credit management system that ensures
    financial integrity and prevents race conditions in a multi-user environment.
    
    Key Features:
    - Immutable ledger pattern: All transactions are recorded, never modified
    - Three-phase lifecycle: Reserve → Consume → Refund (if needed)
    - Concurrency-safe operations using database-level locking
    - Comprehensive audit trail for all credit movements
    - Atomic operations with automatic rollback on failures
    
    Credit States:
    - RESERVED: Credits temporarily held for pending operations
    - CONSUMED: Credits permanently used for completed operations  
    - REFUNDED: Credits returned due to operation failures
    
    The service maintains two key balance calculations:
    - Available Balance: Credits available for new operations (excludes reserved)
    - Total Balance: All credits including those currently reserved
    
    Thread Safety:
    All operations use database row-level locking to prevent race conditions
    when multiple requests attempt to reserve credits simultaneously.
    
    Attributes:
        db (Session): SQLAlchemy database session for all credit operations
    """

    def __init__(self, db: Session):
        """
        Initialize the CreditService with a database session.
        
        Args:
            db (Session): SQLAlchemy database session that will be used for
                         all credit ledger operations and locking mechanisms
        """
        self.db = db

    def get_available_balance(self, organization_id: str) -> int:
        """
        Calculates the available credit balance (excluding reserved credits).
        Available = Total CONSUMED credits - Total RESERVED credits
        """
        # Sum all consumed transactions (positive and negative)
        consumed_balance = self.db.query(func.coalesce(func.sum(CreditLedger.amount), 0)).filter(
            and_(
                CreditLedger.organization_id == organization_id,
                CreditLedger.status == CreditTransactionStatus.CONSUMED
            )
        ).scalar()
        
        # Sum all reserved transactions (should be negative)
        reserved_balance = self.db.query(func.coalesce(func.sum(CreditLedger.amount), 0)).filter(
            and_(
                CreditLedger.organization_id == organization_id,
                CreditLedger.status == CreditTransactionStatus.RESERVED
            )
        ).scalar()
        
        # Available balance = consumed credits + reserved credits (reserved are negative)
        return consumed_balance + reserved_balance

    def get_total_balance(self, organization_id: str) -> int:
        """
        Calculates the total credit balance including reserved credits.
        This is the sum of all CONSUMED transactions only.
        """
        balance = self.db.query(func.coalesce(func.sum(CreditLedger.amount), 0)).filter(
            and_(
                CreditLedger.organization_id == organization_id,
                CreditLedger.status == CreditTransactionStatus.CONSUMED
            )
        ).scalar()
        return balance

    @sentry_trace("credit_balance_check")
    def has_sufficient_balance(self, organization_id: str, required_amount: int) -> bool:
        """
        Pre-authorization check: Verify if organization has sufficient available credits.
        This is called by the API layer before enqueueing any credit-consuming task.
        """
        available_balance = self.get_available_balance(organization_id)
        has_sufficient = available_balance >= required_amount
        
        track_business_event("credit_balance_check", {
            "organization_id": organization_id,
            "required_amount": required_amount,
            "available_balance": available_balance,
            "has_sufficient": has_sufficient
        })
        
        return has_sufficient

    @sentry_trace("credit_reservation")
    def reserve_credits(
        self, 
        organization_id: str, 
        amount: int, 
        action_type: CreditActionType,
        description: str = "",
        user_id: str = None,
        reference_id: str = None
    ) -> CreditLedger:
        """
        Reserve credits for a pending operation. Creates a RESERVED transaction.
        This atomically decrements the available balance while funds are in escrow.
        """
        if amount <= 0:
            raise ValueError("Reservation amount must be positive.")

        # Lock the organization row to ensure atomic operation
        org = self.db.query(Organization).filter(
            Organization.id == organization_id
        ).with_for_update().first()

        if not org:
            raise ValueError("Organization not found.")

        # Double-check available balance
        available_balance = self.get_available_balance(organization_id)
        if available_balance < amount:
            raise InsufficientCreditsError(
                f"Insufficient available credits. Required: {amount}, Available: {available_balance}"
            )
        
        # Create reservation (negative amount, RESERVED status)
        reservation = CreditLedger(
            organization_id=organization_id,
            amount=-amount,  # Negative for reservation
            action_type=action_type,
            status=CreditTransactionStatus.RESERVED,
            description=description,
            user_id=user_id,
            reference_id=reference_id
        )
        self.db.add(reservation)
        self.db.flush()  # Get the ID
        
        logger.info(f"Reserved {amount} credits for organization {organization_id} (action: {action_type.value})")
        
        track_business_event("credits_reserved", {
            "organization_id": organization_id,
            "amount": amount,
            "action_type": action_type,
            "reservation_id": str(reservation.id),
            "reference_id": reference_id
        })
        
        return reservation

    @sentry_trace("credit_consumption")
    def consume_reservation(self, reservation_id: str) -> CreditLedger:
        """
        Consume a reservation after successful operation completion.
        Updates the reservation status from RESERVED to CONSUMED.
        """
        reservation = self.db.query(CreditLedger).filter(
            CreditLedger.id == reservation_id
        ).first()
        
        if not reservation:
            raise ValueError(f"Reservation {reservation_id} not found")
        
        if reservation.status != CreditTransactionStatus.RESERVED:
            raise ValueError(f"Cannot consume reservation {reservation_id} with status {reservation.status}")
        
        # Update status to consumed
        reservation.status = CreditTransactionStatus.CONSUMED
        
        logger.info(f"Consumed reservation {reservation_id} for {abs(reservation.amount)} credits")
        
        track_business_event("credits_consumed", {
            "organization_id": str(reservation.organization_id),
            "amount": abs(reservation.amount),
            "action_type": reservation.action_type,
            "reservation_id": reservation_id,
            "reference_id": reservation.reference_id
        })
        
        return reservation

    @sentry_trace("credit_refund")
    def refund_reservation(self, reservation_id: str, reason: str) -> CreditLedger:
        """
        Refund a reservation after operation failure.
        Creates a new positive transaction to restore the balance and marks original as REFUNDED.
        """
        reservation = self.db.query(CreditLedger).filter(
            CreditLedger.id == reservation_id
        ).first()
        
        if not reservation:
            raise ValueError(f"Reservation {reservation_id} not found")
        
        if reservation.status not in [CreditTransactionStatus.RESERVED, CreditTransactionStatus.FAILED]:
            raise ValueError(f"Cannot refund reservation {reservation_id} with status {reservation.status}")
        
        # Update original reservation status
        reservation.status = CreditTransactionStatus.REFUNDED
        reservation.reason = reason
        
        # Create refund transaction (positive amount to restore balance)
        refund = CreditLedger(
            organization_id=reservation.organization_id,
            amount=abs(reservation.amount),  # Positive to restore credits
            action_type=CreditActionType.REFUND,
            status=CreditTransactionStatus.CONSUMED,  # Refunds are immediately consumed
            description=f"Refund for failed {reservation.action_type.value}: {reason}",
            user_id=reservation.user_id,
            reference_id=reservation.reference_id,
            retry_of_ledger_id=reservation.id
        )
        self.db.add(refund)
        self.db.flush()
        
        logger.info(f"Refunded reservation {reservation_id} for {abs(reservation.amount)} credits. Reason: {reason}")
        
        track_business_event("credits_refunded", {
            "organization_id": str(reservation.organization_id),
            "amount": abs(reservation.amount),
            "action_type": reservation.action_type,
            "reservation_id": reservation_id,
            "refund_id": str(refund.id),
            "reason": reason,
            "reference_id": reservation.reference_id
        })
        
        return refund

    def add_credits(
        self, 
        organization_id: str, 
        amount: int, 
        action_type: CreditActionType,
        description: str = "",
        user_id: str = None,
        reference_id: str = None
    ) -> CreditLedger:
        """Add credits to an organization (for refills, purchases, bonuses)."""
        if amount <= 0:
            raise ValueError("Credit amount must be positive.")

        credit_entry = CreditLedger(
            organization_id=organization_id,
            amount=amount,  # Positive for additions
            action_type=action_type,
            status=CreditTransactionStatus.CONSUMED,  # Credits are immediately available
            description=description,
            user_id=user_id,
            reference_id=reference_id
        )
        self.db.add(credit_entry)
        self.db.flush()
        
        logger.info(f"Added {amount} credits to organization {organization_id} (action: {action_type.value})")
        
        track_business_event("credits_added", {
            "organization_id": organization_id,
            "amount": amount,
            "action_type": action_type,
            "transaction_id": str(credit_entry.id),
            "reference_id": reference_id
        })
        
        return credit_entry

3. SubscriptionService Implementation
This service manages the lifecycle of a Subscription object.
File Location: backend/app/services/subscription_service.py
File Content:
import logging
from sqlalchemy.orm import Session
from datetime import datetime, timedelta, timezone

from app.models.organization import Organization
from app.models.plan import Plan, PlanTier
from app.models.subscription import Subscription, SubscriptionStatus
from app.models.credit_ledger import CreditActionType
from app.services.credit_service import CreditService

logger = logging.getLogger(__name__)

class SubscriptionService:
    """Service for managing the subscription lifecycle."""

    def __init__(self, db: Session):
        self.db = db
        self.credit_service = CreditService(db)

    def create_trial_subscription(self, organization: Organization, user_id: str):
        """
        Creates the initial 7-day trial subscription for a new organization and
        grants the initial 500 free credits.
        """
        if organization.subscription:
            raise ValueError("Organization already has a subscription.")

        trial_plan = self.db.query(Plan).filter(Plan.tier == PlanTier.FREE).first()
        if not trial_plan:
            # This would be a system configuration error
            raise RuntimeError("Free trial plan not configured in the system.")

        trial_ends = datetime.now(timezone.utc) + timedelta(days=7)
        
        new_subscription = Subscription(
            organization_id=organization.id,
            plan_id=trial_plan.id,
            status=SubscriptionStatus.TRIALING,
            trial_ends_at=trial_ends
        )
        self.db.add(new_subscription)
        
        # Grant the one-time signup credits via the CreditService
        self.credit_service.add_credits(
            organization_id=organization.id,
            user_id=user_id,
            amount=trial_plan.monthly_credits, # e.g., 500
            action_type=CreditActionType.SIGNUP_BONUS,
            description=f"One-time credits for '{trial_plan.name}'."
        )
        logger.info(f"Trial subscription created for organization {organization.id}.")

    def upgrade_subscription(self, organization_id: str, new_plan_id: str, provider_sub_id: str) -> Subscription:
        """
        Upgrades an organization to a paid plan. This is typically called
        by the webhook handler after a successful payment.
        """
        subscription = self.db.query(Subscription).filter(
            Subscription.organization_id == organization_id
        ).with_for_update().one()

        subscription.plan_id = new_plan_id
        subscription.status = SubscriptionStatus.ACTIVE
        subscription.provider_subscription_id = provider_sub_id
        subscription.trial_ends_at = None # End the trial period

        # TODO: Add logic to grant the initial monthly credits for the new plan.
        
        logger.info(f"Subscription for organization {organization_id} upgraded to plan {new_plan_id}.")
        return subscription

4. Next Steps
With the core services for managing subscriptions and the credit ledger now defined, the next step is to create the system that will receive and process events from our payment provider (e.g., Razorpay).
Next File: 4.3-Backend-Webhook-Service.md will define the decoupled, asynchronous architecture for ingesting payment webhooks, which will then call these services to update subscription statuses and grant credits for purchases.