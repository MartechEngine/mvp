Phase: 6 - Content & Analysis Suite
Part: 6.6
Title: Enterprise Backlink Analysis Service
Depends On: 6.5-Backend-Keyword-Analysis-Service.md
Objective: To implement the EnterpriseBacklinkAnalysisService, a service responsible for analyzing raw backlink data stored in the CentralRawData bank. This service performs on-the-fly data aggregation and summarization to provide users with a clear, actionable overview of their backlink profile without incurring additional AI or API costs.
1. Core Principles: On-the-Fly Analysis of Stored Data
Memory-First: This service is a pure data processor. It exclusively reads from the BACKLINKS_DATAFORSEO data type in the CentralRawData bank.
No Credit Cost: This is a free operation for the user as it only analyzes data they have already paid to collect during a DCS scan. It does not call the UnifiedAIService.
Data Transformation: The service's primary job is to transform a potentially massive, raw list of backlink data into a clean, structured, and easy-to-understand summary for the UI.
2. Backlink Analysis Pydantic Schemas
File Location: backend/app/schemas/backlink_analysis_schemas.py
File Content:

```python
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime
from uuid import UUID

# --- Response Sub-Models ---

class LinkTypeDistribution(BaseModel):
    """Distribution of dofollow vs nofollow links."""
    dofollow: int = Field(..., description="Number of dofollow backlinks")
    nofollow: int = Field(..., description="Number of nofollow backlinks")

class DomainAuthorityDistribution(BaseModel):
    """Distribution of backlinks by domain authority tiers."""
    tier_1: int = Field(..., description="Links from DA 80+ domains")
    tier_2: int = Field(..., description="Links from DA 60-79 domains")
    tier_3: int = Field(..., description="Links from DA 40-59 domains")
    tier_4: int = Field(..., description="Links from DA 0-39 domains")

class TopAnchorText(BaseModel):
    """Top anchor text used in backlinks."""
    text: str = Field(..., description="Anchor text")
    count: int = Field(..., description="Number of times this anchor text is used")
    percentage: float = Field(..., description="Percentage of total backlinks")

class TopReferringDomain(BaseModel):
    """Top domains linking to the project."""
    domain: str = Field(..., description="Referring domain")
    backlinks_count: int = Field(..., description="Number of backlinks from this domain")
    domain_authority: Optional[int] = Field(None, description="Domain authority score")
    first_seen: Optional[datetime] = Field(None, description="When this domain first linked")

# --- Main Response Model ---

class BacklinkAnalysisResponse(BaseModel):
    """Complete backlink analysis response."""
    project_id: UUID = Field(..., description="Project ID")
    total_backlinks: int = Field(..., description="Total number of backlinks")
    referring_domains: int = Field(..., description="Number of unique referring domains")
    domain_rank: Optional[int] = Field(None, description="Overall domain rank")
    
    # Distributions
    link_type_distribution: LinkTypeDistribution
    domain_authority_distribution: DomainAuthorityDistribution
    
    # Top lists
    top_anchor_texts: List[TopAnchorText] = Field(default_factory=list)
    top_referring_domains: List[TopReferringDomain] = Field(default_factory=list)
    
    # Metadata
    data_last_updated: datetime = Field(..., description="When the underlying data was last updated")
    analysis_generated_at: datetime = Field(default_factory=datetime.utcnow, description="When this analysis was generated")
```
3. EnterpriseBacklinkAnalysisService Implementation
File Location: backend/app/services/backlink_analysis_service.py
File Content:
import logging
from sqlalchemy.orm import Session
from typing import List
from collections import Counter

from app.services.project_memory_service import ProjectMemoryService
from app.schemas.backlink_analysis_schemas import (
    BacklinkAnalysisResponse, LinkTypeDistribution, DomainAuthorityDistribution, TopAnchorText
)
from app.models.central_raw_data import CentralRawData
from app.models.project import Project

logger = logging.getLogger(__name__)

class EnterpriseBacklinkAnalysisService:
    """
    Performs on-the-fly analysis of raw backlink data stored in the CentralRawData bank.
    """

    def __init__(self, db: Session):
        self.db = db

    def analyze_backlinks_for_project(
        self, 
        project_id: str,
        organization_id: str
    ) -> BacklinkAnalysisResponse:
        """
        Main entry point for backlink analysis. Fetches, processes, and summarizes data.
        """
        project = self.db.query(Project).filter_by(id=project_id, organization_id=organization_id).one()
        
        # 1. Fetch raw backlink data from the Central Raw Data bank
        raw_backlink_record = self.db.query(CentralRawData).filter_by(
            domain=project.url, data_type='BACKLINKS_DATAFORSEO'
        ).order_by(CentralRawData.created_at.desc()).first()

        if not raw_backlink_record or not raw_backlink_record.raw_data.get('tasks'):
            raise ValueError("No backlink data found in Data Bank. Run a DCS scan first.")
            
        raw_summary = raw_backlink_record.raw_data['tasks'][0].get('result', [{}])[0]
        # In a full implementation, you would fetch the full backlink list, not just the summary.
        # For this example, we'll work with the summary data structure.

        total_backlinks = raw_summary.get('backlinks', 0)
        referring_domains = raw_summary.get('referring_domains', 0)
        
        # This is placeholder logic. A real implementation would iterate over the full list of backlinks.
        link_types = Counter(dofollow=raw_summary.get('dofollow', 0), nofollow=(total_backlinks - raw_summary.get('dofollow', 0)))
        
        da_dist = DomainAuthorityDistribution(tier_1=0, tier_2=0, tier_3=0, tier_4=0) # Placeholder
        top_anchors = [] # Placeholder

        analysis_response = BacklinkAnalysisResponse(
            project_id=project_id,
            total_backlinks=total_backlinks,
            referring_domains=referring_domains,
            domain_rank=raw_summary.get('rank'),
            link_type_distribution=LinkTypeDistribution(**link_types),
            domain_authority_distribution=da_dist,
            top_anchor_texts=top_anchors,
            data_last_updated=raw_backlink_record.created_at
        )

        logger.info(f"Successfully analyzed backlink profile for project {project_id}.")
        return analysis_response

4. Next Steps
This service provides a clear, summarized view of a project's backlink profile by processing existing data. The final analysis service will follow a similar pattern to analyze competitor data.
Next File: 6.7-Backend-Competitor-Analysis-Service.md will create the final service in this group, synthesizing competitor data from Project Memory to identify strategic opportunities.