Phase: 1 - Foundation & Core Infrastructure
Part: 1.3
Title: Enterprise Security Architecture & Deployment Scenarios
Depends On: 1.2-Environment-Configuration.md
Objective: To define the security architecture for all environments, clearly distinguishing between the local development workflow and the production deployment process. This ensures developers can work efficiently locally, while the production environment adheres to enterprise-grade, zero-trust security on GCP.
1. Core Security Principle: Environment Isolation
Our architecture is built on a strict separation between environments. The application code itself is environment-agnostic (it reads from environment variables), but the source and security of those variables are fundamentally different.
Development: Fast, simple, and self-contained. Uses local .env files for configuration.
Production: Secure, audited, and resilient. Uses a cloud-native secret manager.
2. Development Scenario (Local Machine)
This is the standard workflow for every developer on the team. The goal is maximum productivity with zero dependency on cloud infrastructure.
Source of Truth: The backend/.env and frontend/.env.local files.
Credentials: Developers use non-production credentials. The DATABASE_URL points to the local Docker PostgreSQL container. API keys for any third-party services are developer-tier keys stored directly in the .env file.
GCP Interaction: None. No GCP service account or credentials are required for local development. The application runs entirely within the Docker Compose network.
Workflow:
A developer clones the repository.
They copy .env.example to .env.
They run docker-compose up.
The entire application stack (backend, frontend, DB, Redis) runs locally. The FastAPI application reads its configuration directly from the .env file.
3. Production Deployment Scenario (GCP)
This outlines the process our CI/CD pipeline will follow for a secure production deployment.
Source of Truth: GCP Secret Manager. The .env file is never used in production.
Identity: The application runs under the identity of a dedicated, least-privilege IAM Service Account. This is the only identity authorized to access production secrets and services.
Workflow:
One-Time Setup: A DevOps engineer runs the gcp-setup-iam.sh script (defined below) to create the service account and grant it the necessary permissions in GCP. All production secrets (Database URL, API Keys, etc.) are securely stored in GCP Secret Manager.
CI/CD Pipeline ("One-Click Push"):
The pipeline authenticates to GCP using a securely stored key for the service account.
It builds our production-ready Docker images.
It pushes these images to Google Artifact Registry.
It deploys the images to a GCP service like Cloud Run or App Engine.
Application Runtime: When the container starts in production, it uses its assigned service account identity to fetch its configuration (like the database URL) directly from GCP Secret Manager at runtime.
4. Implementation: Production IAM Setup Script
This script is for production environment setup only. It is not run by developers for their local work.
File Location: scripts/gcp-setup-iam.sh
File Content:

#!/bin/bash
# Enterprise IAM Setup Script for MartechEngine - PRODUCTION ONLY

set -euo pipefail

# --- Configuration ---
# Usage: ./gcp-setup-iam.sh <gcp-project-id>
PROJECT_ID="${1}"
ENVIRONMENT="production" # This script is hardcoded for production

SERVICE_ACCOUNT_NAME="martechengine-${ENVIRONMENT}-sa"
SERVICE_ACCOUNT_EMAIL="${SERVICE_ACCOUNT_NAME}@${PROJECT_ID}.iam.gserviceaccount.com"
SERVICE_ACCOUNT_DISPLAY_NAME="MartechEngine Production Service Account"

# --- Validation ---
if [[ -z "$PROJECT_ID" ]]; then
    echo "‚ùå Error: GCP Project ID is required."
    echo "Usage: $0 <gcp-project-id>"
    exit 1
fi

echo "üîê Setting up PRODUCTION IAM for MartechEngine"
echo "   Project: $PROJECT_ID"
echo "   Service Acc: $SERVICE_ACCOUNT_EMAIL"
echo "--------------------------------------------------"

# 1. Create the Service Account
echo "üèóÔ∏è  Step 1/3: Creating the service account..."
if gcloud iam service-accounts describe "$SERVICE_ACCOUNT_EMAIL" --project="$PROJECT_ID" &>/dev/null; then
    echo "   ‚úÖ Service account '$SERVICE_ACCOUNT_NAME' already exists."
else
    gcloud iam service-accounts create "$SERVICE_ACCOUNT_NAME" \
        --project="$PROJECT_ID" \
        --display-name="$SERVICE_ACCOUNT_DISPLAY_NAME"
    echo "   ‚úÖ Service account created."
fi

# 2. Grant Required IAM Roles
echo "üîí Step 2/3: Granting necessary IAM roles..."
ROLES=(
    "roles/secretmanager.secretAccessor"  # To read secrets
    "roles/cloudsql.client"             # To connect to Cloud SQL
    "roles/logging.logWriter"           # To write logs
    "roles/monitoring.metricWriter"     # To write metrics
    "roles/aiplatform.user"             # To use Vertex AI
    "roles/storage.objectViewer"        # To read from GCS buckets
)
for role in "${ROLES[@]}"; do
    echo "   - Granting role: $role"
    gcloud projects add-iam-policy-binding "$PROJECT_ID" \
        --member="serviceAccount:$SERVICE_ACCOUNT_EMAIL" \
        --role="$role" \
        --condition=None > /dev/null
done
echo "   ‚úÖ All roles granted."

# 3. Guidance on Key Management for CI/CD
echo "üîë Step 3/3: Key Management Guidance for CI/CD..."
echo "   A service account key is required for your CI/CD pipeline to authenticate."
echo "   To create one and store it as a GitHub Secret, follow these steps:"
echo "   1. Create the key:"
echo "      gcloud iam service-accounts keys create ci-cd-key.json --iam-account=\"$SERVICE_ACCOUNT_EMAIL\" --project=\"$PROJECT_ID\""
echo "   2. Go to your GitHub repository -> Settings -> Secrets and variables -> Actions."
echo "   3. Create a new repository secret named 'GCP_SA_KEY'."
echo "   4. Copy the entire content of the 'ci-cd-key.json' file and paste it into the secret's value."
echo "   5. Securely DELETE the 'ci-cd-key.json' file from your local machine: rm ci-cd-key.json"
echo ""
echo "üéâ Enterprise IAM setup for PRODUCTION is complete!"

