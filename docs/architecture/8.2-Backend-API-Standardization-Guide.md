Phase: 8 - Operations & Compliance
Part: 8.2
Title: Backend API Standardization Guide
Depends On: 2.6-Backend-Auth-and-User-API.md, 3.2-Backend-Project-API.md, 4.4-Backend-Payment-and-Billing-API.md
Objective: To establish comprehensive API design standards and patterns that ensure consistency, maintainability, and developer experience across all MartechEngine backend endpoints. This guide standardizes request/response formats, error handling, authentication patterns, validation, and documentation practices.

## 1. Core API Design Principles

**Consistency First**: All endpoints follow identical patterns for request/response structure, error handling, and status codes.
**Security by Default**: Every endpoint implements proper authentication, authorization, and input validation.
**Developer Experience**: Clear documentation, predictable behavior, and helpful error messages.
**Performance Aware**: Efficient pagination, caching headers, and async processing where appropriate.

## 2. Standard Request/Response Patterns

### Base Response Schema
```python
# File: backend/app/schemas/common_schemas.py
from pydantic import BaseModel, Field
from typing import Optional, Any, Dict, List, Generic, TypeVar
from datetime import datetime

T = TypeVar('T')

class APIErrorDetail(BaseModel):
    """Standard error detail structure."""
    code: str = Field(..., description="Machine-readable error code")
    message: str = Field(..., description="Human-readable error message")
    field: Optional[str] = Field(None, description="Field name if validation error")
    details: Optional[Dict[str, Any]] = Field(None, description="Additional error context")

class APIErrorResponse(BaseModel):
    """Standard error response structure."""
    success: bool = Field(False, description="Always false for error responses")
    error: APIErrorDetail = Field(..., description="Error details")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Error timestamp")
    request_id: Optional[str] = Field(None, description="Request tracking ID")

class APIPaginationMeta(BaseModel):
    """Standard pagination metadata."""
    page: int = Field(..., description="Current page number (1-based)")
    per_page: int = Field(..., description="Items per page")
    total_items: int = Field(..., description="Total number of items")
    total_pages: int = Field(..., description="Total number of pages")
    has_next: bool = Field(..., description="Whether there are more pages")
    has_prev: bool = Field(..., description="Whether there are previous pages")

class APISuccessResponse(BaseModel, Generic[T]):
    """Standard success response structure."""
    success: bool = Field(True, description="Always true for success responses")
    data: T = Field(..., description="Response payload")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Response timestamp")
    request_id: Optional[str] = Field(None, description="Request tracking ID")

class APIPaginatedResponse(BaseModel, Generic[T]):
    """Standard paginated response structure."""
    success: bool = Field(True, description="Always true for success responses")
    data: List[T] = Field(..., description="Array of items")
    meta: APIPaginationMeta = Field(..., description="Pagination metadata")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Response timestamp")
    request_id: Optional[str] = Field(None, description="Request tracking ID")

class APIHealthResponse(BaseModel):
    """Standard health check response."""
    status: str = Field(..., description="Service status: healthy, degraded, unhealthy")
    version: str = Field(..., description="Application version")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Health check timestamp")
    checks: Dict[str, Any] = Field(..., description="Individual component health checks")
```

### Standard Query Parameters
```python
# File: backend/app/schemas/query_schemas.py
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from datetime import datetime

class PaginationParams(BaseModel):
    """Standard pagination parameters."""
    page: int = Field(1, ge=1, le=1000, description="Page number (1-based)")
    per_page: int = Field(20, ge=1, le=100, description="Items per page")
    
    @validator('per_page')
    def validate_per_page(cls, v):
        if v > 100:
            raise ValueError('per_page cannot exceed 100')
        return v

class SortParams(BaseModel):
    """Standard sorting parameters."""
    sort_by: Optional[str] = Field(None, description="Field to sort by")
    sort_order: Optional[str] = Field("asc", regex="^(asc|desc)$", description="Sort order")

class DateRangeParams(BaseModel):
    """Standard date range filtering."""
    date_from: Optional[datetime] = Field(None, description="Start date (inclusive)")
    date_to: Optional[datetime] = Field(None, description="End date (inclusive)")
    
    @validator('date_to')
    def validate_date_range(cls, v, values):
        if v and 'date_from' in values and values['date_from']:
            if v < values['date_from']:
                raise ValueError('date_to must be after date_from')
        return v

class SearchParams(BaseModel):
    """Standard search parameters."""
    q: Optional[str] = Field(None, min_length=1, max_length=500, description="Search query")
    filters: Optional[List[str]] = Field(None, description="Additional filters")
```

## 3. Standard Error Handling

### Exception Hierarchy
```python
# File: backend/app/core/exceptions.py
class MartechEngineException(Exception):
    """Base exception for all MartechEngine errors."""
    def __init__(self, message: str, code: str = None, details: dict = None):
        self.message = message
        self.code = code or self.__class__.__name__.upper()
        self.details = details or {}
        super().__init__(self.message)

# Authentication & Authorization
class AuthenticationError(MartechEngineException):
    """Authentication failed."""
    pass

class AuthorizationError(MartechEngineException):
    """Authorization failed."""
    pass

class InvalidCredentialsError(AuthenticationError):
    """Invalid login credentials."""
    pass

class TokenExpiredError(AuthenticationError):
    """JWT token has expired."""
    pass

class EmailAlreadyExistsError(MartechEngineException):
    """Email address already registered."""
    pass

# Resource Errors
class ResourceNotFoundError(MartechEngineException):
    """Requested resource not found."""
    pass

class ResourceConflictError(MartechEngineException):
    """Resource conflicts with existing data."""
    pass

class ResourceLimitExceededError(MartechEngineException):
    """Resource limit exceeded."""
    pass

# Validation Errors
class ValidationError(MartechEngineException):
    """Input validation failed."""
    pass

class BusinessLogicError(MartechEngineException):
    """Business rule violation."""
    pass

# External Service Errors
class ExternalServiceError(MartechEngineException):
    """External service unavailable or error."""
    pass

class RateLimitExceededError(MartechEngineException):
    """API rate limit exceeded."""
    pass

# Credit System Errors
class InsufficientCreditsError(MartechEngineException):
    """Not enough credits for operation."""
    pass

class CreditReservationError(MartechEngineException):
    """Failed to reserve credits."""
    pass
```

### Centralized Exception Handlers
```python
# File: backend/app/api/v1/exception_handlers.py
import logging
from fastapi import Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from sqlalchemy.exc import IntegrityError
from pydantic import ValidationError as PydanticValidationError

from app.core.exceptions import *
from app.schemas.common_schemas import APIErrorResponse, APIErrorDetail
from app.core.config import settings

logger = logging.getLogger(__name__)

def setup_exception_handlers(app):
    """Register all exception handlers with the FastAPI app."""
    
    # Authentication & Authorization Errors
    @app.exception_handler(InvalidCredentialsError)
    async def invalid_credentials_handler(request: Request, exc: InvalidCredentialsError):
        return JSONResponse(
            status_code=status.HTTP_401_UNAUTHORIZED,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="AUTH_INVALID_CREDENTIALS",
                    message="Invalid email or password"
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump(),
            headers={"WWW-Authenticate": "Bearer"}
        )
    
    @app.exception_handler(TokenExpiredError)
    async def token_expired_handler(request: Request, exc: TokenExpiredError):
        return JSONResponse(
            status_code=status.HTTP_401_UNAUTHORIZED,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="AUTH_TOKEN_EXPIRED",
                    message="Access token has expired"
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump(),
            headers={"WWW-Authenticate": "Bearer"}
        )
    
    @app.exception_handler(AuthorizationError)
    async def authorization_handler(request: Request, exc: AuthorizationError):
        return JSONResponse(
            status_code=status.HTTP_403_FORBIDDEN,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="AUTH_FORBIDDEN",
                    message="Insufficient permissions for this operation"
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump()
        )
    
    # Resource Errors
    @app.exception_handler(ResourceNotFoundError)
    async def resource_not_found_handler(request: Request, exc: ResourceNotFoundError):
        return JSONResponse(
            status_code=status.HTTP_404_NOT_FOUND,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="RESOURCE_NOT_FOUND",
                    message=str(exc)
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump()
        )
    
    @app.exception_handler(ResourceConflictError)
    async def resource_conflict_handler(request: Request, exc: ResourceConflictError):
        return JSONResponse(
            status_code=status.HTTP_409_CONFLICT,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="RESOURCE_CONFLICT",
                    message=str(exc)
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump()
        )
    
    @app.exception_handler(EmailAlreadyExistsError)
    async def email_exists_handler(request: Request, exc: EmailAlreadyExistsError):
        return JSONResponse(
            status_code=status.HTTP_409_CONFLICT,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="AUTH_EMAIL_EXISTS",
                    message="An account with this email address already exists"
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump()
        )
    
    # Business Logic Errors
    @app.exception_handler(InsufficientCreditsError)
    async def insufficient_credits_handler(request: Request, exc: InsufficientCreditsError):
        return JSONResponse(
            status_code=status.HTTP_402_PAYMENT_REQUIRED,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="CREDITS_INSUFFICIENT",
                    message="Insufficient credits for this operation",
                    details=exc.details
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump()
        )
    
    @app.exception_handler(RateLimitExceededError)
    async def rate_limit_handler(request: Request, exc: RateLimitExceededError):
        return JSONResponse(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="RATE_LIMIT_EXCEEDED",
                    message="Rate limit exceeded. Please try again later.",
                    details=exc.details
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump(),
            headers={"Retry-After": "60"}
        )
    
    # Validation Errors
    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        errors = []
        for error in exc.errors():
            field = ".".join(str(loc) for loc in error["loc"][1:])  # Skip 'body'
            errors.append({
                "field": field,
                "message": error["msg"],
                "type": error["type"]
            })
        
        return JSONResponse(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="VALIDATION_ERROR",
                    message="Input validation failed",
                    details={"errors": errors}
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump()
        )
    
    # Database Integrity Errors
    @app.exception_handler(IntegrityError)
    async def integrity_error_handler(request: Request, exc: IntegrityError):
        logger.error(f"Database integrity error: {exc}")
        
        # Don't expose internal database details in production
        if settings.ENVIRONMENT == "production":
            message = "A data integrity constraint was violated"
        else:
            message = str(exc.orig)
        
        return JSONResponse(
            status_code=status.HTTP_409_CONFLICT,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="DATA_INTEGRITY_ERROR",
                    message=message
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump()
        )
    
    # External Service Errors
    @app.exception_handler(ExternalServiceError)
    async def external_service_handler(request: Request, exc: ExternalServiceError):
        logger.error(f"External service error: {exc}")
        
        return JSONResponse(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="EXTERNAL_SERVICE_ERROR",
                    message="External service temporarily unavailable"
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump(),
            headers={"Retry-After": "30"}
        )
    
    # Generic Exception Handler (Catch-all)
    @app.exception_handler(Exception)
    async def generic_exception_handler(request: Request, exc: Exception):
        logger.error(f"Unhandled exception: {exc}", exc_info=True)
        
        # Don't expose internal errors in production
        if settings.ENVIRONMENT == "production":
            message = "An internal server error occurred"
        else:
            message = str(exc)
        
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="INTERNAL_SERVER_ERROR",
                    message=message
                ),
                request_id=getattr(request.state, 'request_id', None)
            ).model_dump()
        )
```

## 4. Standard Authentication & Authorization

### Authentication Dependencies
```python
# File: backend/app/api/v1/dependencies/auth_deps.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from typing import Optional

from app.core.database import get_db
from app.core.security import verify_access_token
from app.models.user import User
from app.models.organization import Organization, Membership, MemberRole
from app.core.exceptions import TokenExpiredError, AuthorizationError

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """Get current authenticated user from JWT token."""
    try:
        payload = verify_access_token(credentials.credentials)
        user_id = payload.get("sub")
        
        if user_id is None:
            raise TokenExpiredError("Invalid token payload")
        
        user = db.query(User).filter(User.id == user_id).first()
        if user is None:
            raise TokenExpiredError("User not found")
        
        return user
    except Exception as e:
        raise TokenExpiredError("Invalid or expired token")

async def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """Get current active user (not disabled)."""
    if not current_user.is_active:
        raise AuthorizationError("User account is disabled")
    
    return current_user

async def get_current_verified_user(
    current_user: User = Depends(get_current_active_user)
) -> User:
    """Get current verified user (email verified)."""
    if not current_user.is_verified:
        raise AuthorizationError("Email verification required")
    
    return current_user

async def get_organization_member(
    organization_id: str,
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
) -> Membership:
    """Verify user is a member of the specified organization."""
    membership = db.query(Membership).filter(
        Membership.user_id == current_user.id,
        Membership.organization_id == organization_id
    ).first()
    
    if not membership:
        raise AuthorizationError("Access denied to this organization")
    
    return membership

async def require_organization_admin(
    organization_id: str,
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
) -> Membership:
    """Require user to be an admin of the specified organization."""
    membership = await get_organization_member(organization_id, current_user, db)
    
    if membership.role not in [MemberRole.OWNER, MemberRole.ADMIN]:
        raise AuthorizationError("Admin privileges required")
    
    return membership

async def require_system_admin(
    current_user: User = Depends(get_current_active_user)
) -> User:
    """Require user to be a system administrator."""
    if not current_user.is_admin:
        raise AuthorizationError("System admin privileges required")
    
    return current_user
```

## 5. Standard Endpoint Patterns

### CRUD Operations Template
```python
# File: backend/app/api/v1/endpoints/template_crud.py
from fastapi import APIRouter, Depends, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional

from app.core.database import get_db
from app.api.v1.dependencies.auth_deps import get_current_verified_user
from app.models.user import User
from app.schemas.common_schemas import APISuccessResponse, APIPaginatedResponse
from app.schemas.query_schemas import PaginationParams, SortParams, DateRangeParams
from app.services.template_service import TemplateService
from app.core.exceptions import ResourceNotFoundError

router = APIRouter()

@router.post("/", status_code=status.HTTP_201_CREATED)
async def create_resource(
    resource_data: ResourceCreateSchema,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_verified_user)
) -> APISuccessResponse[ResourceResponseSchema]:
    """
    Create a new resource.
    
    - **resource_data**: Resource creation data
    - **Returns**: Created resource details
    """
    service = TemplateService(db)
    
    resource = await service.create_resource(
        resource_data=resource_data,
        user_id=str(current_user.id),
        organization_id=str(current_user.organization_id)
    )
    
    return APISuccessResponse(data=ResourceResponseSchema.from_orm(resource))

@router.get("/", response_model=APIPaginatedResponse[ResourceResponseSchema])
async def list_resources(
    pagination: PaginationParams = Depends(),
    sort: SortParams = Depends(),
    date_range: DateRangeParams = Depends(),
    search_query: Optional[str] = Query(None, description="Search query"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_verified_user)
) -> APIPaginatedResponse[ResourceResponseSchema]:
    """
    List resources with pagination, sorting, and filtering.
    
    - **page**: Page number (1-based)
    - **per_page**: Items per page (max 100)
    - **sort_by**: Field to sort by
    - **sort_order**: Sort order (asc/desc)
    - **date_from**: Filter from date
    - **date_to**: Filter to date
    - **search_query**: Search query
    - **Returns**: Paginated list of resources
    """
    service = TemplateService(db)
    
    result = await service.list_resources(
        organization_id=str(current_user.organization_id),
        pagination=pagination,
        sort=sort,
        date_range=date_range,
        search_query=search_query
    )
    
    return APIPaginatedResponse(
        data=[ResourceResponseSchema.from_orm(item) for item in result.items],
        meta=result.meta
    )

@router.get("/{resource_id}")
async def get_resource(
    resource_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_verified_user)
) -> APISuccessResponse[ResourceResponseSchema]:
    """
    Get a specific resource by ID.
    
    - **resource_id**: Resource identifier
    - **Returns**: Resource details
    """
    service = TemplateService(db)
    
    resource = await service.get_resource(
        resource_id=resource_id,
        organization_id=str(current_user.organization_id)
    )
    
    if not resource:
        raise ResourceNotFoundError("Resource not found")
    
    return APISuccessResponse(data=ResourceResponseSchema.from_orm(resource))

@router.put("/{resource_id}")
async def update_resource(
    resource_id: str,
    resource_data: ResourceUpdateSchema,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_verified_user)
) -> APISuccessResponse[ResourceResponseSchema]:
    """
    Update a specific resource.
    
    - **resource_id**: Resource identifier
    - **resource_data**: Updated resource data
    - **Returns**: Updated resource details
    """
    service = TemplateService(db)
    
    resource = await service.update_resource(
        resource_id=resource_id,
        resource_data=resource_data,
        organization_id=str(current_user.organization_id),
        user_id=str(current_user.id)
    )
    
    if not resource:
        raise ResourceNotFoundError("Resource not found")
    
    return APISuccessResponse(data=ResourceResponseSchema.from_orm(resource))

@router.delete("/{resource_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_resource(
    resource_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_verified_user)
):
    """
    Delete a specific resource.
    
    - **resource_id**: Resource identifier
    """
    service = TemplateService(db)
    
    success = await service.delete_resource(
        resource_id=resource_id,
        organization_id=str(current_user.organization_id),
        user_id=str(current_user.id)
    )
    
    if not success:
        raise ResourceNotFoundError("Resource not found")
```

## 6. Standard HTTP Status Codes

### Status Code Guidelines
```python
# File: backend/app/core/status_codes.py
"""
Standard HTTP status codes for MartechEngine API.

SUCCESS CODES:
- 200 OK: Successful GET, PUT, PATCH requests
- 201 Created: Successful POST requests that create resources
- 204 No Content: Successful DELETE requests
- 202 Accepted: Async operations started successfully

CLIENT ERROR CODES:
- 400 Bad Request: Invalid request format or parameters
- 401 Unauthorized: Authentication required or failed
- 403 Forbidden: Authenticated but insufficient permissions
- 404 Not Found: Resource does not exist
- 409 Conflict: Resource conflict (e.g., duplicate email)
- 422 Unprocessable Entity: Validation errors
- 429 Too Many Requests: Rate limit exceeded
- 402 Payment Required: Insufficient credits

SERVER ERROR CODES:
- 500 Internal Server Error: Unexpected server error
- 502 Bad Gateway: External service error
- 503 Service Unavailable: Service temporarily down
- 504 Gateway Timeout: External service timeout
"""

# Standard status code mappings for common operations
OPERATION_STATUS_CODES = {
    "create": 201,
    "read": 200,
    "update": 200,
    "delete": 204,
    "list": 200,
    "async_start": 202,
    "health_check": 200
}
```

## 7. Standard Documentation Patterns

### OpenAPI Documentation Standards
```python
# File: backend/app/api/v1/endpoints/example_documented.py
from fastapi import APIRouter, Depends, status, Query, Path, Body
from typing import List, Optional

router = APIRouter()

@router.post(
    "/projects",
    status_code=status.HTTP_201_CREATED,
    summary="Create New Project",
    description="Create a new project for the authenticated user's organization.",
    response_description="Successfully created project details",
    tags=["Projects"],
    responses={
        201: {
            "description": "Project created successfully",
            "content": {
                "application/json": {
                    "example": {
                        "success": True,
                        "data": {
                            "id": "proj_123",
                            "name": "My Website",
                            "url": "https://example.com",
                            "description": "Company website analysis"
                        },
                        "timestamp": "2024-01-01T12:00:00Z"
                    }
                }
            }
        },
        400: {"description": "Invalid project data"},
        401: {"description": "Authentication required"},
        403: {"description": "Insufficient permissions"},
        409: {"description": "Project with this URL already exists"}
    }
)
async def create_project(
    project_data: ProjectCreateSchema = Body(
        ...,
        description="Project creation data",
        example={
            "name": "My Website",
            "url": "https://example.com",
            "description": "Company website for SEO analysis"
        }
    ),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_verified_user)
):
    """
    Create a new project for SEO analysis.
    
    This endpoint allows users to add new websites/projects to their organization
    for comprehensive SEO analysis and monitoring.
    
    **Requirements:**
    - User must be authenticated and email verified
    - URL must be valid and accessible
    - Project name must be unique within organization
    
    **Process:**
    1. Validates project data and URL accessibility
    2. Creates project record in user's organization
    3. Initializes project memory for future scans
    4. Returns project details with unique identifier
    """
    # Implementation here...
    pass
```

## 8. Standard Middleware Integration

### Request ID and Logging Middleware
```python
# File: backend/app/middleware/request_middleware.py
import uuid
import time
import logging
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

logger = logging.getLogger(__name__)

class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """
    Middleware to add request IDs and log all API requests.
    """
    
    async def dispatch(self, request: Request, call_next):
        # Generate unique request ID
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id
        
        # Start timing
        start_time = time.time()
        
        # Log incoming request
        logger.info(
            f"Request started",
            extra={
                "request_id": request_id,
                "method": request.method,
                "url": str(request.url),
                "user_agent": request.headers.get("user-agent"),
                "client_ip": request.client.host
            }
        )
        
        # Process request
        response = await call_next(request)
        
        # Calculate duration
        duration = time.time() - start_time
        
        # Add request ID to response headers
        response.headers["X-Request-ID"] = request_id
        
        # Log response
        logger.info(
            f"Request completed",
            extra={
                "request_id": request_id,
                "status_code": response.status_code,
                "duration_ms": round(duration * 1000, 2)
            }
        )
        
        return response
```

## 9. Implementation Checklist

### For Each New API Endpoint:

**✅ Request/Response Structure**
- [ ] Uses standard APISuccessResponse or APIPaginatedResponse
- [ ] Implements proper Pydantic schemas for validation
- [ ] Includes comprehensive OpenAPI documentation

**✅ Authentication & Authorization**
- [ ] Uses appropriate auth dependency (get_current_verified_user, etc.)
- [ ] Implements organization-level access control
- [ ] Validates user permissions for the operation

**✅ Error Handling**
- [ ] Raises appropriate custom exceptions
- [ ] Relies on centralized exception handlers
- [ ] Provides helpful error messages

**✅ Input Validation**
- [ ] Validates all input parameters
- [ ] Uses standard query parameter schemas
- [ ] Implements business logic validation

**✅ Performance & Security**
- [ ] Implements pagination for list endpoints
- [ ] Uses database sessions properly
- [ ] Includes rate limiting considerations

**✅ Documentation**
- [ ] Comprehensive docstrings
- [ ] OpenAPI examples and descriptions
- [ ] Clear parameter documentation

## 10. Next Steps

This API Standardization Guide provides:
- ✅ **Consistent patterns** for all endpoint implementations
- ✅ **Comprehensive error handling** with centralized exception management
- ✅ **Security standards** with proper authentication and authorization
- ✅ **Documentation standards** for developer experience
- ✅ **Performance guidelines** for scalable API design

**Next Implementation**: Apply these standards to complete email verification backend implementation.
