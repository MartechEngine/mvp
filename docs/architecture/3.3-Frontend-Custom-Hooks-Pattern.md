Phase: 3 - Core Application & Project Management
Part: 3.3
Title: Frontend Custom Hooks Pattern with React Query
Depends On: 3.2-Backend-Project-API.md
Objective: To define the architectural pattern for creating custom hooks that manage server state. This document establishes the blueprint for how all data-fetching and data-mutation hooks will be structured, using @tanstack/react-query to create a clean, declarative, and highly reusable API for our UI components to consume.
1. Core Principles: The Hook as the Data Layer API
Our UI components will be completely decoupled from the complexities of server state management. This is achieved through a set of strict principles:
One Hook File per Domain: Each data domain (e.g., projects, auth, billing) will have its own use... hook file (e.g., useProjects.ts).
Consistent Query Keys: A structured queryKeys object will be defined in each hook file. This is the single most important pattern for ensuring consistent and predictable caching, refetching, and invalidation.
Encapsulation: UI components will never call useQuery or useMutation directly. They will only use the custom hooks we define (e.g., useProjects, useCreateProject).
Separation of Concerns:
Hooks are responsible for data fetching logic, caching, and side effects (notifications, invalidation).
Components are responsible only for rendering the UI based on the state provided by the hooks.
Services (from file 2.7) are responsible for the low-level API call implementation.
2. Pattern for useQuery (Data Fetching)
This pattern demonstrates how to create custom hooks for fetching data. It includes a structured key factory and hooks for fetching both a list of items and a single item.
File Location: frontend/src/hooks/useProjects.ts (Illustrative Example)
File Content (Initial Setup):
import { useQuery } from '@tanstack/react-query';
import { ProjectService } from '@/services/project.service'; // Will be created
import { Project, PaginatedProjects } from '@/types/project'; // Will be created
import { ApiErrorResponse } from '@/types/api';

// 1. Define a structured key factory for this domain.
// This is crucial for consistent caching, refetching, and invalidation.
export const projectKeys = {
  all: ['projects'] as const,
  lists: () => [...projectKeys.all, 'list'] as const,
  list: (params: { page: number }) => [...projectKeys.lists(), params] as const,
  details: () => [...projectKeys.all, 'detail'] as const,
  detail: (id: string) => [...projectKeys.details(), id] as const,
};

// 2. Create a custom hook for fetching a list of projects.
export const useProjects = (params = { page: 1 }) => {
  return useQuery<PaginatedProjects, Error>({
    queryKey: projectKeys.list(params),
    // The queryFn simply calls our service layer method.
    queryFn: () => ProjectService.getProjects(params),
    // keepPreviousData is useful for pagination to prevent UI flickering while new page data loads.
    keepPreviousData: true,
  });
};

// 3. Create a custom hook for fetching a single project.
export const useProject = (projectId: string | null) => {
  return useQuery<Project, Error>({
    queryKey: projectKeys.detail(projectId!),
    queryFn: () => ProjectService.getProjectById(projectId!),
    // The `enabled` option is critical. It prevents the query from running
    // if the projectId is null or undefined, avoiding unnecessary API calls and errors.
    enabled: !!projectId,
  });
};

3. Pattern for useMutation (Data Modification)
This pattern demonstrates how to create custom hooks for actions that create, update, or delete data. It includes logic for handling success/error notifications and, most importantly, automatic cache invalidation, which keeps our UI automatically in sync with the server.
File Location: frontend/src/hooks/useProjects.ts (Append to this file)
File Content (to append):
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'react-hot-toast';
import { ProjectCreatePayload } from '@/types/project'; // Will be created

// ... (previous useQuery hooks) ...

// 4. Create a custom hook for the "create project" mutation.
export const useCreateProject = () => {
  const queryClient = useQueryClient();

  return useMutation<Project, Error, ProjectCreatePayload>({
    // The mutationFn calls our service layer method.
    mutationFn: (newProject: ProjectCreatePayload) => ProjectService.createProject(newProject),
    
    // --- THIS IS THE KEY PATTERN ---
    // On success, we perform side effects.
    onSuccess: (newlyCreatedProject) => {
      toast.success(`Project "${newlyCreatedProject.name}" created successfully!`);
      
      // Invalidate all queries that start with ['projects', 'list'].
      // This will automatically trigger a refetch in any component using `useProjects`,
      // ensuring the UI updates with the new project without any manual state management.
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
    },
    
    // On error, we can show a user-friendly notification.
    // The error message is standardized by our apiClient from file 2.7.
    onError: (error: Error) => {
      toast.error(`Failed to create project: ${error.message}`);
    },
  });
};
4. Next Steps
This file establishes the fundamental pattern for our entire frontend data layer. Every new feature that requires server interaction will follow this blueprint: define a query key, create a service method, and wrap it in a custom hook.
Next File: 3.4-Frontend-Project-Hooks.md will take this pattern and apply it comprehensively to the projects domain, creating all the necessary hooks (useUpdateProject, useDeleteProject, etc.) and the corresponding TypeScript types they depend on.
