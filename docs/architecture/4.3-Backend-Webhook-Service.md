Phase: 4 - Core Application & Billing
Part: 4.3
Title: Event-Driven Webhook Architecture
Depends On: 4.2-Backend-Subscription-Service.md
Objective: To define a highly available and resilient webhook ingestion system. This architecture is designed to immediately acknowledge events from the payment provider and offload all complex business logic to a decoupled, asynchronous background worker, ensuring no payment events are ever lost due to API timeouts or processing failures.
1. Core Principle: Acknowledge Immediately, Process Asynchronously
The single most important rule for handling webhooks is to do as little work as possible before returning a 200 OK response to the provider. If the provider receives a timeout or a 5xx error, it may retry sending the same event, leading to duplicate processing.
Our architecture solves this with a two-step process:
A Lightweight Ingestion Endpoint: A FastAPI endpoint whose only jobs are to verify the webhook's signature and publish the event to a Celery task queue. It is designed to be extremely fast and non-blocking.
An Asynchronous Celery Worker: A Celery task subscribes to the event queue. It contains all the complex business logic (updating the database, calling services) and operates completely independently of the API server. If this task fails, it can be retried safely without affecting the ingestion endpoint.
2. Architectural Diagram
sequenceDiagram
    participant Razorpay as Payment Provider (Razorpay)
    participant API as Webhook Ingestion API
    participant Celery as Celery Task Queue (Redis)
    participant Worker as Webhook Processor Worker
    participant DB as Database

    Razorpay->>+API: POST /webhooks/payment (Event Payload)
    API->>-Razorpay: 200 OK (Acknowledged)
    API->>Celery: Enqueue process_webhook(payload)
    
    Celery-->>+Worker: Delivers task
    Worker->>+DB: Start Transaction
    Worker->>DB: Find purchase/subscription record
    Worker->>DB: Call CreditService/SubscriptionService
    Worker->>DB: Update record status (e.g., to COMPLETED)
    DB-->>-Worker: Success
    Worker-->>-Celery: Task Succeeded

3. Webhook Processor Celery Task
This Celery task contains all the business logic and operates asynchronously.
File Location: backend/app/tasks/billing_tasks.py
File Content:
import logging
from celery import shared_task
from sqlalchemy.orm import Session
from json import JSONDecodeError

from app.core.database import SessionLocal
from app.services.subscription_service import SubscriptionService
from app.services.credit_service import CreditService
from app.models.credit_purchase import CreditPurchase, PurchaseStatus
from app.models.credit_ledger import CreditActionType

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3, default_retry_delay=300) # Retry after 5 minutes
def process_payment_webhook(self, event_payload: dict, signature: str):
    """
    Asynchronous Celery task to process payment webhooks.
    This contains the actual business logic.
    """
    db: Session = SessionLocal()
    # TODO: Add logic to verify the webhook signature here again as a security measure.
    # This prevents tasks from being triggered internally without a valid signature.

    try:
        event_type = event_payload.get('event')
        
        # Example logic for a successful one-time credit purchase
        if event_type == 'order.paid':
            order_id = event_payload['payload']['order']['entity']['id']
            
            sub_service = SubscriptionService(db)
            credit_service = CreditService(db)

            with db.begin():
                # Find the pending purchase record
                purchase = db.query(CreditPurchase).filter(
                    CreditPurchase.provider_order_id == order_id,
                    CreditPurchase.status == PurchaseStatus.PENDING
                ).with_for_update().first()

                if purchase:
                    # Grant the credits
                    credit_service.add_credits(
                        organization_id=purchase.organization_id,
                        user_id=purchase.user_id,
                        amount=purchase.credits_granted,
                        action_type=CreditActionType.CREDIT_PURCHASE,
                        description=f"Purchase for order {order_id}",
                        reference_id=str(purchase.id)
                    )
                    # Mark the purchase as completed
                    purchase.status = PurchaseStatus.COMPLETED
                    logger.info(f"Credit purchase {purchase.id} completed for order {order_id}.")
                else:
                    logger.warning(f"Received webhook for an unknown or already processed order: {order_id}")
        
        # TODO: Add logic for other event types, like 'subscription.activated'
        # elif event_type == 'subscription.activated':
        #   ... call SubscriptionService.upgrade_subscription ...

        db.commit()

    except Exception as e:
        logger.error(f"Error processing webhook payload: {e}", exc_info=True)
        db.rollback()
        # Retry the task for transient errors (e.g., database connection issues)
        raise self.retry(exc=e)
    finally:
        db.close()

4. Webhook Ingestion API Endpoint
This is the public-facing API endpoint. It is intentionally "dumb" and fast.
File to Modify: backend/app/api/v1/endpoints/webhooks.py
File Content:
import logging
import hmac
import hashlib
from fastapi import APIRouter, Request, Header, HTTPException, status
from typing import Optional
from json import JSONDecodeError

from app.tasks.billing_tasks import process_payment_webhook
from app.core.config import settings

logger = logging.getLogger(__name__)
router = APIRouter()

class WebhookSignatureVerifier:
    """Service for verifying webhook signatures from payment providers."""
    
    @staticmethod
    def verify_razorpay_signature(payload_body: bytes, signature: str, webhook_secret: str) -> bool:
        """
        Verify Razorpay webhook signature using HMAC-SHA256.
        
        Args:
            payload_body: Raw request body as bytes
            signature: X-Razorpay-Signature header value
            webhook_secret: Webhook secret from Razorpay dashboard
            
        Returns:
            bool: True if signature is valid, False otherwise
        """
        if not signature or not webhook_secret:
            return False
            
        try:
            # Generate expected signature
            expected_signature = hmac.new(
                webhook_secret.encode('utf-8'),
                payload_body,
                hashlib.sha256
            ).hexdigest()
            
            # Compare signatures using constant-time comparison
            return hmac.compare_digest(signature, expected_signature)
            
        except Exception as e:
            logger.error(f"Error verifying webhook signature: {e}")
            return False

@router.post("/payments", status_code=status.HTTP_200_OK, include_in_schema=False)
async def handle_payment_webhook(
    request: Request,
    x_razorpay_signature: Optional[str] = Header(None)
):
    """
    Receives, verifies, and dispatches webhooks for asynchronous processing.
    This endpoint should be protected by network rules to only allow traffic from the payment provider.
    """
    body = await request.body()
    
    # Verify webhook signature to ensure authenticity
    if not x_razorpay_signature:
        logger.warning("Webhook received without signature header")
        raise HTTPException(status_code=400, detail="Missing signature header")
    
    webhook_secret = getattr(settings, 'RAZORPAY_WEBHOOK_SECRET', None)
    if not webhook_secret:
        logger.error("RAZORPAY_WEBHOOK_SECRET not configured")
        raise HTTPException(status_code=500, detail="Webhook verification not configured")
    
    if not WebhookSignatureVerifier.verify_razorpay_signature(body, x_razorpay_signature, webhook_secret):
        logger.warning(f"Invalid webhook signature received from IP: {request.client.host if request.client else 'unknown'}")
        raise HTTPException(status_code=400, detail="Invalid signature")

    try:
        payload = await request.json()
    except JSONDecodeError:
        logger.warning("Invalid JSON payload received in webhook")
        raise HTTPException(status_code=400, detail="Invalid JSON payload")

    # Dispatch the task to Celery for background processing
    process_payment_webhook.delay(event_payload=payload, signature=x_razorpay_signature)
    
    logger.info("Payment webhook acknowledged and dispatched for processing.")
    return {"status": "acknowledged"}

5. Next Steps
With the backend architecture for monetization now fully designed (data models, services, and webhook handling), the next step is to define the API endpoints the frontend will use to initiate these payment flows.
Next File: 4.4-Backend-Payment-and-Billing-API.md will define the user-facing API for fetching plans, initiating subscription upgrades, and purchasing credit packs.