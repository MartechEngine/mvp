Phase: 6 - Content & Analysis Suite
Part: 6.8
Title: Enterprise Content & Analysis API Endpoints
Depends On: 6.7-Backend-Competitor-Analysis-Service.md
Objective: To implement the RESTful API endpoints for the Content & Analysis Suite, ensuring they are secure, multi-tenant aware, and correctly integrated with the refactored, asynchronous service layer. This API will serve as the gateway for the frontend to access all high-level intelligence.
1. Core Principle: A Unified and Secure Intelligence Gateway
Strict Authorization: Every endpoint will use a dependency to fetch the Project and verify that the current user's organization_id matches the project's, guaranteeing a user can only access data for projects they own.
Credit-Awareness: Endpoints that trigger credit-consuming actions (like Keyword or Competitor analysis) will correctly handle InsufficientCreditsError from the UnifiedAIService, returning a 402 Payment Required status code.
Asynchronous Endpoints: All endpoints will be async to properly await the service layer calls, which in turn await the AI and other I/O-bound operations.
2. API Endpoint Implementation
This file defines the API router that exposes all the analysis and generation services.
File Location: backend/app/api/v1/endpoints/intelligence.py
File Content:
import logging
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from uuid import UUID

from app.core.database import get_db
from app.api.v1.dependencies.auth_deps import get_current_active_user
from app.models.user import User as UserModel
from app.models.project import Project as ProjectModel
from app.services.keyword_analysis_service import EnterpriseKeywordAnalysisService
from app.services.backlink_analysis_service import EnterpriseBacklinkAnalysisService
from app.services.competitor_analysis_service import EnterpriseCompetitorAnalysisService
from app.services.content_generation_service import ContentGenerationService
from app.services.credit_service import CreditService
from app.core.exceptions import InsufficientCreditsError
from app.schemas import (
    keyword_analysis_schemas, 
    backlink_analysis_schemas, 
    competitor_analysis_schemas,
    content_generation_schemas
)
from app.schemas.common_schemas import APISuccessResponse

logger = logging.getLogger(__name__)
router = APIRouter()

# --- Analysis Endpoints ---

@router.get(
    "/{project_id}/keyword-analysis", 
    response_model=APISuccessResponse[keyword_analysis_schemas.KeywordAnalysisResponse], 
    summary="Get AI-Powered Keyword Analysis (Credit Cost)"
)
async def get_keyword_analysis(
    project_id: UUID,
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    # Pre-authorization credit balance check (overview.md Section 6.4)
    credit_service = CreditService(db)
    required_credits = 15  # Cost for keyword analysis
    
    if not credit_service.has_sufficient_balance(
        organization_id=str(current_user.organization_id),
        required_amount=required_credits
    ):
        raise HTTPException(
            status_code=status.HTTP_402_PAYMENT_REQUIRED,
            detail=f"Insufficient credits. Required: {required_credits} credits for keyword analysis."
        )
    
    service = EnterpriseKeywordAnalysisService(db)
    try:
        result = await service.analyze_keywords_for_project(
            user_id=str(current_user.id), 
            organization_id=str(current_user.organization_id), 
            project_id=str(project_id)
        )
        return APISuccessResponse(data=result)
    except InsufficientCreditsError as e:
        raise HTTPException(status_code=status.HTTP_402_PAYMENT_REQUIRED, detail=str(e))
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get(
    "/{project_id}/backlink-analysis", 
    response_model=APISuccessResponse[backlink_analysis_schemas.BacklinkAnalysisResponse], 
    summary="Get Backlink Profile Summary (Free)"
)
async def get_backlink_analysis(
    project_id: UUID,
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    service = EnterpriseBacklinkAnalysisService(db)
    try:
        result = service.analyze_backlinks_for_project(
            project_id=str(project_id),
            organization_id=str(current_user.organization_id)
        )
        return APISuccessResponse(data=result)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get(
    "/{project_id}/competitor-analysis", 
    response_model=APISuccessResponse[competitor_analysis_schemas.CompetitorAnalysisResponse], 
    summary="Get Competitor Analysis (Credit Cost)"
)
async def get_competitor_analysis(
    project_id: UUID,
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    # Pre-authorization credit balance check (overview.md Section 6.4)
    credit_service = CreditService(db)
    required_credits = 20  # Cost for competitor analysis
    
    if not credit_service.has_sufficient_balance(
        organization_id=str(current_user.organization_id),
        required_amount=required_credits
    ):
        raise HTTPException(
            status_code=status.HTTP_402_PAYMENT_REQUIRED,
            detail=f"Insufficient credits. Required: {required_credits} credits for competitor analysis."
        )
    
    service = EnterpriseCompetitorAnalysisService(db)
    try:
        result = await service.analyze_competitors_for_project(
            user_id=str(current_user.id), 
            organization_id=str(current_user.organization_id), 
            project_id=str(project_id)
        )
        return APISuccessResponse(data=result)
    except InsufficientCreditsError as e:
        raise HTTPException(status_code=status.HTTP_402_PAYMENT_REQUIRED, detail=str(e))
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# --- Content Generation Endpoint ---

@router.post(
    "/generate-content",
    # Define a response model for the generated asset
    summary="Generate Content from a CTA (Credit Cost)"
)
async def generate_content_from_cta(
    request: content_generation_schemas.ContentGenerationRequest,
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    # Pre-authorization credit balance check (overview.md Section 6.4)
    credit_service = CreditService(db)
    required_credits = 25  # Cost for content generation
    
    if not credit_service.has_sufficient_balance(
        organization_id=str(current_user.organization_id),
        required_amount=required_credits
    ):
        raise HTTPException(
            status_code=status.HTTP_402_PAYMENT_REQUIRED,
            detail=f"Insufficient credits. Required: {required_credits} credits for content generation."
        )
    
    service = ContentGenerationService(db)
    try:
        result = await service.generate_asset_from_cta(
            user_id=str(current_user.id),
            organization_id=str(current_user.organization_id),
            request=request
        )
        return APISuccessResponse(data=result, message="Content generated successfully.")
    except InsufficientCreditsError as e:
        raise HTTPException(status_code=status.HTTP_402_PAYMENT_REQUIRED, detail=str(e))
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

