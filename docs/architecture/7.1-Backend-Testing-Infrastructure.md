File: 7.1-Backend-Testing-Infrastructure.md
Phase: 7 - Enterprise Readiness & Finalization
Part: 7.1
Title: Enterprise Backend Testing Infrastructure
Depends On: 6.10-Frontend-Content-Hub-UI.md
Objective: To establish a comprehensive, multi-layered testing infrastructure for the FastAPI backend. This setup uses pytest as the test runner, testcontainers for ephemeral, true-to-production databases, and factory-boy for generating realistic, multi-tenant test data.
1. Core Principle: Isolated, Realistic, and Fast Tests
Isolation: Every test run must be independent. We will achieve this by spinning up a fresh, ephemeral PostgreSQL database inside a Docker container for each test session. This guarantees a clean slate and prevents tests from interfering with each other.
Realism: Tests will run against a real PostgreSQL database, not an in-memory substitute like SQLite. This ensures that our tests are validating logic against the same database engine used in production.
Developer Experience: The setup is designed to be seamless. A developer can run all backend tests with a single pytest command without needing to manually manage a test database.
2. Test Dependencies & Configuration
We will use a dedicated requirements file for testing dependencies.
File Location: backend/requirements-dev.txt
File Content:
pytest>=7.4.0
pytest-cov>=4.1.0
pytest-asyncio>=0.21.0
httpx>=0.27.0
faker>=19.0.0
factory-boy>=3.3.0
testcontainers[postgres]>=4.4.0
alembic>=1.13.0
File Location: backend/pytest.ini
File Content:
[pytest]
python_files = tests.py test_*.py *_tests.py
testpaths = tests
asyncio_mode = auto
3. Test Data Strategy: Multi-Tenant Factories
To easily create realistic test data that respects our multi-tenant architecture (User -> Membership -> Organization), we will use factory-boy.
File Location: backend/tests/factories.py
File Content:
import factory
from faker import Faker
from factory.alchemy import SQLAlchemyModelFactory

from app.models import Organization, User, Membership, MemberRole
from app.core.security import get_password_hash
from app.core.database import SessionLocal # A session to use for creating data

fake = Faker()

class OrganizationFactory(SQLAlchemyModelFactory):
    class Meta:
        model = Organization
        sqlalchemy_session = SessionLocal()
        sqlalchemy_session_persistence = "commit"

    name = factory.LazyFunction(fake.company)

class UserFactory(SQLAlchemyModelFactory):
    class Meta:
        model = User
        sqlalchemy_session = SessionLocal()
        sqlalchemy_session_persistence = "commit"

    email = factory.LazyFunction(fake.email)
    full_name = factory.LazyFunction(fake.name)
    hashed_password = factory.LazyFunction(lambda: get_password_hash("testpassword123!"))
    is_active = True
    is_verified = True

class MembershipFactory(SQLAlchemyModelFactory):
    class Meta:
        model = Membership
        sqlalchemy_session = SessionLocal()
        sqlalchemy_session_persistence = "commit"

    user = factory.SubFactory(UserFactory)
    organization = factory.SubFactory(OrganizationFactory)
    role = MemberRole.OWNER

4. Test Infrastructure Fixtures (conftest.py)
This is the core of our testing setup. It uses pytest fixtures to manage the lifecycle of the test database container and provide clean sessions and API clients to our tests.
File Location: backend/tests/conftest.py
File Content:
import pytest
from typing import Generator
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from fastapi.testclient import TestClient
from testcontainers.postgres import PostgresContainer
import os

# Set path to allow alembic to find the config
os.environ["APP_CONFIG_PATH"] = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))

from app.main import app
from app.models.base import Base
from app.core.database import get_db
from app.api.v1.dependencies.auth_deps import get_current_active_user
from tests.factories import UserFactory, MembershipFactory, OrganizationFactory
from app.models.user import User

# --- Database Fixture (using Testcontainers) ---
@pytest.fixture(scope="session")
def db_engine_url() -> Generator[str, None, None]:
    """Spins up a temporary PostgreSQL container for the entire test session."""
    with PostgresContainer("postgres:15-alpine") as postgres:
        yield postgres.get_connection_url()

@pytest.fixture(scope="session")
def db_session_factory(db_engine_url: str):
    """Creates a session factory and runs all Alembic migrations."""
    from alembic.config import Config
    from alembic import command

    engine = create_engine(db_engine_url)
    alembic_cfg = Config("alembic.ini")
    alembic_cfg.set_main_option("sqlalchemy.url", db_engine_url)
    command.upgrade(alembic_cfg, "head")
    
    return sessionmaker(autocommit=False, autoflush=False, bind=engine)

# --- Per-Test Fixtures ---
@pytest.fixture
def db(db_session_factory) -> Generator[Session, None, None]:
    """Provides a clean, transaction-isolated database session for each test."""
    session = db_session_factory()
    # Link factories to this specific session
    UserFactory._meta.sqlalchemy_session = session
    OrganizationFactory._meta.sqlalchemy_session = session
    MembershipFactory._meta.sqlalchemy_session = session
    
    try:
        yield session
    finally:
        session.rollback() # Ensure no state leaks between tests
        session.close()

@pytest.fixture
def client(db: Session) -> Generator[TestClient, None, None]:
    """Provides a FastAPI TestClient with the database dependency overridden."""
    def override_get_db():
        yield db
    
    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as c:
        yield c
    del app.dependency_overrides[get_db]

# --- Authenticated Client Fixture ---
@pytest.fixture
def authenticated_user(db: Session) -> User:
    """Creates a default authenticated user for tests."""
    membership = MembershipFactory()
    db.commit()
    return membership.user

@pytest.fixture
def authenticated_client(client: TestClient, authenticated_user: User) -> TestClient:
    """Provides an authenticated TestClient for testing protected endpoints."""
    def override_get_current_active_user():
        return authenticated_user

    app.dependency_overrides[get_current_active_user] = override_get_current_active_user
    yield client
    del app.dependency_overrides[get_current_active_user]

