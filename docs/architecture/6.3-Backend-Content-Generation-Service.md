Phase: 6 - Content & Analysis Suite
Part: 6.3
Title: Enterprise Content Generation Service
Depends On: 6.2-Backend-Shared-Data-Processing.md
Objective: To implement the EnterpriseContentGenerationService, an advanced engine for creating various types of SEO assets. This service orchestrates the entire content creation workflow, from gathering project-specific context and reserving AI credits to generating content via the UnifiedAIService and performing post-generation quality checks.
1. Core Principles: Context, Quality, and Auditability
Context is King: The service's primary differentiator is its ability to use the rich data in Project Memory. It will retrieve a project's target audience, existing keywords, and brand voice to provide the AI with deep context, resulting in highly relevant and effective content.
Quality is Non-Negotiable: Every piece of generated content can be passed through a quality assurance pipeline using the EnterpriseTextProcessor to ensure a high standard of output.
Auditability: The entire process is auditable. The final GeneratedContentAsset is linked back to the scan_result that identified the opportunity, providing a clear trail.
2. ContentGenerationService Schemas
We need schemas to handle the API request for generating content.
File Location: backend/app/schemas/content_generation_schemas.py
File Content:
from pydantic import BaseModel, Field
from typing import Dict, Any

from app.models.project_memory import AssetType

class ContentGenerationRequest(BaseModel):
    """Schema for the API request to generate a specific content asset."""
    scan_result_id: str
    asset_type: AssetType = Field(..., description="The type of asset to generate, based on the CTA.")
    # Optional context for more creative tasks, e.g., a blog post topic
    user_prompt: str | None = None
    # Add other parameters as needed, like target keywords for a meta tag
    context_data: Dict[str, Any] | None = None

3. ContentGenerationService Implementation
This service is the primary orchestrator for the "Generate" CTAs shown in the UI.
File Location: backend/app/services/content_generation_service.py
File Content:

import logging
from sqlalchemy.orm import Session
from typing import Dict, Any

from app.core.config import settings
from app.services.unified_ai_service import EnterpriseUnifiedAIService
from app.services.project_memory_service import ProjectMemoryService
from app.services.shared.text_processor import EnterpriseTextProcessor
from app.schemas.ai_service_schemas import AITaskRequest, PromptTask
from app.schemas.content_generation_schemas import ContentGenerationRequest
from app.models.audit import ScanResult
from app.models.project import Project
from app.models.project_memory import GeneratedContentAsset, AssetType

logger = logging.getLogger(__name__)

# Map the generation request to a specific AI prompt task and credit cost
ASSET_TASK_MAP = {
    "META_TAG": {"task": PromptTask.GENERATE_META_TAGS_V1, "cost": 2},
    "LLM_TXT": {"task": PromptTask.GENERATE_LLM_TXT_V1, "cost": 5},
    # Add other asset types here
}

class ContentGenerationService:
    """Orchestrates the AI content generation workflow based on scan results."""

    def __init__(self, db: Session):
        self.db = db
        self.ai_service = EnterpriseUnifiedAIService(db)
        self.memory_service = ProjectMemoryService(db)
        self.text_processor = EnterpriseTextProcessor()

    def generate_asset_from_cta(
        self,
        user_id: str,
        organization_id: str,
        request: ContentGenerationRequest
    ) -> GeneratedContentAsset:
        """
        Main entry point for generating a content asset based on a CTA.
        This workflow is atomic and handles its own transactions via the AI service.
        """
        scan_result = self.db.query(ScanResult).join(Project).filter(
            ScanResult.id == request.scan_result_id,
            Project.organization_id == organization_id # Security check
        ).first()

        if not scan_result:
            raise ValueError("Scan result not found or access denied.")

        task_info = ASSET_TASK_MAP.get(request.asset_type.value)
        if not task_info:
            raise ValueError(f"Unsupported asset type for generation: {request.asset_type.value}")

        # 1. Gather Rich Context from Project Memory
        # (This can be expanded to fetch competitor data, existing keywords, etc.)
        project_context = {
            "project_url": scan_result.audit.project.url,
            "project_name": scan_result.audit.project.name,
            # Add other relevant context here for the AI prompt
        }
        
        # 2. Prepare and Execute AI Task via the Unified AI Service
        # The AI service handles credit reservation, execution, and consumption atomically.
        ai_task_request = AITaskRequest(
            task=task_info["task"],
            project_id=str(scan_result.audit.project_id),
            user_id=user_id,
            organization_id=organization_id,
            context={**project_context, **(request.context_data or {})},
            estimated_credit_cost=task_info["cost"]
        )
        
        ai_response = self.ai_service.execute_ai_task(ai_task_request)

        if not ai_response.success or not ai_response.data:
            raise Exception(f"AI content generation failed: {ai_response.error}")

        # The AI response should contain the generated content in a structured format
        generated_content_text = ai_response.data.get("generated_content", "")

        # 3. Save the Generated Asset to Project Memory
        # This is done in a new transaction after the AI task is successfully completed and paid for.
        with self.db.begin():
            new_asset = self.memory_service.save_generated_asset(
                project_id=str(scan_result.audit.project_id),
                scan_result_id=str(scan_result.id),
                asset_type=request.asset_type,
                content=generated_content_text
            )
            self.db.commit()
            self.db.refresh(new_asset)

        logger.info(f"Content asset {new_asset.id} of type {request.asset_type.value} created successfully.")
        return new_asset

4. Next Steps
The ContentGenerationService is now designed to be a robust, atomic, and reliable engine for fulfilling the core value proposition of the DCS scan results. It correctly composes our underlying services to perform its complex task.
Next File: 6.4-Backend-Content-Strategy-Service.md will implement another key feature that builds upon this solid foundation, focusing on analyzing data to find content gaps and suggest new topics.