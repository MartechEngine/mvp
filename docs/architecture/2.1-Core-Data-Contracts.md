Phase: 2 - User Identity & Authentication
Part: 2.1
Title: Core Data Contracts: TypeScript Types & Pydantic Schemas
Depends On: 1.8-Frontend-Root-Redirect-Logic.md
Objective: To establish the definitive, shared data structures for authentication and users. This creates a strongly-typed "contract" between the FastAPI backend and the Next.js frontend, preventing data inconsistencies and improving developer experience by standardizing on Pydantic v2.
1. Backend: Pydantic Schemas
These schemas define the data structure, validation rules, and API documentation for our backend. They are the single source of truth for what our API accepts and returns.
File Location: backend/app/schemas/common_schemas.py
File Content:
from pydantic import BaseModel, Field, ConfigDict
from typing import TypeVar, Generic, Optional, List, Any

# Generic type variable for response data
DataType = TypeVar('DataType')

class APISuccessResponse(BaseModel, Generic[DataType]):
    """Standardized success response wrapper for all API endpoints."""
    success: bool = Field(True, const=True)
    data: DataType
    message: Optional[str] = None
    
    model_config = ConfigDict(from_attributes=True)

class APIErrorDetail(BaseModel):
    """Detailed error information for field-level validation errors."""
    field: Optional[str] = None
    message: str
    code: str

class APIErrorResponse(BaseModel):
    """Standardized error response wrapper for all API endpoints."""
    success: bool = Field(False, const=False)
    error: APIErrorDetail

class PaginationMetadata(BaseModel):
    """Pagination metadata for list responses."""
    page: int
    per_page: int
    total_items: int
    total_pages: int

class PaginatedResponse(BaseModel, Generic[DataType]):
    """Paginated response wrapper with data and pagination metadata."""
    data: List[DataType]
    pagination: PaginationMetadata

File Location: backend/app/schemas/auth_schemas.py
File Content:
from pydantic import BaseModel, EmailStr, Field, ConfigDict
from typing import Optional
from uuid import UUID

# --- Request Schemas ---

class UserCreate(BaseModel):
    """Schema for user registration."""
    email: EmailStr
    password: str = Field(..., min_length=8)
    full_name: str = Field(..., min_length=2)
    organization_name: str = Field(..., min_length=2, description="The name of the user's initial organization.")

class UserLogin(BaseModel):
    """Schema for user login request."""
    email: EmailStr
    password: str

class RefreshTokenRequest(BaseModel):
    """Schema for refresh token request."""
    refresh_token: str = Field(..., description="The refresh token to use for generating a new access token")

class LogoutRequest(BaseModel):
    """Schema for logout request."""
    session_id: Optional[str] = Field(None, description="Specific session ID to logout from")
    revoke_all_sessions: bool = Field(False, description="Whether to revoke all user sessions")

# --- Response Schemas ---

class Token(BaseModel):
    """Schema for JWT token pair response."""
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

class User(BaseModel):
    """Schema for the authenticated user profile response."""
    id: UUID
    email: EmailStr
    full_name: str
    is_active: bool
    is_verified: bool

    model_config = ConfigDict(from_attributes=True)

2. Frontend: TypeScript Types
These types mirror the backend schemas, providing end-to-end type safety for our frontend application. This is the "contract" our frontend code will adhere to.
File Location: frontend/src/types/api.ts
File Content:
// --- Generic API Response Wrappers ---

export interface ApiSuccessResponse<T> {
  success: true;
  data: T;
  message?: string;
}

export interface ApiErrorDetail {
  field?: string;
  message: string;
  code: string;
}

export interface ApiErrorResponse {
  success: false;
  error: ApiErrorDetail;
}

// A type guard to easily differentiate between success and error responses
export function isApiErrorResponse(response: any): response is ApiErrorResponse {
  return response && response.success === false && response.error !== undefined;
}

export interface PaginationMetadata {
  page: number;
  per_page: number;
  total_items: number;
  total_pages: number;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: PaginationMetadata;
}

File Location: frontend/src/types/auth.ts
File Content:
// --- Authentication and User Types ---

export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  token_type: 'bearer';
}

export interface User {
  id: string; // UUIDs are strings in TypeScript
  email: string;
  full_name: string;
  is_active: boolean;
  is_verified: boolean;
}

// Payloads for authentication forms
export interface RegisterPayload {
  email: string;
  password: string;
  full_name: string;
  organization_name: string;
}

export interface LoginPayload {
  email: string;
  password: string;
}
3. Integration & Next Steps
Enforcement: These schemas and types are now the "single source of truth" for our API contract. The FastAPI backend will use the Pydantic schemas to automatically validate incoming request bodies and serialize outgoing responses.
Frontend Usage: The frontend apiClient and service layers will use these TypeScript types to ensure that all data flowing through the application is strongly typed, reducing runtime errors and improving developer productivity.
Next File: The next step (2.2-Data-Models-Auth-and-Users.md) is to implement the actual SQLAlchemy database models that these schemas represent.