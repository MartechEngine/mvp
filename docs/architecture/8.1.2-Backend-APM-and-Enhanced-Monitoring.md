Phase: 8 - Operations and Compliance
Part: 8.1.2
Title: Backend APM and Enhanced Monitoring
Depends On: 8.1-Phase-8-Operations-and-Compliance.md, 8.1.1-Backend-Rate-Limiting-and-API-Protection.md
Objective: To implement comprehensive Application Performance Monitoring (APM), error tracking, business metrics, and observability infrastructure that provides real-time insights into system health, performance bottlenecks, and user behavior patterns.

## 1. Core Principles

**Full-Stack Observability**: Monitor every layer from infrastructure to user experience.
**Proactive Detection**: Identify issues before they impact users through predictive alerting.
**Business Intelligence**: Track key business metrics alongside technical performance.
**Privacy Compliant**: Ensure all monitoring respects user privacy and data protection regulations.

## 2. APM Integration Architecture

### Datadog APM Integration
```python
# File: backend/app/core/monitoring.py
import logging
import time
import functools
from typing import Dict, Any, Optional, Callable
from ddtrace import tracer, patch_all
from ddtrace.contrib.fastapi import patch as patch_fastapi
import ddtrace.ext.errors as dd_errors

from app.core.config import settings

logger = logging.getLogger(__name__)

# Initialize Datadog tracing
if settings.DATADOG_ENABLED:
    patch_all()  # Auto-instrument common libraries
    patch_fastapi()  # Specific FastAPI instrumentation

class APMService:
    """
    Centralized APM service for monitoring and metrics.
    """
    
    def __init__(self):
        self.enabled = settings.DATADOG_ENABLED
        if self.enabled:
            from datadog import initialize, statsd
            initialize(
                api_key=settings.DATADOG_API_KEY,
                app_key=settings.DATADOG_APP_KEY,
                host_name=settings.HOSTNAME
            )
            self.statsd = statsd
        else:
            self.statsd = None
    
    def trace_function(self, service_name: str, operation_name: str = None):
        """Decorator to trace function execution."""
        def decorator(func: Callable):
            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs):
                if not self.enabled:
                    return await func(*args, **kwargs)
                
                span_name = operation_name or f"{func.__module__}.{func.__name__}"
                with tracer.trace(span_name, service=service_name) as span:
                    try:
                        span.set_tag("function.name", func.__name__)
                        span.set_tag("function.module", func.__module__)
                        
                        start_time = time.time()
                        result = await func(*args, **kwargs)
                        
                        execution_time = time.time() - start_time
                        span.set_metric("execution_time", execution_time)
                        self.record_metric(f"{service_name}.{func.__name__}.duration", execution_time)
                        self.record_metric(f"{service_name}.{func.__name__}.success", 1)
                        
                        return result
                        
                    except Exception as e:
                        span.set_error(e)
                        span.set_tag(dd_errors.ERROR_MSG, str(e))
                        span.set_tag(dd_errors.ERROR_TYPE, type(e).__name__)
                        
                        self.record_metric(f"{service_name}.{func.__name__}.error", 1)
                        raise
            
            @functools.wraps(func)
            def sync_wrapper(*args, **kwargs):
                if not self.enabled:
                    return func(*args, **kwargs)
                
                span_name = operation_name or f"{func.__module__}.{func.__name__}"
                with tracer.trace(span_name, service=service_name) as span:
                    try:
                        span.set_tag("function.name", func.__name__)
                        span.set_tag("function.module", func.__module__)
                        
                        start_time = time.time()
                        result = func(*args, **kwargs)
                        
                        execution_time = time.time() - start_time
                        span.set_metric("execution_time", execution_time)
                        self.record_metric(f"{service_name}.{func.__name__}.duration", execution_time)
                        self.record_metric(f"{service_name}.{func.__name__}.success", 1)
                        
                        return result
                        
                    except Exception as e:
                        span.set_error(e)
                        span.set_tag(dd_errors.ERROR_MSG, str(e))
                        span.set_tag(dd_errors.ERROR_TYPE, type(e).__name__)
                        
                        self.record_metric(f"{service_name}.{func.__name__}.error", 1)
                        raise
            
            import asyncio
            if asyncio.iscoroutinefunction(func):
                return async_wrapper
            else:
                return sync_wrapper
        
        return decorator
    
    def record_metric(self, metric_name: str, value: float, tags: Optional[Dict[str, str]] = None):
        """Record a custom metric."""
        if not self.enabled or not self.statsd:
            return
        
        try:
            tag_list = [f"{k}:{v}" for k, v in (tags or {}).items()]
            self.statsd.gauge(metric_name, value, tags=tag_list)
        except Exception as e:
            logger.error(f"Failed to record metric {metric_name}: {e}")
    
    def increment_counter(self, metric_name: str, value: int = 1, tags: Optional[Dict[str, str]] = None):
        """Increment a counter metric."""
        if not self.enabled or not self.statsd:
            return
        
        try:
            tag_list = [f"{k}:{v}" for k, v in (tags or {}).items()]
            self.statsd.increment(metric_name, value, tags=tag_list)
        except Exception as e:
            logger.error(f"Failed to increment counter {metric_name}: {e}")

# Global APM instance
apm = APMService()
```

### Sentry Error Tracking Integration
```python
# File: backend/app/core/error_tracking.py
import logging
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration
from sentry_sdk.integrations.celery import CeleryIntegration
from typing import Dict, Any, Optional

from app.core.config import settings

logger = logging.getLogger(__name__)

class ErrorTrackingService:
    """
    Centralized error tracking and reporting service.
    """
    
    def __init__(self):
        self.enabled = settings.SENTRY_ENABLED
        if self.enabled:
            self._initialize_sentry()
    
    def _initialize_sentry(self):
        """Initialize Sentry with proper configuration."""
        sentry_sdk.init(
            dsn=settings.SENTRY_DSN,
            environment=settings.ENVIRONMENT,
            release=settings.APP_VERSION,
            integrations=[
                FastApiIntegration(auto_enabling_integrations=False),
                SqlalchemyIntegration(),
                CeleryIntegration(),
            ],
            traces_sample_rate=0.1,  # 10% of transactions
            profiles_sample_rate=0.1,  # 10% for profiling
            before_send=self._filter_errors,
        )
        
        logger.info("Sentry error tracking initialized")
    
    def _filter_errors(self, event, hint):
        """Filter out noise from error reporting."""
        if 'exc_info' in hint:
            exc_type, exc_value, tb = hint['exc_info']
            
            # Filter out validation errors (they're user errors, not system errors)
            if exc_type.__name__ in ['ValidationError', 'HTTPException']:
                return None
            
            # Filter out rate limiting errors
            if exc_type.__name__ == 'RateLimitExceeded':
                return None
        
        return event
    
    def capture_exception(self, error: Exception, context: Optional[Dict[str, Any]] = None,
                         user_id: Optional[str] = None, organization_id: Optional[str] = None):
        """Capture an exception with additional context."""
        if not self.enabled:
            return
        
        with sentry_sdk.configure_scope() as scope:
            if user_id:
                scope.set_user({
                    "id": user_id,
                    "organization_id": organization_id
                })
            
            if context:
                for key, value in context.items():
                    scope.set_context(key, value)
            
            sentry_sdk.capture_exception(error)
    
    def capture_message(self, message: str, level: str = "info", 
                       context: Optional[Dict[str, Any]] = None):
        """Capture a custom message."""
        if not self.enabled:
            return
        
        with sentry_sdk.configure_scope() as scope:
            if context:
                for key, value in context.items():
                    scope.set_context(key, value)
            
            sentry_sdk.capture_message(message, level=level)

# Global error tracking instance
error_tracker = ErrorTrackingService()
```

## 3. Business Metrics Tracking

```python
# File: backend/app/services/business_metrics_service.py
import logging
from typing import Dict, Any
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from sqlalchemy import func, and_

from app.core.monitoring import apm
from app.models.user import User
from app.models.subscription import Subscription
from app.models.scan_result import ScanResult
from app.models.credit_ledger import CreditLedger

logger = logging.getLogger(__name__)

class BusinessMetricsService:
    """
    Service for tracking and reporting business metrics.
    """
    
    def __init__(self, db: Session):
        self.db = db
    
    def track_user_registration(self, user: User):
        """Track new user registration."""
        apm.increment_counter("business.user.registration", 1, {
            "plan": "free_trial",
            "source": "organic"
        })
        
        apm.record_metric("business.user.total_count", self._get_total_users())
    
    def track_subscription_conversion(self, user: User, subscription: Subscription):
        """Track subscription conversion."""
        days_to_convert = (subscription.created_at - user.created_at).days
        
        apm.record_metric("business.subscription.conversion", 1, {
            "plan": subscription.plan_id,
            "user_id": str(user.id)
        })
        
        apm.record_metric("business.subscription.time_to_convert_days", days_to_convert, {
            "plan": subscription.plan_id
        })
        
        self._update_mrr_metrics()
    
    def track_scan_completion(self, scan_result: ScanResult):
        """Track DCS scan completion."""
        apm.increment_counter("business.scan.completed", 1, {
            "audit_type": scan_result.audit.audit_type,
            "organization_id": str(scan_result.audit.project.organization_id)
        })
        
        if scan_result.dcs_score is not None:
            apm.record_metric("business.scan.dcs_score", scan_result.dcs_score, {
                "audit_type": scan_result.audit.audit_type
            })
    
    def track_feature_usage(self, feature_name: str, user_id: str, 
                           organization_id: str, metadata: Optional[Dict[str, Any]] = None):
        """Track feature usage for product analytics."""
        tags = {
            "feature": feature_name,
            "user_id": user_id,
            "organization_id": organization_id
        }
        
        if metadata:
            for key, value in metadata.items():
                if key in ['project_type', 'content_type', 'analysis_type']:
                    tags[key] = str(value)
        
        apm.increment_counter("business.feature.usage", 1, tags)
    
    def generate_daily_metrics_report(self) -> Dict[str, Any]:
        """Generate daily business metrics report."""
        today = datetime.utcnow().date()
        
        new_users_today = self.db.query(User).filter(
            func.date(User.created_at) == today
        ).count()
        
        new_subscriptions_today = self.db.query(Subscription).filter(
            func.date(Subscription.created_at) == today
        ).count()
        
        scans_completed_today = self.db.query(ScanResult).filter(
            func.date(ScanResult.created_at) == today
        ).count()
        
        credits_consumed_today = self.db.query(
            func.sum(CreditLedger.amount)
        ).filter(
            and_(
                func.date(CreditLedger.created_at) == today,
                CreditLedger.amount < 0
            )
        ).scalar() or 0
        
        report = {
            "date": today.isoformat(),
            "users": {
                "new_registrations": new_users_today,
                "total_active": self._get_active_users_count(days=30)
            },
            "subscriptions": {
                "new_conversions": new_subscriptions_today,
                "total_active": self._get_active_subscriptions_count(),
                "mrr": self._calculate_current_mrr()
            },
            "scans": {
                "completed_today": scans_completed_today,
                "average_dcs_score": self._get_average_dcs_score(days=1)
            },
            "credits": {
                "consumed_today": abs(credits_consumed_today)
            }
        }
        
        # Send metrics to monitoring
        for category, metrics in report.items():
            if isinstance(metrics, dict):
                for metric_name, value in metrics.items():
                    if isinstance(value, (int, float)):
                        apm.record_metric(f"business.daily.{category}.{metric_name}", value)
        
        return report
    
    def _get_total_users(self) -> int:
        return self.db.query(User).count()
    
    def _get_active_users_count(self, days: int) -> int:
        cutoff = datetime.utcnow() - timedelta(days=days)
        return self.db.query(User).filter(User.last_login_at >= cutoff).count()
    
    def _get_active_subscriptions_count(self) -> int:
        return self.db.query(Subscription).filter(
            Subscription.status == 'active'
        ).count()
    
    def _calculate_current_mrr(self) -> float:
        active_subscriptions = self.db.query(Subscription).filter(
            Subscription.status == 'active'
        ).all()
        
        mrr = 0.0
        for sub in active_subscriptions:
            if sub.billing_cycle == 'monthly':
                mrr += sub.amount
            elif sub.billing_cycle == 'yearly':
                mrr += sub.amount / 12
        
        return mrr
    
    def _update_mrr_metrics(self):
        current_mrr = self._calculate_current_mrr()
        apm.record_metric("business.revenue.mrr", current_mrr)
    
    def _get_average_dcs_score(self, days: int) -> Optional[float]:
        cutoff = datetime.utcnow() - timedelta(days=days)
        
        result = self.db.query(func.avg(ScanResult.dcs_score)).filter(
            and_(
                ScanResult.created_at >= cutoff,
                ScanResult.dcs_score.isnot(None)
            )
        ).scalar()
        
        return float(result) if result else None
```

## 4. Performance Monitoring Middleware

```python
# File: backend/app/middleware/performance_monitoring.py
import time
import logging
from fastapi import Request, Response
from typing import Callable

from app.core.monitoring import apm
from app.core.error_tracking import error_tracker

logger = logging.getLogger(__name__)

class PerformanceMonitoringMiddleware:
    """
    Middleware to monitor API performance and business metrics.
    """
    
    async def __call__(self, request: Request, call_next: Callable) -> Response:
        start_time = time.time()
        
        method = request.method
        path = request.url.path
        user_agent = request.headers.get("user-agent", "")
        
        error_tracker.add_breadcrumb(
            message=f"{method} {path}",
            category="http",
            data={
                "method": method,
                "path": path,
                "user_agent": user_agent
            }
        )
        
        try:
            response = await call_next(request)
            
            response_time = time.time() - start_time
            
            apm.record_metric("api.response_time", response_time, {
                "method": method,
                "endpoint": path,
                "status_code": str(response.status_code)
            })
            
            apm.increment_counter("api.requests", 1, {
                "method": method,
                "endpoint": path,
                "status_code": str(response.status_code)
            })
            
            response.headers["X-Response-Time"] = f"{response_time:.3f}s"
            
            if response_time > 2.0:
                logger.warning(f"Slow request: {method} {path} took {response_time:.3f}s")
                apm.increment_counter("api.slow_requests", 1, {
                    "method": method,
                    "endpoint": path
                })
            
            return response
            
        except Exception as e:
            response_time = time.time() - start_time
            
            apm.increment_counter("api.errors", 1, {
                "method": method,
                "endpoint": path,
                "error_type": type(e).__name__
            })
            
            error_tracker.capture_exception(e, {
                "request": {
                    "method": method,
                    "path": path,
                    "response_time": response_time
                }
            })
            
            raise
```

## 5. Health Check and Monitoring Endpoints

```python
# File: backend/app/api/v1/endpoints/monitoring.py
import logging
import time
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from sqlalchemy import text

from app.core.database import get_db
from app.core.config import settings
from app.services.business_metrics_service import BusinessMetricsService
from app.api.v1.dependencies.auth_deps import require_admin

logger = logging.getLogger(__name__)
router = APIRouter()

@router.get("/health")
async def health_check(db: Session = Depends(get_db)):
    """Comprehensive health check endpoint."""
    health_status = {
        "status": "healthy",
        "timestamp": time.time(),
        "version": settings.APP_VERSION,
        "environment": settings.ENVIRONMENT,
        "checks": {}
    }
    
    # Database health check
    try:
        db.execute(text("SELECT 1"))
        health_status["checks"]["database"] = {"status": "healthy"}
    except Exception as e:
        health_status["checks"]["database"] = {"status": "unhealthy", "error": str(e)}
        health_status["status"] = "unhealthy"
    
    # Redis health check
    try:
        import redis
        r = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, 
                       password=settings.REDIS_PASSWORD)
        r.ping()
        health_status["checks"]["redis"] = {"status": "healthy"}
    except Exception as e:
        health_status["checks"]["redis"] = {"status": "unhealthy", "error": str(e)}
        health_status["status"] = "degraded"
    
    return health_status

@router.get("/metrics")
async def get_metrics(
    db: Session = Depends(get_db),
    current_user = Depends(require_admin)
):
    """Get system metrics (admin only)."""
    metrics_service = BusinessMetricsService(db)
    
    daily_report = metrics_service.generate_daily_metrics_report()
    
    system_metrics = {
        "system": {
            "uptime": time.time() - settings.START_TIME,
            "version": settings.APP_VERSION,
            "environment": settings.ENVIRONMENT
        },
        "business": daily_report
    }
    
    return system_metrics
```

## 6. Configuration Updates

```python
# File: backend/app/core/config.py (additions)
import time

class Settings(BaseSettings):
    # ... existing settings ...
    
    # Monitoring Configuration
    DATADOG_ENABLED: bool = False
    DATADOG_API_KEY: Optional[SecretStr] = None
    DATADOG_APP_KEY: Optional[SecretStr] = None
    HOSTNAME: str = "martechengine-api"
    
    # Error Tracking
    SENTRY_ENABLED: bool = False
    SENTRY_DSN: Optional[str] = None
    
    # Application Metadata
    APP_VERSION: str = "1.0.0"
    START_TIME: float = time.time()
    
    # Performance Thresholds
    SLOW_QUERY_THRESHOLD: float = 1.0  # seconds
    SLOW_REQUEST_THRESHOLD: float = 2.0  # seconds
```

## 7. Integration with FastAPI Application

```python
# File: backend/app/main.py (modifications)
from app.middleware.performance_monitoring import PerformanceMonitoringMiddleware
from app.core.monitoring import apm
from app.core.error_tracking import error_tracker

app = FastAPI(title="MartechEngine API")

# Add monitoring middleware
app.add_middleware(PerformanceMonitoringMiddleware)

# Initialize monitoring on startup
@app.on_event("startup")
async def startup_event():
    logger.info("Starting MartechEngine API")
    apm.record_metric("app.startup", 1)

@app.on_event("shutdown")
async def shutdown_event():
    logger.info("Shutting down MartechEngine API")
    apm.record_metric("app.shutdown", 1)
```

## 8. Next Steps

This APM and Enhanced Monitoring system provides:
- ✅ **Full-stack observability** with Datadog and Sentry integration
- ✅ **Business metrics tracking** for key performance indicators
- ✅ **Performance monitoring** with automatic slow request detection
- ✅ **Error tracking** with context and user information
- ✅ **Health checks** for all critical system components

**Next File**: Create the Data Export Service architecture for enterprise users to export their data.
