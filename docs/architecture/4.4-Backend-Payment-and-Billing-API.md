Phase: 4 - Core Application & Billing
Part: 4.4
Title: Backend Payment & Billing API
Depends On: 4.3-Backend-Webhook-Service.md
Objective: To define a secure and logical set of API endpoints for the frontend to manage the entire subscription lifecycle, purchase credits, and retrieve billing history. This API enforces the subscription-first business rule, where users must have an active paid plan to purchase add-on credits.
1. Core Principles
Resource-Oriented Structure: The API is structured around clear resources (/plans, /subscriptions, /credits, /billing), making it intuitive and RESTful.
Dependency Injection: Endpoints will use FastAPI's Depends to inject service instances, keeping the API layer thin and focused on HTTP concerns.
Explicit Business Logic: The API layer acts as the gatekeeper for our business rules. For example, the /credits/purchase endpoint will explicitly check for an active subscription before allowing a purchase.
2. Pydantic Schemas for Billing API
We need to define the request and response models for our billing endpoints.
File Location: backend/app/schemas/billing_schemas.py
File Content:
from pydantic import BaseModel, Field, ConfigDict
from typing import List, Optional
from uuid import UUID
from datetime import datetime

from app.models.plan import PlanTier
from app.models.subscription import SubscriptionStatus
from app.models.credit_ledger import CreditActionType

# --- Response Schemas ---

class Plan(BaseModel):
    id: UUID
    name: str
    tier: PlanTier
    price_monthly: float
    currency: str
    allowed_projects: int
    monthly_credits: int
    can_purchase_credits: bool

    model_config = ConfigDict(from_attributes=True)


class Subscription(BaseModel):
    id: UUID
    status: SubscriptionStatus
    trial_ends_at: Optional[datetime]
    plan: Plan

    model_config = ConfigDict(from_attributes=True)


class CreditPurchaseInitiation(BaseModel):
    """Response when initiating a credit purchase, providing details for the payment gateway."""
    purchase_id: UUID
    provider_order_id: str
    amount: float
    currency: str
    credits_to_be_granted: int


class CreditLedgerEntry(BaseModel):
    id: UUID
    amount: int
    transaction_type: CreditActionType
    description: Optional[str]
    created_at: datetime
    
    model_config = ConfigDict(from_attributes=True)


# --- Request Schemas ---

class CreditPurchaseRequest(BaseModel):
    """Request to purchase a credit pack."""
    credit_package_id: UUID # Represents a predefined package of credits for a certain price

class SubscriptionUpgradeRequest(BaseModel):
    """Request to upgrade to a new paid plan."""
    new_plan_id: UUID

3. Billing & Payment API Endpoints
This file contains the router for all user-facing billing and payment endpoints.
File Location: backend/app/api/v1/endpoints/billing.py
File Content:
import logging
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.api.v1.dependencies.auth_deps import get_current_active_user
from app.models.user import User as UserModel
from app.models.plan import Plan as PlanModel
from app.models.subscription import Subscription as SubscriptionModel, SubscriptionStatus
from app.models.credit_ledger import CreditLedger as CreditLedgerModel
from app.models.credit_package import CreditPackage as CreditPackageModel
from app.models.credit_purchase import CreditPurchase as CreditPurchaseModel, PurchaseStatus
from app.schemas.billing_schemas import (
    Plan as PlanSchema,
    Subscription as SubscriptionSchema,
    CreditPurchaseRequest,
    CreditPurchaseInitiation,
    CreditLedgerEntry
)
from app.schemas.common_schemas import APISuccessResponse
from app.services.payment_gateway_service import PaymentGatewayService

logger = logging.getLogger(__name__)
router = APIRouter()

@router.get(
    "/plans",
    response_model=APISuccessResponse[List[PlanSchema]],
    summary="List available subscription plans"
)
def list_available_plans(db: Session = Depends(get_db)):
    """
    Returns a list of all available subscription plans for the pricing page.
    """
    plans = db.query(PlanModel).order_by(PlanModel.price_monthly).all()
    return APISuccessResponse(data=plans)


@router.get(
    "/subscription",
    response_model=APISuccessResponse[SubscriptionSchema],
    summary="Get user's subscription status"
)
def get_subscription_status(
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Retrieves the current subscription status for the user's organization.
    """
    subscription = db.query(SubscriptionModel).filter(
        SubscriptionModel.organization_id == current_user.organization_id
    ).first()
    
    if not subscription:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Subscription not found.")
        
    return APISuccessResponse(data=subscription)


@router.post(
    "/credits/purchase",
    response_model=APISuccessResponse[CreditPurchaseInitiation],
    summary="Initiate a credit purchase"
)
def purchase_credits(
    request: CreditPurchaseRequest,
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Initiates the purchase of an add-on credit package.
    - Business Rule: Verifies that the organization has an active, paid subscription.
    """
    try:
        # 1. Check if the user's plan allows purchasing credits
        subscription = db.query(SubscriptionModel).filter(
            SubscriptionModel.organization_id == current_user.organization_id
        ).first()

        if not subscription:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="No subscription found for this organization."
            )
            
        if subscription.status != SubscriptionStatus.ACTIVE:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Subscription must be active to purchase credits."
            )

        if not subscription.plan.can_purchase_credits:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Your current plan does not allow purchasing additional credits. Please upgrade to a paid plan."
            )

        # 2. Validate the credit package exists
        credit_package = db.query(CreditPackageModel).filter(
            CreditPackageModel.id == request.credit_package_id
        ).first()
        
        if not credit_package:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Credit package not found."
            )

        # 3. Create purchase record in pending state
        purchase_record = CreditPurchaseModel(
            organization_id=current_user.organization_id,
            user_id=current_user.id,
            credit_package_id=request.credit_package_id,
            amount=credit_package.price,
            currency=credit_package.currency,
            credits_to_be_granted=credit_package.credits,
            status=PurchaseStatus.PENDING
        )
        db.add(purchase_record)
        db.flush()

        # 4. Initiate purchase with payment provider
        payment_service = PaymentGatewayService(db)
        
        try:
            payment_order = payment_service.create_credit_purchase_order(
                purchase_id=str(purchase_record.id),
                amount=credit_package.price,
                currency=credit_package.currency,
                description=f"Credit Package: {credit_package.name}",
                user_email=current_user.email,
                organization_id=str(current_user.organization_id)
            )
            
            # Update purchase record with payment provider details
            purchase_record.provider_order_id = payment_order.order_id
            purchase_record.payment_url = payment_order.payment_url
            db.commit()
            
            logger.info(f"Credit purchase initiated for organization {current_user.organization_id}, amount: {credit_package.price}")
            
            return APISuccessResponse(
                data={
                    "purchase_id": str(purchase_record.id),
                    "provider_order_id": payment_order.order_id,
                    "payment_url": payment_order.payment_url,
                    "amount": float(credit_package.price),
                    "currency": credit_package.currency,
                    "credits_to_be_granted": credit_package.credits,
                    "expires_at": payment_order.expires_at.isoformat() if payment_order.expires_at else None
                },
                message="Credit purchase initiated successfully."
            )
            
        except Exception as payment_error:
            # Mark purchase as failed and rollback
            purchase_record.status = PurchaseStatus.FAILED
            purchase_record.failure_reason = str(payment_error)
            db.commit()
            
            logger.error(f"Payment gateway error for purchase {purchase_record.id}: {payment_error}")
            raise HTTPException(
                status_code=status.HTTP_502_BAD_GATEWAY,
                detail="Payment service temporarily unavailable. Please try again later."
            )
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error in credit purchase: {e}")
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An unexpected error occurred while processing your request."
        )


@router.get(
    "/billing/history",
    response_model=APISuccessResponse[List[CreditLedgerEntry]],
    summary="Get billing history"
)
def get_billing_history(
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Retrieves the organization's transaction history from the CreditLedger.
    """
    history = db.query(CreditLedgerModel).filter(
        CreditLedgerModel.organization_id == current_user.organization_id
    ).order_by(CreditLedgerModel.created_at.desc()).limit(100).all()
    
    return APISuccessResponse(data=history)

4. Next Steps
With the backend architecture for monetization now fully designed from data models to services and APIs, the next phase is to build the frontend components that will interact with this system.
Next File: 4.5-Frontend-Billing-Hooks.md will create the React Query hooks that align with these new backend API endpoints, providing a clean data layer for our UI.