Phase: 4 - Core Application & Billing
Part: 4.1
Title: Data Models for Billing, Subscriptions & Credits
Depends On: 3.7-Frontend-User-Profile-UI.md
Objective: To define the robust SQLAlchemy data models for the entire billing and monetization system. This architecture is built on a subscription-first model and introduces an immutable credit ledger for fully auditable financial transactions.
1. Core Principle: The Immutable Ledger
Our credit management system is designed like a bank ledger. We will never update a user's credit balance directly. Instead, every change is recorded as a new, immutable transaction in the credit_ledger table. An organization's current balance is calculated by summing all their completed transactions. This append-only approach provides a complete, auditable, and tamper-proof history of all financial activities, which is critical for compliance and debugging.
2. Plan Model
Defines the available subscription tiers for the application.
File Location: backend/app/models/plan.py
File Content:
import enum
from sqlalchemy import Column, Integer, String, Numeric, Boolean

from app.models.base import Base, BaseMixin

class PlanTier(str, enum.Enum):
    FREE = "FREE"
    PAID = "PAID"

class Plan(Base, BaseMixin):
    __tablename__ = 'plans'

    name = Column(String, nullable=False, unique=True) # e.g., "Free Trial", "Pro Plan"
    tier = Column(Enum(PlanTier), nullable=False, default=PlanTier.FREE)
    
    price_monthly = Column(Numeric(10, 2), nullable=False, default=0.00)
    currency = Column(String(3), nullable=False, default='USD')
    
    # Business logic fields
    allowed_projects = Column(Integer, nullable=False, default=1)
    monthly_credits = Column(Integer, nullable=False, default=500)
    can_purchase_credits = Column(Boolean, default=False, nullable=False)

3. Subscription Model
Tracks an organization's subscription to a specific Plan.
File Location: backend/app/models/subscription.py
File Content:
import enum
from sqlalchemy import Column, String, ForeignKey, DateTime, func
from sqlalchemy.orm import relationship

from app.models.base import Base, BaseMixin

class SubscriptionStatus(str, enum.Enum):
    TRIALING = "TRIALING"
    ACTIVE = "ACTIVE"
    TRIAL_EXPIRED = "TRIAL_EXPIRED"
    CANCELLED = "CANCELLED"

class Subscription(Base, BaseMixin):
    __tablename__ = 'subscriptions'

    organization_id = Column(ForeignKey('organizations.id', ondelete="CASCADE"), nullable=False, unique=True)
    plan_id = Column(ForeignKey('plans.id', ondelete="RESTRICT"), nullable=False)
    
    status = Column(Enum(SubscriptionStatus), nullable=False, default=SubscriptionStatus.TRIALING)
    
    # The timestamp when the 7-day trial period ends.
    trial_ends_at = Column(DateTime(timezone=True), nullable=True)
    
    # External ID from the payment provider (e.g., Razorpay subscription_id)
    provider_subscription_id = Column(String, nullable=True, unique=True)
    
    # Billing cycle tracking for monthly credit refills
    last_refill_at = Column(DateTime(timezone=True), nullable=True, index=True)
    billing_cycle_anchor_at = Column(DateTime(timezone=True), nullable=True, index=True)

    organization = relationship("Organization", back_populates="subscription")
    plan = relationship("Plan")

# To complete the bidirectional relationship, add the back-reference to the Organization model.
**File to Modify:** `backend/app/models/organization.py`
**Content to Add:**
```python
# In backend/app/models/organization.py
# ... (inside the Organization class) ...
    subscription = relationship("Subscription", back_populates="organization", uselist=False, cascade="all, delete-orphan")

4. CreditLedger Model (Immutable)
An immutable, append-only log of all credit transactions. This is the source of truth for an organization's credit history.
File Location: backend/app/models/credit_ledger.py
File Content:
import enum
from sqlalchemy import Column, Integer, String, ForeignKey, Text
from sqlalchemy.orm import relationship

from app.models.base import Base, BaseMixin

class CreditActionType(str, enum.Enum):
    SCAN = "SCAN"
    GENERATION = "GENERATION"
    REFILL = "REFILL"
    REFUND = "REFUND"
    SIGNUP_BONUS = "SIGNUP_BONUS"

class CreditTransactionStatus(str, enum.Enum):
    RESERVED = "RESERVED"
    CONSUMED = "CONSUMED"
    REFUNDED = "REFUNDED"
    FAILED = "FAILED"

class CreditLedger(Base, BaseMixin):
    __tablename__ = 'credit_ledger'

    organization_id = Column(ForeignKey('organizations.id', ondelete="RESTRICT"), nullable=False, index=True)
    user_id = Column(ForeignKey('users.id', ondelete="SET NULL"), nullable=True) # User who initiated
    
    # The amount of credits added or removed. Positive for additions, negative for deductions.
    amount = Column(Integer, nullable=False)
    
    # Enhanced fields from overview.md Section 6.1
    action_type = Column(Enum(CreditActionType), nullable=False, index=True)
    status = Column(Enum(CreditTransactionStatus), nullable=False, default=CreditTransactionStatus.RESERVED, index=True)
    
    # Reference to the source record (audit_id, generated_content_asset_id, etc.)
    reference_id = Column(String, nullable=True, index=True)
    
    # Failure reason for REFUNDED or FAILED transactions
    reason = Column(Text, nullable=True)
    
    # Self-referencing key to link retry attempts to original failed transactions
    retry_of_ledger_id = Column(ForeignKey('credit_ledger.id'), nullable=True, index=True)
    
    # Legacy description field (kept for backward compatibility)
    description = Column(Text, nullable=True)

    # Relationships
    organization = relationship("Organization")
    user = relationship("User")
    retry_of = relationship("CreditLedger", remote_side="CreditLedger.id")
    
    # Indexes for performance
    __table_args__ = (
        Index('idx_credit_ledger_org_status', 'organization_id', 'status'),
        Index('idx_credit_ledger_action_status', 'action_type', 'status'),
        Index('idx_credit_ledger_reference', 'reference_id'),
    )

5. CreditPurchase Model
Represents a one-time purchase of a credit pack.
File Location: backend/app/models/credit_purchase.py
File Content:
import enum
from sqlalchemy import Column, String, ForeignKey, Numeric, Integer
from sqlalchemy.orm import relationship

from app.models.base import Base, BaseMixin

class PurchaseStatus(str, enum.Enum):
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"

class CreditPurchase(Base, BaseMixin):
    __tablename__ = 'credit_purchases'

    organization_id = Column(ForeignKey('organizations.id', ondelete="CASCADE"), nullable=False)
    user_id = Column(ForeignKey('users.id', ondelete="SET NULL"), nullable=True)
    
    # External ID from payment provider (e.g., Razorpay order_id)
    provider_order_id = Column(String, nullable=False, unique=True)
    
    status = Column(Enum(PurchaseStatus), nullable=False, default=PurchaseStatus.PENDING)
    amount_paid = Column(Numeric(10, 2), nullable=False)
    currency = Column(String(3), nullable=False, default='USD')
    credits_granted = Column(Integer, nullable=False)

    organization = relationship("Organization")
    user = relationship("User")

6. Alembic Migration
After creating these model files, we must generate a new migration to apply all the schema changes.
Execution Command (run in the backend directory):
alembic revision --autogenerate -m "Create billing, subscription, and credit models"
alembic upgrade head

7. Next Steps
With the foundational database schema for our entire monetization system now defined, we are ready to build the services that will interact with these tables.
Next File: 4.2-Backend-Subscription-Service.md will implement the SubscriptionService, which will manage the lifecycle of Subscription objects (trial creation, upgrades, cancellations).