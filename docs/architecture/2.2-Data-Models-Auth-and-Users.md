Phase: 2 - User Identity & Authentication
Part: 2.2
Title: Data Models for Authentication, Organizations & Multi-Tenancy
Depends On: 2.1-Core-Data-Contracts.md
Objective: To define the core SQLAlchemy data models for authentication and multi-tenancy. This structure establishes a clear separation between a user's identity and their role within an organization, forming the foundation for a secure, multi-tenant application.
1. Core Architectural Principle: Decoupling User and Tenant
The architecture is built on a standard, robust pattern for multi-tenant applications:
User: Represents an individual's login credentials and personal identity. A User can exist independently.
Organization: The central "tenant" model. An Organization owns resources like projects and subscriptions.
Membership: A junction (or association) table that links a User to an Organization with a specific role. This is the key to multi-tenancy, as one user can eventually belong to multiple organizations with different roles in each.
2. Base Model Mixins
We will create a base model file to define common columns that will be reused across many of our tables, such as primary keys and timestamps. This reduces boilerplate and ensures consistency.
File Location: backend/app/models/base.py
File Content:
import uuid
from sqlalchemy import Column, DateTime, func
from sqlalchemy.orm import declarative_base
from sqlalchemy.dialects.postgresql import UUID

Base = declarative_base()

class BaseMixin:
    """Base model mixin for common columns."""
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
3. Core Data Models
These files define the actual database tables for our authentication and tenancy system.
File Location: backend/app/models/user.py
File Content:
from sqlalchemy import Column, String, Boolean
from sqlalchemy.orm import relationship

from app.models.base import Base, BaseMixin

class User(Base, BaseMixin):
    __tablename__ = 'users'

    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    
    is_active = Column(Boolean, default=True, nullable=False)
    is_verified = Column(Boolean, default=False, nullable=False)

    # A user can be a member of multiple organizations
    memberships = relationship('Membership', back_populates='user', cascade='all, delete-orphan')

File Location: backend/app/models/organization.py
File Content:
from sqlalchemy import Column, String, ForeignKey
from sqlalchemy.orm import relationship

from app.models.base import Base, BaseMixin
from app.models.user import User

class Organization(Base, BaseMixin):
    __tablename__ = 'organizations'

    name = Column(String, nullable=False)
    owner_id = Column(ForeignKey('users.id'), nullable=False)

    owner = relationship('User')
    members = relationship('Membership', back_populates='organization', cascade='all, delete-orphan')

File Location: backend/app/models/membership.py
File Content:
import enum
from sqlalchemy import Column, Enum, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID

from app.models.base import Base, BaseMixin

class MemberRole(str, enum.Enum):
    OWNER = 'owner'
    ADMIN = 'admin'
    MEMBER = 'member'

class Membership(Base, BaseMixin):
    __tablename__ = 'memberships'

    user_id = Column(ForeignKey('users.id'), primary_key=True)
    organization_id = Column(ForeignKey('organizations.id'), primary_key=True)
    
    role = Column(Enum(MemberRole), nullable=False, default=MemberRole.MEMBER)

    user = relationship('User', back_populates='memberships')
    organization = relationship('Organization', back_populates='members')

4. Alembic Migration
After creating/updating these model files, we must generate a new database migration to apply the schema changes.
Execution Command (run in the backend directory):
# Ensure you have alembic installed: pip install alembic
alembic revision --autogenerate -m "Create auth and multi-tenancy models"
alembic upgrade head
5. Next Steps
With the database schema for authentication and multi-tenancy now defined, the next step is to build the security layer that will interact with these models.
Next File: 2.3-Backend-Security-JWT-Service.md will define the core utilities for password hashing and creating/validating JSON Web Tokens (JWTs).