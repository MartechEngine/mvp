Phase: 2 - User Identity & Authentication
Part: 2.5.1
Title: Backend User Session Service
Depends On: 2.5-Backend-Auth-Service.md, 2.2.1-Data-Model-User-Session.md
Objective: To implement the UserSessionService that manages JWT refresh tokens, session lifecycle, device tracking, and security features like session limits and suspicious activity detection.

## 1. Core Principles

**Session Security**: Each session is tied to a device and tracks security metadata like IP address and user agent.
**Token Rotation**: Refresh tokens are rotated on each use to prevent replay attacks.
**Session Limits**: Enforce maximum number of concurrent sessions per user.
**Audit Trail**: Complete tracking of session creation, refresh, and termination events.

## 2. UserSessionService Implementation

**File Location:** `backend/app/services/user_session_service.py`

**File Content:**
```python
import logging
import secrets
from datetime import datetime, timedelta
from typing import Optional, Tuple, List
from sqlalchemy.orm import Session
from sqlalchemy import and_, func

from app.core.config import settings
from app.core.security import create_refresh_token, verify_refresh_token
from app.core.exceptions import InvalidCredentialsError, ValidationError
from app.models.user_session import UserSession, SessionStatus
from app.models.user import User

logger = logging.getLogger(__name__)

class UserSessionService:
    """Service for managing user sessions and refresh tokens."""
    
    def __init__(self, db: Session):
        self.db = db
        self.max_sessions_per_user = getattr(settings, 'MAX_SESSIONS_PER_USER', 5)
        self.refresh_token_expire_days = getattr(settings, 'REFRESH_TOKEN_EXPIRE_DAYS', 30)
    
    def create_session(self, user_id: str, device_info: dict, 
                      ip_address: Optional[str] = None) -> Tuple[UserSession, str]:
        """
        Create a new user session with refresh token.
        
        Args:
            user_id: The user's UUID
            device_info: Dictionary containing device metadata
            ip_address: Client IP address
            
        Returns:
            Tuple of (UserSession, refresh_token_string)
            
        Raises:
            ValidationError: If session limit exceeded
        """
        try:
            # Check session limits
            active_sessions_count = self.db.query(UserSession).filter(
                and_(
                    UserSession.user_id == user_id,
                    UserSession.status == SessionStatus.ACTIVE,
                    UserSession.expires_at > datetime.utcnow()
                )
            ).count()
            
            if active_sessions_count >= self.max_sessions_per_user:
                # Terminate oldest session to make room
                oldest_session = self.db.query(UserSession).filter(
                    and_(
                        UserSession.user_id == user_id,
                        UserSession.status == SessionStatus.ACTIVE
                    )
                ).order_by(UserSession.last_used_at.asc()).first()
                
                if oldest_session:
                    self._terminate_session(oldest_session, "Session limit exceeded")
            
            # Generate session ID and refresh token
            session_id = secrets.token_urlsafe(32)
            refresh_token = secrets.token_urlsafe(64)
            
            # Create session record
            expires_at = datetime.utcnow() + timedelta(days=self.refresh_token_expire_days)
            
            session = UserSession(
                session_id=session_id,
                user_id=user_id,
                refresh_token_hash=self._hash_token(refresh_token),
                device_id=device_info.get("device_id"),
                device_name=device_info.get("device_name", "Unknown Device"),
                device_type=device_info.get("device_type", "unknown"),
                user_agent=device_info.get("user_agent"),
                ip_address=ip_address,
                expires_at=expires_at,
                status=SessionStatus.ACTIVE
            )
            
            self.db.add(session)
            self.db.commit()
            self.db.refresh(session)
            
            logger.info(f"Created session {session_id} for user {user_id}")
            
            return session, refresh_token
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to create session for user {user_id}: {e}")
            raise
    
    def refresh_session(self, refresh_token: str, 
                       ip_address: Optional[str] = None) -> Tuple[UserSession, str]:
        """
        Refresh a session and rotate the refresh token.
        
        Args:
            refresh_token: The current refresh token
            ip_address: Client IP address
            
        Returns:
            Tuple of (UserSession, new_refresh_token)
            
        Raises:
            InvalidCredentialsError: If refresh token is invalid or expired
        """
        try:
            # Find session by refresh token hash
            token_hash = self._hash_token(refresh_token)
            session = self.db.query(UserSession).filter(
                and_(
                    UserSession.refresh_token_hash == token_hash,
                    UserSession.status == SessionStatus.ACTIVE,
                    UserSession.expires_at > datetime.utcnow()
                )
            ).first()
            
            if not session:
                logger.warning(f"Invalid refresh token attempt from IP {ip_address}")
                raise InvalidCredentialsError("Invalid or expired refresh token")
            
            # Check for suspicious activity (IP change)
            if ip_address and session.ip_address and ip_address != session.ip_address:
                logger.warning(f"IP address changed for session {session.session_id}: {session.ip_address} -> {ip_address}")
                # Could implement additional security measures here
            
            # Generate new refresh token
            new_refresh_token = secrets.token_urlsafe(64)
            
            # Update session
            session.refresh_token_hash = self._hash_token(new_refresh_token)
            session.last_used_at = datetime.utcnow()
            session.refresh_count += 1
            
            if ip_address:
                session.ip_address = ip_address
            
            self.db.commit()
            
            logger.info(f"Refreshed session {session.session_id}")
            
            return session, new_refresh_token
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to refresh session: {e}")
            raise
    
    def terminate_session(self, refresh_token: str) -> bool:
        """
        Terminate a session (logout).
        
        Args:
            refresh_token: The refresh token to terminate
            
        Returns:
            True if session was terminated, False if not found
        """
        try:
            token_hash = self._hash_token(refresh_token)
            session = self.db.query(UserSession).filter(
                UserSession.refresh_token_hash == token_hash
            ).first()
            
            if session:
                self._terminate_session(session, "User logout")
                return True
            
            return False
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to terminate session: {e}")
            return False
    
    def terminate_all_sessions(self, user_id: str, except_session_id: Optional[str] = None) -> int:
        """
        Terminate all active sessions for a user.
        
        Args:
            user_id: The user's UUID
            except_session_id: Optional session ID to keep active
            
        Returns:
            Number of sessions terminated
        """
        try:
            query = self.db.query(UserSession).filter(
                and_(
                    UserSession.user_id == user_id,
                    UserSession.status == SessionStatus.ACTIVE
                )
            )
            
            if except_session_id:
                query = query.filter(UserSession.session_id != except_session_id)
            
            sessions = query.all()
            count = 0
            
            for session in sessions:
                self._terminate_session(session, "All sessions terminated")
                count += 1
            
            logger.info(f"Terminated {count} sessions for user {user_id}")
            return count
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to terminate sessions for user {user_id}: {e}")
            return 0
    
    def get_user_sessions(self, user_id: str, active_only: bool = True) -> List[UserSession]:
        """
        Get all sessions for a user.
        
        Args:
            user_id: The user's UUID
            active_only: If True, only return active sessions
            
        Returns:
            List of UserSession objects
        """
        query = self.db.query(UserSession).filter(UserSession.user_id == user_id)
        
        if active_only:
            query = query.filter(
                and_(
                    UserSession.status == SessionStatus.ACTIVE,
                    UserSession.expires_at > datetime.utcnow()
                )
            )
        
        return query.order_by(UserSession.last_used_at.desc()).all()
    
    def cleanup_expired_sessions(self) -> int:
        """
        Clean up expired sessions (maintenance task).
        
        Returns:
            Number of sessions cleaned up
        """
        try:
            expired_sessions = self.db.query(UserSession).filter(
                and_(
                    UserSession.status == SessionStatus.ACTIVE,
                    UserSession.expires_at <= datetime.utcnow()
                )
            ).all()
            
            count = 0
            for session in expired_sessions:
                self._terminate_session(session, "Session expired")
                count += 1
            
            logger.info(f"Cleaned up {count} expired sessions")
            return count
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to cleanup expired sessions: {e}")
            return 0
    
    def _terminate_session(self, session: UserSession, reason: str):
        """Internal method to terminate a session."""
        session.status = SessionStatus.TERMINATED
        session.terminated_at = datetime.utcnow()
        session.termination_reason = reason
        self.db.commit()
        
        logger.info(f"Terminated session {session.session_id}: {reason}")
    
    def _hash_token(self, token: str) -> str:
        """Hash a token for secure storage."""
        import hashlib
        return hashlib.sha256(token.encode()).hexdigest()
```

## 3. Session Management API Integration

The UserSessionService integrates with the authentication API to provide:

- **Session Creation**: During login, creates a new session with device tracking
- **Token Refresh**: Rotates refresh tokens securely while maintaining session state
- **Session Termination**: Handles logout and security-driven session termination
- **Session Monitoring**: Provides visibility into active sessions for users

## 4. Security Features

**Token Rotation**: Refresh tokens are rotated on each use to prevent replay attacks.
**Device Tracking**: Sessions are tied to specific devices with metadata tracking.
**IP Monitoring**: Tracks IP address changes for suspicious activity detection.
**Session Limits**: Enforces maximum concurrent sessions per user.
**Automatic Cleanup**: Expired sessions are automatically cleaned up.

## 5. Next Steps

With the UserSessionService implemented, the authentication system now has complete session management capabilities.

**Next File:** `2.6.1-Backend-Email-Service.md` will implement email verification and notification capabilities.
