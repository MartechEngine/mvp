Phase: 8 - Operations & Compliance
Part: 8.1.3
Title: Backend Sentry Error Tracking Integration
Depends On: 8.1.2-Backend-APM-and-Enhanced-Monitoring.md, 8.2-Backend-API-Standardization-Guide.md
Objective: To implement comprehensive error tracking and monitoring using Sentry for real-time error detection, performance monitoring, and debugging capabilities. This integration provides detailed error context, user impact analysis, and automated alerting for production issues.

## 1. Core Principles

**Comprehensive Coverage**: Track all errors, exceptions, and performance issues across the entire application.
**Privacy First**: Filter sensitive data and PII from error reports while maintaining debugging utility.
**Actionable Insights**: Provide rich context for debugging including user actions, request data, and system state.
**Performance Monitoring**: Track application performance metrics and identify bottlenecks.

## 2. Sentry Configuration and Setup

### Core Configuration
```python
# File: backend/app/core/sentry_config.py
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration
from sentry_sdk.integrations.celery import CeleryIntegration
from sentry_sdk.integrations.redis import RedisIntegration
from sentry_sdk.integrations.logging import LoggingIntegration
from sentry_sdk.integrations.httpx import HttpxIntegration
import logging

from app.core.config import settings

def init_sentry():
    """Initialize Sentry error tracking and performance monitoring."""
    
    if not settings.SENTRY_ENABLED or not settings.SENTRY_DSN:
        logging.info("Sentry disabled or DSN not configured")
        return
    
    # Configure integrations
    integrations = [
        FastApiIntegration(
            auto_enabling_integrations=True,
            transaction_style="endpoint",
            failed_request_status_codes=[400, 401, 403, 404, 413, 429, 500, 502, 503, 504]
        ),
        SqlalchemyIntegration(),
        CeleryIntegration(monitor_beat_tasks=True, propagate_traces=True),
        RedisIntegration(),
        LoggingIntegration(level=logging.INFO, event_level=logging.ERROR),
        HttpxIntegration()
    ]
    
    # Initialize Sentry
    sentry_sdk.init(
        dsn=settings.SENTRY_DSN,
        environment=settings.ENVIRONMENT,
        release=settings.APP_VERSION,
        server_name=settings.HOSTNAME,
        integrations=integrations,
        traces_sample_rate=settings.SENTRY_TRACES_SAMPLE_RATE,
        profiles_sample_rate=settings.SENTRY_PROFILES_SAMPLE_RATE,
        sample_rate=settings.SENTRY_ERROR_SAMPLE_RATE,
        attach_stacktrace=True,
        send_default_pii=False,
        max_breadcrumbs=100,
        debug=settings.SENTRY_DEBUG,
        before_send=filter_sensitive_data,
        before_send_transaction=filter_transaction_data
    )
    
    logging.info(f"Sentry initialized for environment: {settings.ENVIRONMENT}")

def filter_sensitive_data(event, hint):
    """Filter sensitive data from Sentry events before sending."""
    # Remove sensitive headers
    if 'request' in event and 'headers' in event['request']:
        sensitive_headers = ['authorization', 'cookie', 'x-api-key']
        for header in sensitive_headers:
            if header in event['request']['headers']:
                event['request']['headers'][header] = '[Filtered]'
    
    # Remove sensitive form data
    if 'request' in event and 'data' in event['request']:
        sensitive_fields = ['password', 'token', 'secret', 'key', 'credit_card']
        data = event['request']['data']
        if isinstance(data, dict):
            for field in sensitive_fields:
                if field in data:
                    data[field] = '[Filtered]'
    
    # Filter out expected errors that shouldn't be tracked
    if 'exception' in event:
        for exception in event['exception']['values']:
            if exception.get('type') in ['ValidationError', 'HTTPException']:
                return None  # Don't track validation errors
    
    return event

def filter_transaction_data(event, hint):
    """Filter transaction data for performance monitoring."""
    # Skip health check endpoints
    if event.get('transaction', '').endswith('/health'):
        return None
    
    # Skip static file requests
    if event.get('transaction', '').startswith('/static/'):
        return None
    
    return event
```

### Environment Configuration
```python
# File: backend/app/core/config.py (additions)
class Settings(BaseSettings):
    # ... existing settings ...
    
    # Sentry Configuration
    SENTRY_ENABLED: bool = Field(False, description="Enable Sentry error tracking")
    SENTRY_DSN: Optional[str] = Field(None, description="Sentry DSN for error reporting")
    SENTRY_DEBUG: bool = Field(False, description="Enable Sentry debug mode")
    
    # Sampling rates (0.0 to 1.0)
    SENTRY_ERROR_SAMPLE_RATE: float = Field(1.0, description="Error sampling rate")
    SENTRY_TRACES_SAMPLE_RATE: float = Field(0.1, description="Performance traces sampling rate")
    SENTRY_PROFILES_SAMPLE_RATE: float = Field(0.1, description="Profiling sampling rate")
    
    # Release tracking
    APP_VERSION: str = Field("1.0.0", description="Application version for release tracking")
    HOSTNAME: str = Field("localhost", description="Server hostname for identification")
```

## 3. Custom Error Context and User Tracking

### User Context Middleware
```python
# File: backend/app/middleware/sentry_middleware.py
import sentry_sdk
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.core.security import verify_access_token
from app.models.user import User

class SentryContextMiddleware(BaseHTTPMiddleware):
    """Middleware to add user and request context to Sentry events."""
    
    async def dispatch(self, request: Request, call_next):
        # Set request context
        with sentry_sdk.configure_scope() as scope:
            scope.set_tag("request_id", getattr(request.state, 'request_id', 'unknown'))
            scope.set_tag("endpoint", f"{request.method} {request.url.path}")
            scope.set_context("request", {
                "method": request.method,
                "url": str(request.url),
                "headers": dict(request.headers),
                "query_params": dict(request.query_params)
            })
            
            # Add user context if authenticated
            await self._add_user_context(request, scope)
        
        response = await call_next(request)
        
        # Add response context for errors
        if response.status_code >= 400:
            with sentry_sdk.configure_scope() as scope:
                scope.set_context("response", {
                    "status_code": response.status_code,
                    "headers": dict(response.headers)
                })
        
        return response
    
    async def _add_user_context(self, request: Request, scope):
        """Add authenticated user context to Sentry."""
        try:
            # Extract JWT token from Authorization header
            auth_header = request.headers.get("authorization")
            if not auth_header or not auth_header.startswith("Bearer "):
                return
            
            token = auth_header.split(" ")[1]
            payload = verify_access_token(token)
            user_id = payload.get("sub")
            
            if user_id:
                # Get user from database
                db = next(get_db())
                try:
                    user = db.query(User).filter(User.id == user_id).first()
                    if user:
                        scope.set_user({
                            "id": str(user.id),
                            "email": user.email,
                            "username": user.full_name,
                            "organization_id": str(user.organization_id) if user.organization_id else None
                        })
                        
                        scope.set_tag("user_id", str(user.id))
                        scope.set_tag("user_verified", user.is_verified)
                        scope.set_tag("user_active", user.is_active)
                finally:
                    db.close()
                    
        except Exception:
            # Don't let user context extraction break the request
            pass
```

## 4. Business Logic Error Tracking

### Sentry Utilities
```python
# File: backend/app/core/sentry_utils.py
import sentry_sdk
from typing import Dict, Any, Optional
from functools import wraps
import logging

logger = logging.getLogger(__name__)

def track_business_event(event_name: str, properties: Dict[str, Any] = None):
    """Track business events for analytics and debugging."""
    with sentry_sdk.configure_scope() as scope:
        scope.set_tag("event_type", "business_event")
        scope.add_breadcrumb(
            message=event_name,
            category="business",
            data=properties or {},
            level="info"
        )

def track_performance_issue(operation: str, duration_ms: float, threshold_ms: float = 1000):
    """Track performance issues when operations exceed thresholds."""
    if duration_ms > threshold_ms:
        with sentry_sdk.configure_scope() as scope:
            scope.set_tag("performance_issue", True)
            scope.set_context("performance", {
                "operation": operation,
                "duration_ms": duration_ms,
                "threshold_ms": threshold_ms,
                "slowdown_factor": duration_ms / threshold_ms
            })
        
        sentry_sdk.capture_message(
            f"Performance issue: {operation} took {duration_ms}ms (threshold: {threshold_ms}ms)",
            level="warning"
        )

def track_external_api_error(service: str, endpoint: str, status_code: int, response_time_ms: float):
    """Track external API errors and performance issues."""
    with sentry_sdk.configure_scope() as scope:
        scope.set_tag("external_api_error", True)
        scope.set_tag("external_service", service)
        scope.set_context("external_api", {
            "service": service,
            "endpoint": endpoint,
            "status_code": status_code,
            "response_time_ms": response_time_ms
        })
    
    sentry_sdk.capture_message(
        f"External API error: {service} {endpoint} returned {status_code}",
        level="error"
    )

def track_credit_operation(operation: str, amount: int, organization_id: str, success: bool):
    """Track credit system operations for business intelligence."""
    with sentry_sdk.configure_scope() as scope:
        scope.set_tag("credit_operation", operation)
        scope.set_tag("organization_id", organization_id)
        scope.add_breadcrumb(
            message=f"Credit {operation}",
            category="credits",
            data={
                "operation": operation,
                "amount": amount,
                "organization_id": organization_id,
                "success": success
            },
            level="info"
        )

def sentry_trace(operation_name: str = None):
    """Decorator to automatically trace function execution and errors."""
    def decorator(func):
        @wraps(func)
        async def async_wrapper(*args, **kwargs):
            op_name = operation_name or f"{func.__module__}.{func.__name__}"
            
            with sentry_sdk.start_transaction(op=op_name, name=func.__name__):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    sentry_sdk.capture_exception(e)
                    raise
        
        @wraps(func)
        def sync_wrapper(*args, **kwargs):
            op_name = operation_name or f"{func.__module__}.{func.__name__}"
            
            with sentry_sdk.start_transaction(op=op_name, name=func.__name__):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    sentry_sdk.capture_exception(e)
                    raise
        
        return async_wrapper if hasattr(func, '__code__') and func.__code__.co_flags & 0x80 else sync_wrapper
    
    return decorator

def add_error_context(context_name: str, context_data: Dict[str, Any]):
    """Add custom context to current Sentry scope."""
    with sentry_sdk.configure_scope() as scope:
        scope.set_context(context_name, context_data)

def set_error_tags(**tags):
    """Set tags on current Sentry scope."""
    with sentry_sdk.configure_scope() as scope:
        for key, value in tags.items():
            scope.set_tag(key, str(value))
```

## 5. Enhanced Service Classes

### Base Service with Sentry Integration
```python
# File: backend/app/services/enhanced_base_service.py
import sentry_sdk
import time
from typing import Any, Dict, Optional
from sqlalchemy.orm import Session

from app.core.sentry_utils import track_performance_issue, add_error_context

class EnhancedBaseService:
    """Base service class with integrated Sentry error tracking and performance monitoring."""
    
    def __init__(self, db: Session):
        self.db = db
        self.service_name = self.__class__.__name__
    
    def _track_operation_start(self, operation: str, **context):
        """Track the start of a service operation."""
        add_error_context("service_operation", {
            "service": self.service_name,
            "operation": operation,
            "context": context
        })
        
        return time.time()
    
    def _track_operation_end(self, operation: str, start_time: float, success: bool = True, **result_context):
        """Track the completion of a service operation."""
        duration_ms = (time.time() - start_time) * 1000
        
        # Track performance issues
        track_performance_issue(
            operation=f"{self.service_name}.{operation}",
            duration_ms=duration_ms,
            threshold_ms=2000  # 2 second threshold
        )
        
        # Add operation result context
        add_error_context("operation_result", {
            "duration_ms": duration_ms,
            "success": success,
            **result_context
        })
        
        # Add breadcrumb for successful operations
        if success:
            sentry_sdk.add_breadcrumb(
                message=f"{self.service_name}.{operation} completed",
                category="service",
                data={"duration_ms": duration_ms},
                level="info"
            )
    
    def _handle_service_error(self, operation: str, error: Exception, **error_context):
        """Handle and track service errors."""
        add_error_context("service_error", {
            "service": self.service_name,
            "operation": operation,
            "error_type": type(error).__name__,
            "error_message": str(error),
            **error_context
        })
        
        # Capture the exception with context
        sentry_sdk.capture_exception(error)
```

## 6. Celery Task Error Tracking

### Enhanced Celery Tasks
```python
# File: backend/app/tasks/enhanced_dcs_tasks.py
import sentry_sdk
from celery import shared_task
from sqlalchemy.orm import Session

from app.core.database import SessionLocal
from app.core.sentry_utils import track_business_event, add_error_context

@shared_task(bind=True, max_retries=3, default_retry_delay=300)
def run_dcs_scan_with_tracking(self, audit_id: str):
    """Enhanced DCS scan task with comprehensive Sentry tracking."""
    db: Session = SessionLocal()
    
    # Set up Sentry context for the task
    with sentry_sdk.configure_scope() as scope:
        scope.set_tag("celery_task", "run_dcs_scan")
        scope.set_tag("audit_id", audit_id)
        scope.set_context("task", {
            "name": "run_dcs_scan",
            "audit_id": audit_id,
            "retry_count": self.request.retries,
            "max_retries": self.max_retries
        })
    
    try:
        # Track task start
        track_business_event("celery_task_started", {
            "task_name": "run_dcs_scan",
            "audit_id": audit_id
        })
        
        # Run the DCS scan (implementation details here)
        # service = EnhancedDCSService(db)
        # result = await service.run_dcs_scan(audit_id)
        
        # Track successful completion
        track_business_event("celery_task_completed", {
            "task_name": "run_dcs_scan",
            "audit_id": audit_id
        })
        
        return {"success": True}
        
    except Exception as exc:
        # Add task error context
        add_error_context("celery_error", {
            "task_name": "run_dcs_scan",
            "audit_id": audit_id,
            "retry_count": self.request.retries,
            "max_retries": self.max_retries,
            "error_type": type(exc).__name__
        })
        
        # Track task failure
        track_business_event("celery_task_failed", {
            "task_name": "run_dcs_scan",
            "audit_id": audit_id,
            "error": str(exc),
            "retry_count": self.request.retries
        })
        
        # Capture exception
        sentry_sdk.capture_exception(exc)
        
        # Retry logic
        if self.request.retries < self.max_retries:
            sentry_sdk.add_breadcrumb(
                message=f"Retrying task (attempt {self.request.retries + 1})",
                category="task",
                level="warning"
            )
            raise self.retry(exc=exc)
        else:
            # Final failure
            track_business_event("celery_task_final_failure", {
                "task_name": "run_dcs_scan",
                "audit_id": audit_id,
                "error": str(exc)
            })
            raise
    
    finally:
        if db.is_active:
            db.close()
```

## 7. Application Integration

### Main Application Setup
```python
# File: backend/app/main.py (additions)
from app.core.sentry_config import init_sentry
from app.middleware.sentry_middleware import SentryContextMiddleware

# Initialize Sentry before creating FastAPI app
init_sentry()

app = FastAPI(
    title="MartechEngine API",
    description="Comprehensive SEO and Marketing Intelligence Platform",
    version=settings.APP_VERSION
)

# Add Sentry context middleware
app.add_middleware(SentryContextMiddleware)

# ... rest of application setup
```

### Health Check with Sentry Status
```python
# File: backend/app/api/v1/endpoints/health.py (additions)
import sentry_sdk
from app.schemas.common_schemas import APIHealthResponse

@router.get("/health", response_model=APIHealthResponse)
async def health_check():
    """Enhanced health check with Sentry integration status."""
    checks = {
        "database": await check_database_health(),
        "redis": await check_redis_health(),
        "celery": await check_celery_health(),
        "sentry": check_sentry_health()
    }
    
    # Determine overall status
    status = "healthy"
    if any(not check["healthy"] for check in checks.values()):
        status = "degraded" if all(check.get("critical", True) == False for check in checks.values() if not check["healthy"]) else "unhealthy"
    
    return APIHealthResponse(
        status=status,
        version=settings.APP_VERSION,
        checks=checks
    )

def check_sentry_health() -> dict:
    """Check Sentry integration health."""
    try:
        if not settings.SENTRY_ENABLED:
            return {"healthy": True, "message": "Sentry disabled", "critical": False}
        
        # Test Sentry connection
        with sentry_sdk.configure_scope() as scope:
            scope.set_tag("health_check", True)
        
        return {"healthy": True, "message": "Sentry operational"}
    except Exception as e:
        return {"healthy": False, "message": f"Sentry error: {str(e)}", "critical": False}
```

## 8. Environment Configuration

### Production Environment Variables
```bash
# File: .env.production
# Sentry Configuration
SENTRY_ENABLED=true
SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id
SENTRY_DEBUG=false

# Sampling rates for production
SENTRY_ERROR_SAMPLE_RATE=1.0
SENTRY_TRACES_SAMPLE_RATE=0.1
SENTRY_PROFILES_SAMPLE_RATE=0.1

# Release tracking
APP_VERSION=1.0.0
HOSTNAME=martechengine-api-prod
```

### Development Environment Variables
```bash
# File: .env.development
# Sentry Configuration
SENTRY_ENABLED=true
SENTRY_DSN=https://your-dev-sentry-dsn@sentry.io/dev-project-id
SENTRY_DEBUG=true

# Higher sampling rates for development
SENTRY_ERROR_SAMPLE_RATE=1.0
SENTRY_TRACES_SAMPLE_RATE=1.0
SENTRY_PROFILES_SAMPLE_RATE=1.0

# Release tracking
APP_VERSION=dev
HOSTNAME=localhost
```

## 9. Implementation Checklist

### Sentry Integration Setup:

**✅ Core Configuration**
- [ ] Install sentry-sdk with FastAPI integration
- [ ] Configure Sentry with proper DSN and environment
- [ ] Set up data filtering for sensitive information
- [ ] Configure sampling rates for production

**✅ Context and User Tracking**
- [ ] Implement SentryContextMiddleware for request context
- [ ] Add user authentication context to errors
- [ ] Set up organization-level error tagging
- [ ] Configure breadcrumb tracking for user actions

**✅ Service Integration**
- [ ] Enhance service classes with error tracking
- [ ] Add performance monitoring to critical operations
- [ ] Implement business event tracking
- [ ] Set up external API error monitoring

**✅ Task Monitoring**
- [ ] Integrate Sentry with Celery tasks
- [ ] Add retry logic with error context
- [ ] Track task performance and failures
- [ ] Set up task-specific error tagging

**✅ Health and Monitoring**
- [ ] Add Sentry status to health checks
- [ ] Configure alerting rules in Sentry dashboard
- [ ] Set up error grouping and filtering
- [ ] Configure team notifications

## 10. Next Steps

This Sentry Error Tracking Integration provides:
- ✅ **Comprehensive error tracking** across all application layers
- ✅ **User and request context** for debugging
- ✅ **Performance monitoring** with automatic issue detection
- ✅ **Privacy protection** with sensitive data filtering
- ✅ **Business intelligence** through event tracking

**Next Implementation**: Complete email verification backend implementation with proper error tracking integration.
