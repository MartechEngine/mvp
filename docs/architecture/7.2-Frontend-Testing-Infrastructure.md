File: 7.2-Frontend-Testing-Infrastructure.md
Phase: 7 - Enterprise Readiness & Finalization
Part: 7.2
Title: Frontend Testing Infrastructure
Depends On: 7.1-Backend-Testing-Infrastructure.md
Objective: To establish a complete, robust, and developer-friendly testing environment for the Next.js frontend. This setup features Jest as the test runner, React Testing Library for user-centric component testing, and Mock Service Worker (MSW) for intercepting API calls at the network level, ensuring tests are isolated and reliable.
1. Core Principles
User-Centric Testing: We will use React Testing Library, which encourages writing tests that resemble how a user interacts with the application, leading to more resilient and meaningful tests.
Network-Level Mocking: We will use Mock Service Worker (MSW) to intercept actual network requests. This is superior to mocking axios or fetch because it tests the entire application data flow, from the component down to the API service layer.
Test Isolation: Each test must be independent. We will configure our tools to automatically reset API mocks and clear the React Query cache before each test.
2. Test Dependencies
Installation Command (run in the frontend directory):
npm install --save-dev jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom @testing-library/user-event msw whatwg-fetch

3. Jest & Next.js Configuration
We need to configure Jest to work with the Next.js compiler and our testing environment.
File Location: frontend/jest.config.js
File Content:

const nextJest = require('next/jest')();

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
});

// Add any custom config to be passed to Jest
const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    // Handle module aliases (this will be automatically configured by nextJest)
    '^@/(.*)$': '<rootDir>/src/$1',
  },
};

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = createJestConfig(customJestConfig);

4. Mock Service Worker (MSW) Setup
MSW allows us to define mock API handlers that intercept network requests during tests.
File Location: frontend/src/tests/mocks/handlers.ts
File Content:
import { http, HttpResponse } from 'msw';

const API_URL = process.env.NEXT_PUBLIC_API_URL;

export const handlers = [
  // Example: Mock for getting the current user
  http.get(`${API_URL}/users/me`, () => {
    return HttpResponse.json({
      success: true,
      data: {
        id: 'c7a7e7e0-4c6c-4b8c-8c4a-4e4e4e4e4e4e',
        email: 'test@example.com',
        full_name: 'Test User',
        is_active: true,
        is_verified: true,
      },
    });
  }),
  
  // Example: Mock for a failed request
  http.post(`${API_URL}/auth/login`, async ({ request }) => {
    const info = await request.json();
    if (info.email === 'fail@example.com') {
      return HttpResponse.json({
          success: false,
          error: { message: "Invalid credentials provided." }
      }, { status: 401 });
    }
    // Handle success case if needed
    return HttpResponse.json({ /* ... success payload ... */ });
  }),
];
File Location: frontend/src/tests/mocks/server.ts
File Content:```typescript
import { setupServer } from 'msw/node';
import { handlers } from './handlers';
// This configures a request mocking server with the given request handlers.
export const server = setupServer(...handlers);


### **5. Global Test Setup & MSW Lifecycle**

This file is crucial for managing the MSW server lifecycle and ensuring test isolation.

**File Location:** `frontend/jest.setup.js`
**File Content:**
```javascript
// Polyfill for fetch API in Node.js environment
require('whatwg-fetch'); 
import '@testing-library/jest-dom';
import { server } from './src/tests/mocks/server.js';
import { queryClient } from './src/tests/utils'; // A test-specific query client

// Establish API mocking before all tests.
beforeAll(() => server.listen());

// Reset any request handlers that we may add during tests,
// so they don't affect other tests. Also clear the query cache.
afterEach(() => {
  server.resetHandlers();
  queryClient.clear();
});

// Clean up after the tests are finished.
afterAll(() => server.close());

6. Custom Render Utility
To avoid boilerplate, we create a custom render function that wraps components in all necessary providers, especially the QueryClientProvider.
File Location: frontend/src/tests/utils.tsx
File Content:

import React, { ReactElement } from 'react';
import { render, RenderOptions } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

// A specific query client for tests with retries turned off for speed
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
  },
});

const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
  return (
    <QueryClientProvider client={queryClient}>
      {/* Add other global providers here if needed, e.g., ThemeProvider */}
      {children}
    </QueryClientProvider>
  );
};

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => render(ui, { wrapper: AllTheProviders, ...options });

// Re-export everything from React Testing Library for convenience
export * from '@testing-library/react';
// Override render method with our custom one
export { customRender as render };```

### **7. Next Steps**

We have now established a complete, modern, and robust testing infrastructure for our frontend application. This setup enables us to perform powerful integration tests by mocking the API at the network level.

*   **Next File:** `7.3-Phase-7-Implementation-and-Testing-Strategy.md