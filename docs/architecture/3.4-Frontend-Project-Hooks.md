Phase: 3 - Core Application & Project Management
Part: 3.4
Title: Frontend Project Hooks
Depends On: 3.3-Frontend-Custom-Hooks-Pattern.md
Objective: To implement the complete suite of @tanstack/react-query custom hooks for the projects domain. This includes hooks for fetching, creating, updating, and deleting projects, complete with optimistic updates, cache invalidation, and user-friendly notifications.
1. Project-Related TypeScript Types
First, we must define the TypeScript types that our hooks and components will use. These types directly correspond to the Pydantic schemas we created for the backend API.
File Location: frontend/src/types/project.ts
File Content:
import { PaginatedResponse, ApiSuccessResponse } from './api';

export enum ProjectStatus {
  ACTIVE = "ACTIVE",
  ARCHIVED = "ARCHIVED",
  PENDING_DELETION = "PENDING_DELETION",
}

export interface Project {
  id: string; // UUID
  name: string;
  url: string;
  status: ProjectStatus;
  owner_id: string;
  organization_id: string;
  created_at: string; // ISO 8601 date string
  updated_at: string; // ISO 8601 date string
}

// --- Request Payloads ---
export interface ProjectCreatePayload {
  name: string;
  url: string;
}

export interface ProjectUpdatePayload {
  name?: string;
  url?: string;
  status?: ProjectStatus;
}

// --- API Responses ---
// For now, the list response is a simple array. We can add pagination later.
export type ProjectListResponse = Project[];
2. Project API Service Layer
Next, we create the ProjectService class that our hooks will call. This service encapsulates all Axios API calls for the /projects endpoints.
File Location: frontend/src/services/project.service.ts
File Content:
import { apiClient } from '@/lib/api/client';
import { ApiSuccessResponse } from '@/types/api';
import { Project, ProjectListResponse, ProjectCreatePayload, ProjectUpdatePayload } from '@/types/project';
import { UUID } from 'crypto';
import { AxiosError } from 'axios'; // Added missing import

export class ProjectService {
  /**
   * Fetches a list of projects for the current user.
   */
  static async getProjects(): Promise<ProjectListResponse> {
    const response = await apiClient.get<ApiSuccessResponse<ProjectListResponse>>('/projects/');
    return response.data.data;
  }

  /**
   * Fetches a single project by its ID.
   */
  static async getProjectById(projectId: string): Promise<Project> {
    const response = await apiClient.get<ApiSuccessResponse<Project>>(`/projects/${projectId}`);
    return response.data.data;
  }

  /**
   * Creates a new project.
   */
  static async createProject(payload: ProjectCreatePayload): Promise<Project> {
    const response = await apiClient.post<ApiSuccessResponse<Project>>('/projects/', payload);
    return response.data.data;
  }

  /**
   * Updates an existing project.
   */
  static async updateProject(projectId: string, payload: ProjectUpdatePayload): Promise<Project> {
    const response = await apiClient.put<ApiSuccessResponse<Project>>(`/projects/${projectId}`, payload);
    return response.data.data;
  }

  /**
   * Deletes a project.
   */
  static async deleteProject(projectId: string): Promise<void> {
    await apiClient.delete(`/projects/${projectId}`);
  }
}
3. Complete Project Hooks Implementation
This is the final, comprehensive file containing all the custom hooks for the projects domain.
File Location: frontend/src/hooks/useProjects.ts
File Content:
import { useQuery, useMutation, useQueryClient, UseQueryResult, UseMutationResult } from '@tanstack/react-query';
import { toast } from 'react-hot-toast';

import { ProjectService } from '@/services/project.service';
import { Project, ProjectCreatePayload, ProjectUpdatePayload, ProjectListResponse } from '@/types/project';

// --- Query Key Factory ---
export const projectKeys = {
  all: ['projects'] as const,
  lists: () => [...projectKeys.all, 'list'] as const,
  details: () => [...projectKeys.all, 'detail'] as const,
  detail: (id: string) => [...projectKeys.details(), id] as const,
};

// --- Query Hooks (Data Fetching) ---

export const useProjects = (): UseQueryResult<ProjectListResponse, Error> => {
  return useQuery({
    queryKey: projectKeys.lists(),
    queryFn: () => ProjectService.getProjects(),
  });
};

export const useProject = (projectId: string | null): UseQueryResult<Project, Error> => {
  return useQuery({
    queryKey: projectKeys.detail(projectId!),
    queryFn: () => ProjectService.getProjectById(projectId!),
    enabled: !!projectId,
  });
};

// --- Mutation Hooks (Data Modification) ---

export const useCreateProject = (): UseMutationResult<Project, Error, ProjectCreatePayload> => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (payload) => ProjectService.createProject(payload),
    onSuccess: (newProject) => {
      toast.success(`Project "${newProject.name}" created successfully!`);
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
    },
    onError: (error: Error) => {
      toast.error(error.message);
    },
  });
};

export const useUpdateProject = (): UseMutationResult<Project, Error, { projectId: string; payload: ProjectUpdatePayload }> => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ projectId, payload }) => ProjectService.updateProject(projectId, payload),
    onSuccess: (updatedProject) => {
      toast.success(`Project "${updatedProject.name}" updated.`);
      // Invalidate both the list and the specific project detail queries
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
      queryClient.invalidateQueries({ queryKey: projectKeys.detail(updatedProject.id) });
    },
    onError: (error: Error) => {
      toast.error(error.message);
    },
  });
};

export const useDeleteProject = (): UseMutationResult<void, Error, string> => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (projectId: string) => ProjectService.deleteProject(projectId),
    onSuccess: () => {
      toast.success('Project moved to trash.');
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
    },
    onError: (error: Error) => {
      toast.error(error.message);
    },
  });
};
4. Next Steps
We have now built a complete, robust, and reusable data layer for managing projects. This set of hooks provides everything our UI components will need to interact with project data, handle loading and error states, and keep the UI in sync with the backend.
Next File: 3.5-Frontend-Project-Dashboard-UI.md will be the fun part: we will now build the actual user interface components for the dashboard. These components will be clean and simple because they will consume these powerful hooks to do all the heavy lifting.