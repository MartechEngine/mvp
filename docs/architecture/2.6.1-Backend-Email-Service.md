Phase: 2 - User Identity & Authentication
Part: 2.6.1
Title: Backend Email Service Architecture
Depends On: 2.6-Backend-Auth-and-User-API.md
Objective: To implement a comprehensive, secure, and scalable email service that handles user verification, password resets, billing notifications, and system alerts. This service integrates with external email providers and maintains audit trails for compliance.

## 1. Core Principles

**Reliability First**: Email delivery is critical for user onboarding and security. The service uses multiple providers with fallback mechanisms.
**Template-Based**: All emails use structured templates with proper branding and internationalization support.
**Audit Trail**: Every email sent is logged for compliance and debugging purposes.
**Async Processing**: Email sending is handled asynchronously via Celery to avoid blocking API responses.

## 2. Email Service Data Models

### Email Template Model
```python
# File: backend/app/models/email_template.py
from sqlalchemy import Column, String, Text, Boolean, Enum
from app.models.base import Base, BaseMixin
import enum

class EmailType(str, enum.Enum):
    EMAIL_VERIFICATION = "EMAIL_VERIFICATION"
    PASSWORD_RESET = "PASSWORD_RESET"
    BILLING_NOTIFICATION = "BILLING_NOTIFICATION"
    SCAN_COMPLETE = "SCAN_COMPLETE"
    CREDIT_LOW_WARNING = "CREDIT_LOW_WARNING"
    SUBSCRIPTION_EXPIRY = "SUBSCRIPTION_EXPIRY"

class EmailTemplate(Base, BaseMixin):
    __tablename__ = 'email_templates'
    
    email_type = Column(Enum(EmailType), nullable=False, unique=True)
    subject_template = Column(String(255), nullable=False)
    html_template = Column(Text, nullable=False)
    text_template = Column(Text, nullable=False)
    is_active = Column(Boolean, default=True)
```

### Email Log Model
```python
# File: backend/app/models/email_log.py
from sqlalchemy import Column, String, Text, DateTime, Enum, ForeignKey
from sqlalchemy.orm import relationship
from app.models.base import Base, BaseMixin
import enum

class EmailStatus(str, enum.Enum):
    PENDING = "PENDING"
    SENT = "SENT"
    FAILED = "FAILED"
    BOUNCED = "BOUNCED"

class EmailLog(Base, BaseMixin):
    __tablename__ = 'email_logs'
    
    user_id = Column(ForeignKey('users.id'), nullable=True)  # Nullable for system emails
    email_type = Column(Enum(EmailType), nullable=False)
    recipient_email = Column(String(255), nullable=False)
    subject = Column(String(255), nullable=False)
    status = Column(Enum(EmailStatus), default=EmailStatus.PENDING)
    provider_used = Column(String(50), nullable=True)  # e.g., 'sendgrid', 'ses'
    provider_message_id = Column(String(255), nullable=True)
    error_message = Column(Text, nullable=True)
    sent_at = Column(DateTime, nullable=True)
    
    user = relationship('User', back_populates='email_logs')
```

## 3. Email Service Implementation

```python
# File: backend/app/services/email_service.py
import logging
from typing import Dict, Any, Optional
from sqlalchemy.orm import Session
from jinja2 import Template

from app.core.config import settings
from app.models.email_template import EmailTemplate, EmailType
from app.models.email_log import EmailLog, EmailStatus
from app.models.user import User
from app.services.email_providers.sendgrid_client import SendGridClient
from app.services.email_providers.ses_client import SESClient
from app.tasks.email_tasks import send_email_async

logger = logging.getLogger(__name__)

class EmailService:
    """
    Centralized email service handling all email communications.
    """
    
    def __init__(self, db: Session):
        self.db = db
        self.providers = self._initialize_providers()
    
    def _initialize_providers(self):
        """Initialize email providers with fallback order."""
        providers = []
        if settings.SENDGRID_API_KEY:
            providers.append(SendGridClient(settings.SENDGRID_API_KEY))
        if settings.AWS_SES_ACCESS_KEY:
            providers.append(SESClient(settings))
        
        if not providers:
            raise ValueError("No email providers configured")
        
        return providers
    
    def send_verification_email(self, user: User, verification_token: str):
        """Send email verification to new user."""
        template_vars = {
            'user_name': user.full_name,
            'verification_url': f"{settings.FRONTEND_URL}/verify-email?token={verification_token}",
            'app_name': 'MartechEngine'
        }
        
        self._queue_email(
            email_type=EmailType.EMAIL_VERIFICATION,
            recipient_email=user.email,
            template_vars=template_vars,
            user_id=user.id
        )
    
    def send_password_reset_email(self, user: User, reset_token: str):
        """Send password reset email."""
        template_vars = {
            'user_name': user.full_name,
            'reset_url': f"{settings.FRONTEND_URL}/reset-password?token={reset_token}",
            'app_name': 'MartechEngine'
        }
        
        self._queue_email(
            email_type=EmailType.PASSWORD_RESET,
            recipient_email=user.email,
            template_vars=template_vars,
            user_id=user.id
        )
    
    def send_billing_notification(self, user: User, notification_type: str, context: Dict[str, Any]):
        """Send billing-related notifications."""
        template_vars = {
            'user_name': user.full_name,
            'notification_type': notification_type,
            **context
        }
        
        self._queue_email(
            email_type=EmailType.BILLING_NOTIFICATION,
            recipient_email=user.email,
            template_vars=template_vars,
            user_id=user.id
        )
    
    def send_scan_complete_notification(self, user: User, project_name: str, scan_id: str):
        """Send notification when DCS scan completes."""
        template_vars = {
            'user_name': user.full_name,
            'project_name': project_name,
            'scan_url': f"{settings.FRONTEND_URL}/projects/{scan_id}/results",
            'app_name': 'MartechEngine'
        }
        
        self._queue_email(
            email_type=EmailType.SCAN_COMPLETE,
            recipient_email=user.email,
            template_vars=template_vars,
            user_id=user.id
        )
    
    def _queue_email(self, email_type: EmailType, recipient_email: str, 
                     template_vars: Dict[str, Any], user_id: Optional[str] = None):
        """Queue email for async processing."""
        # Get email template
        template = self.db.query(EmailTemplate).filter_by(
            email_type=email_type, is_active=True
        ).first()
        
        if not template:
            logger.error(f"No active template found for email type: {email_type}")
            return
        
        # Render templates
        subject = Template(template.subject_template).render(**template_vars)
        html_body = Template(template.html_template).render(**template_vars)
        text_body = Template(template.text_template).render(**template_vars)
        
        # Create email log entry
        email_log = EmailLog(
            user_id=user_id,
            email_type=email_type,
            recipient_email=recipient_email,
            subject=subject,
            status=EmailStatus.PENDING
        )
        self.db.add(email_log)
        self.db.commit()
        self.db.refresh(email_log)
        
        # Queue for async sending
        send_email_async.delay(
            email_log_id=str(email_log.id),
            recipient_email=recipient_email,
            subject=subject,
            html_body=html_body,
            text_body=text_body
        )
        
        logger.info(f"Queued {email_type} email for {recipient_email}")
```

## 4. Email Provider Clients

### SendGrid Client
```python
# File: backend/app/services/email_providers/sendgrid_client.py
import logging
from sendgrid import SendGridAPIClient
from sendgrid.helpers.mail import Mail
from typing import Tuple, Optional

logger = logging.getLogger(__name__)

class SendGridClient:
    """SendGrid email provider client."""
    
    def __init__(self, api_key: str):
        self.client = SendGridAPIClient(api_key)
        self.from_email = "noreply@martechengine.com"
    
    async def send_email(self, to_email: str, subject: str, 
                        html_content: str, text_content: str) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Send email via SendGrid.
        Returns: (success, message_id, error_message)
        """
        try:
            message = Mail(
                from_email=self.from_email,
                to_emails=to_email,
                subject=subject,
                html_content=html_content,
                plain_text_content=text_content
            )
            
            response = self.client.send(message)
            
            if response.status_code in [200, 202]:
                message_id = response.headers.get('X-Message-Id')
                return True, message_id, None
            else:
                return False, None, f"SendGrid error: {response.status_code}"
                
        except Exception as e:
            logger.error(f"SendGrid send failed: {e}")
            return False, None, str(e)
```

### AWS SES Client
```python
# File: backend/app/services/email_providers/ses_client.py
import logging
import boto3
from botocore.exceptions import ClientError
from typing import Tuple, Optional

logger = logging.getLogger(__name__)

class SESClient:
    """AWS SES email provider client."""
    
    def __init__(self, settings):
        self.client = boto3.client(
            'ses',
            aws_access_key_id=settings.AWS_SES_ACCESS_KEY,
            aws_secret_access_key=settings.AWS_SES_SECRET_KEY,
            region_name=settings.AWS_SES_REGION
        )
        self.from_email = "noreply@martechengine.com"
    
    async def send_email(self, to_email: str, subject: str, 
                        html_content: str, text_content: str) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Send email via AWS SES.
        Returns: (success, message_id, error_message)
        """
        try:
            response = self.client.send_email(
                Source=self.from_email,
                Destination={'ToAddresses': [to_email]},
                Message={
                    'Subject': {'Data': subject, 'Charset': 'UTF-8'},
                    'Body': {
                        'Html': {'Data': html_content, 'Charset': 'UTF-8'},
                        'Text': {'Data': text_content, 'Charset': 'UTF-8'}
                    }
                }
            )
            
            message_id = response['MessageId']
            return True, message_id, None
            
        except ClientError as e:
            logger.error(f"SES send failed: {e}")
            return False, None, str(e)
        except Exception as e:
            logger.error(f"SES unexpected error: {e}")
            return False, None, str(e)
```

## 5. Async Email Tasks

```python
# File: backend/app/tasks/email_tasks.py
import logging
from celery import shared_task
from sqlalchemy.orm import Session

from app.core.database import SessionLocal
from app.models.email_log import EmailLog, EmailStatus
from app.services.email_providers.sendgrid_client import SendGridClient
from app.services.email_providers.ses_client import SESClient
from app.core.config import settings

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3, default_retry_delay=300)
def send_email_async(self, email_log_id: str, recipient_email: str, 
                    subject: str, html_body: str, text_body: str):
    """
    Async task to send email with provider fallback.
    """
    db: Session = SessionLocal()
    
    try:
        email_log = db.query(EmailLog).filter_by(id=email_log_id).first()
        if not email_log:
            logger.error(f"Email log {email_log_id} not found")
            return
        
        # Initialize providers
        providers = []
        if settings.SENDGRID_API_KEY:
            providers.append(('sendgrid', SendGridClient(settings.SENDGRID_API_KEY)))
        if settings.AWS_SES_ACCESS_KEY:
            providers.append(('ses', SESClient(settings)))
        
        # Try each provider
        for provider_name, provider in providers:
            try:
                success, message_id, error = await provider.send_email(
                    recipient_email, subject, html_body, text_body
                )
                
                if success:
                    email_log.status = EmailStatus.SENT
                    email_log.provider_used = provider_name
                    email_log.provider_message_id = message_id
                    email_log.sent_at = datetime.utcnow()
                    db.commit()
                    logger.info(f"Email sent successfully via {provider_name}: {email_log_id}")
                    return
                else:
                    logger.warning(f"Provider {provider_name} failed: {error}")
                    continue
                    
            except Exception as e:
                logger.error(f"Provider {provider_name} exception: {e}")
                continue
        
        # All providers failed
        email_log.status = EmailStatus.FAILED
        email_log.error_message = "All email providers failed"
        db.commit()
        
        # Retry the task
        raise self.retry(exc=Exception("Email sending failed"))
        
    except Exception as exc:
        logger.error(f"Email task failed: {exc}")
        if db.is_active:
            db.rollback()
        raise
    finally:
        db.close()
```

## 6. Email API Endpoints

```python
# File: backend/app/api/v1/endpoints/email.py
import logging
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.api.v1.dependencies.auth_deps import get_current_active_user
from app.models.user import User as UserModel
from app.models.email_log import EmailLog
from app.services.email_service import EmailService
from app.schemas.common_schemas import APISuccessResponse

logger = logging.getLogger(__name__)
router = APIRouter()

@router.post("/resend-verification", status_code=status.HTTP_200_OK)
async def resend_verification_email(
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Resend email verification to current user."""
    if current_user.is_verified:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email is already verified"
        )
    
    email_service = EmailService(db)
    # Generate new verification token (implementation depends on auth service)
    verification_token = "temp_token"  # Replace with actual token generation
    email_service.send_verification_email(current_user, verification_token)
    
    return APISuccessResponse(message="Verification email sent")

@router.get("/logs", response_model=APISuccessResponse[List[dict]])
async def get_email_logs(
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Get email logs for current user (admin only)."""
    # Add admin check here
    logs = db.query(EmailLog).filter_by(user_id=current_user.id).limit(50).all()
    return APISuccessResponse(data=[{
        'id': log.id,
        'email_type': log.email_type,
        'status': log.status,
        'sent_at': log.sent_at,
        'subject': log.subject
    } for log in logs])
```

## 7. Email Templates Setup

```python
# File: backend/app/core/email_templates.py
from app.models.email_template import EmailTemplate, EmailType

DEFAULT_TEMPLATES = {
    EmailType.EMAIL_VERIFICATION: {
        'subject': 'Verify your {{ app_name }} account',
        'html': '''
        <h2>Welcome to {{ app_name }}!</h2>
        <p>Hi {{ user_name }},</p>
        <p>Please verify your email address by clicking the link below:</p>
        <a href="{{ verification_url }}" style="background: #007bff; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">Verify Email</a>
        <p>If you didn't create this account, you can safely ignore this email.</p>
        ''',
        'text': '''
        Welcome to {{ app_name }}!
        
        Hi {{ user_name }},
        
        Please verify your email address by visiting: {{ verification_url }}
        
        If you didn't create this account, you can safely ignore this email.
        '''
    },
    EmailType.PASSWORD_RESET: {
        'subject': 'Reset your {{ app_name }} password',
        'html': '''
        <h2>Password Reset Request</h2>
        <p>Hi {{ user_name }},</p>
        <p>Click the link below to reset your password:</p>
        <a href="{{ reset_url }}" style="background: #dc3545; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">Reset Password</a>
        <p>This link will expire in 1 hour.</p>
        ''',
        'text': '''
        Password Reset Request
        
        Hi {{ user_name }},
        
        Visit this link to reset your password: {{ reset_url }}
        
        This link will expire in 1 hour.
        '''
    }
}

def seed_email_templates(db):
    """Seed default email templates."""
    for email_type, template_data in DEFAULT_TEMPLATES.items():
        existing = db.query(EmailTemplate).filter_by(email_type=email_type).first()
        if not existing:
            template = EmailTemplate(
                email_type=email_type,
                subject_template=template_data['subject'],
                html_template=template_data['html'],
                text_template=template_data['text']
            )
            db.add(template)
    db.commit()
```

## 8. Integration with Auth Service

Update the AuthService to use the EmailService:

```python
# File: backend/app/services/auth_service.py (modification)
from app.services.email_service import EmailService

class AuthService:
    def __init__(self, db: Session):
        self.db = db
        self.email_service = EmailService(db)
    
    def register_user(self, user_create: UserCreate) -> User:
        # ... existing registration logic ...
        
        # Send verification email
        verification_token = self._generate_verification_token(new_user)
        self.email_service.send_verification_email(new_user, verification_token)
        
        return new_user
    
    def request_password_reset(self, email: str):
        user = self.db.query(User).filter_by(email=email.lower()).first()
        if user:
            reset_token = self._generate_reset_token(user)
            self.email_service.send_password_reset_email(user, reset_token)
```

## 9. Configuration Updates

```python
# File: backend/app/core/config.py (additions)
class Settings(BaseSettings):
    # ... existing settings ...
    
    # Email Provider Settings
    SENDGRID_API_KEY: Optional[SecretStr] = None
    AWS_SES_ACCESS_KEY: Optional[str] = None
    AWS_SES_SECRET_KEY: Optional[SecretStr] = None
    AWS_SES_REGION: str = "us-east-1"
    
    # Email Configuration
    FROM_EMAIL: str = "noreply@martechengine.com"
    FRONTEND_URL: str = "http://localhost:3000"
```

## 10. Next Steps

This email service architecture provides:
- ✅ **Reliable email delivery** with provider fallback
- ✅ **Template-based system** for consistent branding
- ✅ **Async processing** for performance
- ✅ **Audit trail** for compliance
- ✅ **Integration points** for all user flows

**Next File**: Create rate limiting architecture to address the next critical gap.
