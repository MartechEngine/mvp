Phase: 4 - Core Application & Billing
Part: 4.5
Title: Frontend Billing & Payment Hooks
Depends On: 4.4-Backend-Payment-and-Billing-API.md
Objective: To create a complete set of @tanstack/react-query hooks that align perfectly with the new backend API endpoints for subscriptions and credits. This includes robust useMutation hooks for handling payment flows, with clear onSuccess and onError states to give users immediate feedback.
1. TypeScript Types for Billing
First, we define the TypeScript types that our hooks and components will use, mirroring the Pydantic schemas from the backend.
File Location: frontend/src/types/billing.ts
File Content:
import { UUID } from "crypto";

export enum PlanTier {
    FREE = "FREE",
    PAID = "PAID",
}

export enum SubscriptionStatus {
    TRIALING = "TRIALING",
    ACTIVE = "ACTIVE",
    TRIAL_EXPIRED = "TRIAL_EXPIRED",
    CANCELLED = "CANCELLED",
}

export enum CreditActionType {
    SIGNUP_BONUS = "SIGNUP_BONUS",
    PLAN_REFILL = "PLAN_REFILL",
    CREDIT_PURCHASE = "CREDIT_PURCHASE",
    SCAN_USAGE = "SCAN_USAGE",
    GENERATION_USAGE = "GENERATION_USAGE",
    REFUND = "REFUND",
}

export interface Plan {
    id: UUID;
    name: string;
    tier: PlanTier;
    price_monthly: number;
    currency: string;
    allowed_projects: number;
    monthly_credits: number;
    can_purchase_credits: boolean;
}

export interface Subscription {
    id: UUID;
    status: SubscriptionStatus;
    trial_ends_at?: string; // ISO 8601 date string
    plan: Plan;
}

export interface CreditPurchaseRequest {
    credit_package_id: UUID;
}

export interface CreditPurchaseInitiation {
    purchase_id: UUID;
    provider_order_id: string;
    amount: number;
    currency: string;
    credits_to_be_granted: number;
}

export interface CreditLedgerEntry {
    id: UUID;
    amount: number;
    transaction_type: CreditActionType;
    description?: string;
    created_at: string; // ISO 8601 date string
}

2. Billing Service Layer
We create a BillingService class to encapsulate all Axios API calls for the billing-related endpoints.
File Location: frontend/src/services/billing.service.ts
File Content:
import { apiClient } from '@/lib/api/client';
import { ApiSuccessResponse } from '@/types/api';
import { Plan, Subscription, CreditPurchaseRequest, CreditPurchaseInitiation, CreditLedgerEntry } from '@/types/billing';

export class BillingService {
  static async getAvailablePlans(): Promise<Plan[]> {
    const response = await apiClient.get<ApiSuccessResponse<Plan[]>>('/billing/plans');
    return response.data.data;
  }

  static async getSubscription(): Promise<Subscription> {
    const response = await apiClient.get<ApiSuccessResponse<Subscription>>('/billing/subscription');
    return response.data.data;
  }

  static async initiateCreditPurchase(payload: CreditPurchaseRequest): Promise<CreditPurchaseInitiation> {
    const response = await apiClient.post<ApiSuccessResponse<CreditPurchaseInitiation>>('/billing/credits/purchase', payload);
    return response.data.data;
  }

  static async getBillingHistory(): Promise<CreditLedgerEntry[]> {
    const response = await apiClient.get<ApiSuccessResponse<CreditLedgerEntry[]>>('/billing/billing/history');
    return response.data.data;
  }
}

3. Custom Hooks for Billing & Payments
This file contains all the user-facing hooks for billing.
File Location: frontend/src/hooks/useBilling.ts
File Content:
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'react-hot-toast';

import { BillingService } from '@/services/billing.service';
import { CreditPurchaseRequest } from '@/types/billing';

// --- Query Key Factory ---
export const billingKeys = {
  all: ['billing'] as const,
  plans: () => [...billingKeys.all, 'plans'] as const,
  subscription: () => [...billingKeys.all, 'subscription'] as const,
  history: () => [...billingKeys.all, 'history'] as const,
};

// --- Query Hooks ---

export const useAvailablePlans = () => {
  return useQuery({
    queryKey: billingKeys.plans(),
    queryFn: BillingService.getAvailablePlans,
  });
};

export const useSubscription = () => {
  return useQuery({
    queryKey: billingKeys.subscription(),
    queryFn: BillingService.getSubscription,
  });
};

export const useBillingHistory = () => {
    return useQuery({
        queryKey: billingKeys.history(),
        queryFn: BillingService.getBillingHistory,
    });
};


// --- Mutation Hooks ---

export const usePurchaseCredits = () => {
    const queryClient = useQueryClient();
    // A hypothetical hook to encapsulate the Razorpay checkout logic
    // const { openCheckout } = useRazorpay(); 

    return useMutation({
        mutationFn: (payload: CreditPurchaseRequest) => BillingService.initiateCreditPurchase(payload),
        onSuccess: (paymentData) => {
            // On success, the backend returns the order details.
            // We would then pass these details to the payment provider's checkout.
            toast.success("Redirecting to payment provider...");
            // openCheckout(paymentData); 
            console.log("Payment initiation data:", paymentData);
        },
        onError: (error: Error) => {
            toast.error(error.message);
        },
    });
};

4. Next Steps
With the data and mutation layer for the frontend now designed, the next step is to build the UI components that will consume these hooks to create the user-facing pricing and billing pages.
Next File: 4.6-Frontend-Pricing-Page-UI.md will create the UI for the pricing page, allowing users to view plans and initiate subscription upgrades or credit purchases.