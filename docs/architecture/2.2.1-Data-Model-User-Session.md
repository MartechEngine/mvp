Phase: 2 - Authentication & User Management
Part: 2.2.1
Title: Data Model - User Session
Depends On: 2.2-Data-Models-Auth-and-Users.md
Objective: To define the UserSession SQLAlchemy model that manages JWT refresh tokens, enabling seamless token refresh without forcing users to re-authenticate when access tokens expire.

## 1. Core Principles

**Security First**: Refresh tokens are hashed and stored securely with expiration tracking.
**Session Management**: Each user can have multiple active sessions across different devices.
**Automatic Cleanup**: Expired sessions are automatically cleaned up to prevent database bloat.
**Audit Trail**: Session creation, refresh, and termination events are logged for security.

## 2. UserSession Data Model

### SQLAlchemy Model Definition
```python
# File: backend/app/models/user_session.py
from sqlalchemy import Column, String, DateTime, Boolean, Text, ForeignKey, Index, Integer, Enum
from sqlalchemy.orm import relationship
from datetime import datetime, timedelta
import secrets
import hashlib
import enum

from app.models.base import Base, BaseMixin
from app.core.config import settings

class SessionStatus(str, enum.Enum):
    ACTIVE = "ACTIVE"
    EXPIRED = "EXPIRED"
    REVOKED = "REVOKED"

class UserSession(Base, BaseMixin):
    __tablename__ = 'user_sessions'
    
    # Core identification
    user_id = Column(ForeignKey('users.id'), nullable=False, index=True)
    
    # Session identification
    session_id = Column(String(255), unique=True, nullable=False, index=True)
    refresh_token_hash = Column(String(255), nullable=False, index=True)
    
    # Device and client information
    device_id = Column(String(255), nullable=True, index=True)
    device_name = Column(String(255), nullable=True)  # "iPhone 12", "Chrome on Windows"
    device_type = Column(String(50), nullable=True)   # "mobile", "desktop", "tablet"
    user_agent = Column(Text, nullable=True)
    ip_address = Column(String(45), nullable=True)    # IPv6 compatible
    
    # Location information (optional)
    country = Column(String(2), nullable=True)        # ISO country code
    city = Column(String(100), nullable=True)
    
    # Session lifecycle
    status = Column(Enum(SessionStatus), default=SessionStatus.ACTIVE, nullable=False, index=True)
    expires_at = Column(DateTime, nullable=False, index=True)
    last_used_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Security tracking
    refresh_count = Column(Integer, default=0, nullable=False)
    max_refreshes = Column(Integer, default=100, nullable=False)  # Prevent infinite refresh
    
    # Revocation details
    revoked_at = Column(DateTime, nullable=True)
    revoked_reason = Column(String(100), nullable=True)  # "user_logout", "security_breach", "admin_action"
    
    # Relationships
    user = relationship('User', back_populates='sessions')
    
    # Indexes for performance
    __table_args__ = (
        Index('idx_user_sessions_user_status', 'user_id', 'status'),
        Index('idx_user_sessions_expires_status', 'expires_at', 'status'),
        Index('idx_user_sessions_device', 'user_id', 'device_id'),
    )
    
    @classmethod
    def generate_refresh_token(cls) -> str:
        """Generate a cryptographically secure refresh token."""
        return secrets.token_urlsafe(64)  # 512 bits of entropy
    
    @classmethod
    def hash_refresh_token(cls, token: str) -> str:
        """Hash refresh token for secure storage."""
        return hashlib.sha256(token.encode()).hexdigest()
    
    @classmethod
    def create_session(cls, user_id: str, device_info: dict = None, 
                      ip_address: str = None, location_info: dict = None) -> tuple:
        """
        Create a new user session with refresh token.
        Returns: (UserSession instance, raw_refresh_token)
        """
        # Generate tokens
        session_id = secrets.token_urlsafe(32)
        refresh_token = cls.generate_refresh_token()
        refresh_token_hash = cls.hash_refresh_token(refresh_token)
        
        # Calculate expiration (default 30 days)
        expires_at = datetime.utcnow() + timedelta(
            seconds=settings.REFRESH_TOKEN_EXPIRE_SECONDS
        )
        
        # Extract device information
        device_info = device_info or {}
        location_info = location_info or {}
        
        session = cls(
            user_id=user_id,
            session_id=session_id,
            refresh_token_hash=refresh_token_hash,
            device_id=device_info.get('device_id'),
            device_name=device_info.get('device_name'),
            device_type=device_info.get('device_type'),
            user_agent=device_info.get('user_agent'),
            ip_address=ip_address,
            country=location_info.get('country'),
            city=location_info.get('city'),
            expires_at=expires_at
        )
        
        return session, refresh_token
    
    def is_valid(self) -> bool:
        """Check if session is valid and not expired."""
        if self.status != SessionStatus.ACTIVE:
            return False
        
        if self.expires_at <= datetime.utcnow():
            return False
        
        if self.refresh_count >= self.max_refreshes:
            return False
        
        return True
    
    def refresh(self) -> str:
        """
        Refresh the session with a new token.
        Returns: new_refresh_token
        """
        if not self.is_valid():
            raise ValueError("Cannot refresh invalid session")
        
        # Generate new refresh token
        new_refresh_token = self.generate_refresh_token()
        self.refresh_token_hash = self.hash_refresh_token(new_refresh_token)
        
        # Update session metadata
        self.refresh_count += 1
        self.last_used_at = datetime.utcnow()
        
        # Extend expiration (rolling window)
        self.expires_at = datetime.utcnow() + timedelta(
            seconds=settings.REFRESH_TOKEN_EXPIRE_SECONDS
        )
        
        return new_refresh_token
    
    def revoke(self, reason: str = "user_logout"):
        """Revoke the session."""
        self.status = SessionStatus.REVOKED
        self.revoked_at = datetime.utcnow()
        self.revoked_reason = reason
    
    def update_last_used(self, ip_address: str = None):
        """Update last used timestamp and optionally IP."""
        self.last_used_at = datetime.utcnow()
        if ip_address:
            self.ip_address = ip_address
    
    def to_dict(self) -> dict:
        """Convert session to dictionary for API responses."""
        return {
            "session_id": self.session_id,
            "device_name": self.device_name,
            "device_type": self.device_type,
            "ip_address": self.ip_address,
            "country": self.country,
            "city": self.city,
            "created_at": self.created_at.isoformat(),
            "last_used_at": self.last_used_at.isoformat(),
            "expires_at": self.expires_at.isoformat(),
            "status": self.status,
            "is_current": False  # Will be set by the service
        }
```

## 3. User Model Updates

### Enhanced User Model with Sessions
```python
# File: backend/app/models/user.py (additions)
from sqlalchemy.orm import relationship

class User(Base, BaseMixin):
    # ... existing fields ...
    
    # Relationships
    sessions = relationship('UserSession', back_populates='user', cascade='all, delete-orphan')
    
    def get_active_sessions(self) -> List['UserSession']:
        """Get all active sessions for the user."""
        from app.models.user_session import SessionStatus
        return [
            session for session in self.sessions 
            if session.status == SessionStatus.ACTIVE and session.is_valid()
        ]
    
    def revoke_all_sessions(self, reason: str = "security_action"):
        """Revoke all active sessions for the user."""
        for session in self.get_active_sessions():
            session.revoke(reason)
    
    def get_session_count(self) -> int:
        """Get count of active sessions."""
        return len(self.get_active_sessions())
```

## 4. UserSessionService Implementation

**IMPORTANT:** The complete UserSessionService implementation is defined in `2.5.1-Backend-User-Session-Service.md`. This file contains only the data model definition.

The service provides the following key methods:
- `create_session()` - Create new user session with refresh token
- `refresh_session()` - Refresh session and rotate token
- `revoke_session()` - Revoke specific session
- `revoke_all_user_sessions()` - Revoke all sessions for a user
- `get_user_sessions()` - List user's active sessions

Refer to `2.5.1-Backend-User-Session-Service.md` for the complete implementation.

## 5. Integration Notes

This UserSession model integrates with:
- **AuthService** for login/logout operations
- **UserSessionService** for session lifecycle management
- **JWT Security** for access token generation with session context
- **API Authentication** for request validation

**Next File:** `2.3-Backend-Security-JWT-Service.md` implements the JWT utilities used by this session system.
        try:
            # Check if user exists
            user = self.db.query(User).filter(User.id == user_id).first()
            if not user:
                raise ValidationError("User not found")
            
            # Limit concurrent sessions per user
            active_sessions = user.get_active_sessions()
            if len(active_sessions) >= settings.MAX_SESSIONS_PER_USER:
                # Revoke oldest session
                oldest_session = min(active_sessions, key=lambda s: s.last_used_at)
                oldest_session.revoke("session_limit_exceeded")
            
            # Create new session
            session, refresh_token = UserSession.create_session(
                user_id=user_id,
                device_info=device_info,
                ip_address=ip_address,
                location_info=location_info
            )
            
            self.db.add(session)
            self.db.commit()
            
            track_business_event("session_created", {
                "user_id": user_id,
                "session_id": session.session_id,
                "device_type": session.device_type,
                "ip_address": ip_address
            })
            
            return session, refresh_token
            
        except Exception as e:
            self.db.rollback()
            add_error_context("session_creation_error", {
                "user_id": user_id,
                "error": str(e)
            })
            raise
    
    @sentry_trace("session_refresh")
    def refresh_session(self, refresh_token: str, ip_address: str = None) -> Tuple[UserSession, str]:
        """Refresh a session with a new token."""
        try:
            # Hash the provided token
            token_hash = UserSession.hash_refresh_token(refresh_token)
            
            # Find session by token hash
            session = self.db.query(UserSession).filter(
                UserSession.refresh_token_hash == token_hash,
                UserSession.status == SessionStatus.ACTIVE
            ).first()
            
            if not session:
                raise AuthenticationError("Invalid refresh token")
            
            if not session.is_valid():
                session.status = SessionStatus.EXPIRED
                self.db.commit()
                raise AuthenticationError("Session expired")
            
            # Refresh the session
            new_refresh_token = session.refresh()
            
            # Update IP if provided
            if ip_address:
                session.update_last_used(ip_address)
            
            self.db.commit()
            
            track_business_event("session_refreshed", {
                "user_id": str(session.user_id),
                "session_id": session.session_id,
                "refresh_count": session.refresh_count
            })
            
            return session, new_refresh_token
            
        except Exception as e:
            self.db.rollback()
            add_error_context("session_refresh_error", {
                "error": str(e)
            })
            raise
    
    @sentry_trace("session_revoke")
    def revoke_session(self, session_id: str, user_id: str, reason: str = "user_logout") -> bool:
        """Revoke a specific session."""
        try:
            session = self.db.query(UserSession).filter(
                UserSession.session_id == session_id,
                UserSession.user_id == user_id,
                UserSession.status == SessionStatus.ACTIVE
            ).first()
            
            if not session:
                return False
            
            session.revoke(reason)
            self.db.commit()
            
            track_business_event("session_revoked", {
                "user_id": user_id,
                "session_id": session_id,
                "reason": reason
            })
            
            return True
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to revoke session {session_id}: {e}")
            return False
    
    def revoke_all_user_sessions(self, user_id: str, reason: str = "security_action") -> int:
        """Revoke all sessions for a user."""
        try:
            sessions = self.db.query(UserSession).filter(
                UserSession.user_id == user_id,
                UserSession.status == SessionStatus.ACTIVE
            ).all()
            
            revoked_count = 0
            for session in sessions:
                session.revoke(reason)
                revoked_count += 1
            
            self.db.commit()
            
            track_business_event("all_sessions_revoked", {
                "user_id": user_id,
                "revoked_count": revoked_count,
                "reason": reason
            })
            
            return revoked_count
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to revoke all sessions for user {user_id}: {e}")
            return 0
    
    def get_user_sessions(self, user_id: str, include_expired: bool = False) -> List[Dict[str, Any]]:
        """Get all sessions for a user."""
        query = self.db.query(UserSession).filter(UserSession.user_id == user_id)
        
        if not include_expired:
            query = query.filter(UserSession.status == SessionStatus.ACTIVE)
        
        sessions = query.order_by(UserSession.last_used_at.desc()).all()
        
        return [session.to_dict() for session in sessions]
    
    def cleanup_expired_sessions(self) -> int:
        """Clean up expired sessions."""
        try:
            # Mark expired sessions
            expired_count = self.db.query(UserSession).filter(
                UserSession.expires_at <= datetime.utcnow(),
                UserSession.status == SessionStatus.ACTIVE
            ).update({
                UserSession.status: SessionStatus.EXPIRED
            })
            
            # Delete very old sessions (older than 90 days)
            cutoff_date = datetime.utcnow() - timedelta(days=90)
            deleted_count = self.db.query(UserSession).filter(
                UserSession.expires_at <= cutoff_date
            ).delete()
            
            self.db.commit()
            
            logger.info(f"Session cleanup: {expired_count} expired, {deleted_count} deleted")
            return expired_count + deleted_count
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Session cleanup failed: {e}")
            return 0
```

## 5. Configuration Updates

### Environment Configuration for Sessions
```python
# File: backend/app/core/config.py (additions)
class Settings(BaseSettings):
    # ... existing settings ...
    
    # Session Configuration
    REFRESH_TOKEN_EXPIRE_SECONDS: int = 30 * 24 * 60 * 60  # 30 days
    MAX_SESSIONS_PER_USER: int = 10  # Maximum concurrent sessions
    SESSION_CLEANUP_INTERVAL_HOURS: int = 24  # How often to clean up expired sessions
    
    # Security settings
    REFRESH_TOKEN_ROTATION_ENABLED: bool = True  # Rotate refresh tokens on use
```

## 6. Database Migration

### Alembic Migration for UserSession
```python
# File: backend/alembic/versions/add_user_session_table.py
"""Add user session table

Revision ID: add_user_session_table
Revises: previous_revision
Create Date: 2025-01-01 00:00:00.000000

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers
revision = 'add_user_session_table'
down_revision = 'previous_revision'
branch_labels = None
depends_on = None

def upgrade():
    # Create user_sessions table
    op.create_table('user_sessions',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=False),
        sa.Column('user_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('session_id', sa.String(length=255), nullable=False),
        sa.Column('refresh_token_hash', sa.String(length=255), nullable=False),
        sa.Column('device_id', sa.String(length=255), nullable=True),
        sa.Column('device_name', sa.String(length=255), nullable=True),
        sa.Column('device_type', sa.String(length=50), nullable=True),
        sa.Column('user_agent', sa.Text(), nullable=True),
        sa.Column('ip_address', sa.String(length=45), nullable=True),
        sa.Column('country', sa.String(length=2), nullable=True),
        sa.Column('city', sa.String(length=100), nullable=True),
        sa.Column('status', sa.Enum('ACTIVE', 'EXPIRED', 'REVOKED', name='sessionstatus'), nullable=False),
        sa.Column('expires_at', sa.DateTime(), nullable=False),
        sa.Column('last_used_at', sa.DateTime(), nullable=False),
        sa.Column('refresh_count', sa.Integer(), nullable=False),
        sa.Column('max_refreshes', sa.Integer(), nullable=False),
        sa.Column('revoked_at', sa.DateTime(), nullable=True),
        sa.Column('revoked_reason', sa.String(length=100), nullable=True),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('session_id')
    )
    
    # Create indexes
    op.create_index('idx_user_sessions_user_status', 'user_sessions', ['user_id', 'status'])
    op.create_index('idx_user_sessions_expires_status', 'user_sessions', ['expires_at', 'status'])
    op.create_index('idx_user_sessions_device', 'user_sessions', ['user_id', 'device_id'])
    op.create_index(op.f('ix_user_sessions_user_id'), 'user_sessions', ['user_id'])
    op.create_index(op.f('ix_user_sessions_refresh_token_hash'), 'user_sessions', ['refresh_token_hash'])

def downgrade():
    op.drop_index(op.f('ix_user_sessions_refresh_token_hash'), table_name='user_sessions')
    op.drop_index(op.f('ix_user_sessions_user_id'), table_name='user_sessions')
    op.drop_index('idx_user_sessions_device', table_name='user_sessions')
    op.drop_index('idx_user_sessions_expires_status', table_name='user_sessions')
    op.drop_index('idx_user_sessions_user_status', table_name='user_sessions')
    op.drop_table('user_sessions')
    op.execute('DROP TYPE sessionstatus')
```

## 7. Next Steps

This UserSession data model provides:
- ✅ **Secure refresh token storage** with hashing and expiration
- ✅ **Multi-device session management** with device tracking
- ✅ **Session lifecycle management** with automatic cleanup
- ✅ **Security features** like session limits and revocation
- ✅ **Audit trail** for session events and security monitoring

**Next**: Update the Auth API endpoints to include the refresh endpoint and integrate this session management.
