Phase: 2 - User Identity & Authentication
Part: 2.9
Title: Frontend Authentication Hooks
Depends On: 2.8-Frontend-Auth-Storage-Utilities.md
Objective: To define the core @tanstack/react-query hooks for handling all user authentication flows. These custom hooks will encapsulate the logic for registration, login, logout, and fetching the current user's state, providing a simple, declarative API for our UI components.
1. Core Principle: Hooks as the Public API for UI
Our UI components will not know how to register a user, handle tokens, or display error notifications. They will simply call a hook like useLogin() and react to its state (isLoading, isError, etc.). This pattern leads to extremely clean, readable, and maintainable UI code.
useRegister: A useMutation hook for the signup form.
useLogin: A useMutation hook for the login form.
useLogout: A useMutation hook for the logout button.
useCurrentUser: A useQuery hook to fetch the current user's profile data, which will be used to protect routes and display user-specific information.
2. Authentication Service Layer
First, we define the methods in our AuthService that the hooks will call. This service acts as a clean bridge between our hooks and the apiClient.
File Location: frontend/src/services/auth.service.ts
File Content:

import { apiClient } from '@/lib/api/client';
import { LoginPayload, RegisterPayload, TokenResponse, User } from '@/types/auth';
import { ApiSuccessResponse } from '@/types/api';

export class AuthService {
  /**
   * Registers a new user.
   */
  static async register(payload: RegisterPayload): Promise<User> {
    const response = await apiClient.post<ApiSuccessResponse<User>>('/auth/register', payload);
    return response.data.data;
  }

  /**
   * Logs a user in and returns tokens and user data.
   */
  static async login(payload: LoginPayload): Promise<{ token: TokenResponse; user: User }> {
    const response = await apiClient.post<ApiSuccessResponse<{ token: TokenResponse; user: User }>>('/auth/login', payload);
    return response.data.data;
  }

  /**
   * Fetches the current user's profile.
   * Note: This endpoint doesn't exist yet, but we define the service for it now.
   * It will be created in the backend in a later phase.
   */
  static async getCurrentUser(): Promise<User> {
    const response = await apiClient.get<ApiSuccessResponse<User>>('/users/me');
    return response.data.data;
  }

  /**

   * Logs the user out.
   * Note: A server-side logout endpoint is good practice for token revocation.
   * For the MVP, we will start with a client-side only logout.
   */
  static async logout(): Promise<void> {
    // In the future, this would call: await apiClient.post('/auth/logout');
    return Promise.resolve();
  }
}
3. Custom Hooks Implementation (useAuth)
This file contains all the user-facing hooks for authentication.
File Location: frontend/src/hooks/useAuth.ts
File Content:
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { useRouter } from 'next/navigation';
import { toast } from 'react-hot-toast'; // A popular library for notifications

import { AuthService } from '@/services/auth.service';
import { setAuthTokens, clearAuthTokens, getAuthToken } from '@/lib/utils/auth-storage';
import { LoginPayload, RegisterPayload } from '@/types/auth';

// --- Query Key Factory ---
// A best practice for organizing query keys, making them easy to manage and invalidate.
export const authKeys = {
  all: ['auth'] as const,
  currentUser: () => [...authKeys.all, 'currentUser'] as const,
};

// --- Mutation Hooks ---

export const useRegister = () => {
  const router = useRouter();
  return useMutation({
    mutationFn: (payload: RegisterPayload) => AuthService.register(payload),
    onSuccess: (data) => {
      toast.success(`Welcome, ${data.full_name}! Please check your email to verify your account.`);
      // Redirect to the login page after successful registration.
      router.push('/login');
    },
    onError: (error: Error) => {
      // The apiClient interceptor formats the error message for us.
      toast.error(error.message);
    },
  });
};

export const useLogin = () => {
  const queryClient = useQueryClient();
  const router = useRouter();

  return useMutation({
    mutationFn: (payload: LoginPayload) => AuthService.login(payload),
    onSuccess: (data) => {
      // On successful login, store the tokens.
      setAuthTokens(data.token);
      // Manually set the user data in the cache to avoid an immediate re-fetch.
      queryClient.setQueryData(authKeys.currentUser(), data.user);
      toast.success(`Welcome back, ${data.user.full_name}!`);
      // Redirect to the main application dashboard.
      router.push('/dashboard');
    },
    onError: (error: Error) => {
      toast.error(error.message);
    },
  });
};

export const useLogout = () => {
  const queryClient = useQueryClient();
  const router = useRouter();

  return useMutation({
    mutationFn: AuthService.logout,
    onSuccess: () => {
      // Clear tokens from storage.
      clearAuthTokens();
      // Clear the entire react-query cache to remove all user data.
      queryClient.clear();
      // Redirect to the login page.
      router.push('/login');
      toast.success('You have been logged out.');
    },
    onError: (error: Error) => {
      // Even if the server call fails, clear local state as a fallback.
      clearAuthTokens();
      queryClient.clear();
      router.push('/login');
      toast.error('Logout failed. Your session has been cleared locally.');
    },
  });
};

// --- Query Hook ---

export const useCurrentUser = () => {
  return useQuery({
    queryKey: authKeys.currentUser(),
    // The query function will only run if an auth token exists.
    queryFn: () => AuthService.getCurrentUser(),
    // This is a crucial option: it prevents the query from running if the user is not logged in.
    enabled: !!getAuthToken(),
    // Mark this data as highly stable, as it rarely changes without a login/logout event.
    staleTime: Infinity,
  });
};

4. Next Steps
We have now built the complete data flow for authentication on the frontend. The final piece of this phase is to build the UI components that will use these hooks.
Next File: 2.10-Frontend-Auth-UI-Forms.md will implement the user-facing UI components for login and registration, connecting them to the useLogin and useRegister hooks.