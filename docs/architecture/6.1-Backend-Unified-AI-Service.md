Phase: 6 - Content & Analysis Suite
Part: 6.1
Title: Enterprise Unified AI Service
Depends On: 5.11-Suite-Overview.md
Objective: To implement the EnterpriseUnifiedAIService, a central orchestration layer for all AI interactions. This service abstracts the complexity of different AI models, manages prompt engineering, intelligently routes requests, handles transactional credit management, and ensures the quality and cost-effectiveness of all AI-powered features.
1. Core Principles: Abstraction, Quality, and Atomicity
Abstraction Layer: No other service will ever call the VertexAIClient directly. They will all go through this UnifiedAIService. This allows us to swap, add, or A/B test different AI models in the future without changing any business logic in our other services.
Quality Assurance Gateway: This service is responsible for providing a well-structured prompt to the AI and parsing the response. It acts as a gateway to ensure the data flowing to and from the AI model is clean and validated.
Atomic Operations: Every AI task that consumes credits is an atomic, transactional operation. The service will reserve credits, execute the AI task, and consume the credits in a single unit of work. If the AI task fails, the credit reservation is safely rolled back.
2. UnifiedAIService Pydantic Schemas
We define standardized request and response models to ensure consistent interaction with the AI service.
File Location: backend/app/schemas/ai_service_schemas.py
File Content:
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional
from enum import Enum

class PromptTask(str, Enum):
    """Enumeration of predefined, version-controlled AI tasks."""
    ANALYZE_SEO_DATA_V1 = "ANALYZE_SEO_DATA_V1"
    GENERATE_META_TAGS_V1 = "GENERATE_META_TAGS_V1"
    GENERATE_LLM_TXT_V1 = "GENERATE_LLM_TXT_V1"
    ANALYZE_CONTENT_GAPS_V1 = "ANALYZE_CONTENT_GAPS_V1"
    CLUSTER_KEYWORDS_V1 = "CLUSTER_KEYWORDS_V1"
    ANALYZE_COMPETITIVE_LANDSCAPE_V1 = "ANALYZE_COMPETITIVE_LANDSCAPE_V1"

class AITaskRequest(BaseModel):
    """A standardized request object for any AI task."""
    task: PromptTask
    project_id: str
    user_id: str
    organization_id: str
    context: Dict[str, Any] # The data to be used in the prompt
    estimated_credit_cost: int

class AITaskResponse(BaseModel):
    """A standardized response object from an AI task."""
    success: bool
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    model_used: str
    credits_consumed: int

3. Prompt Management System
To avoid hardcoding complex prompts inside our services, we will create a dedicated module for managing them. This allows for easy updates, versioning, and A/B testing of prompts.
File Location: backend/app/core/prompts.py
File Content:
from typing import Dict, Any
from jinja2 import Environment, FileSystemLoader, select_autoescape
from app.schemas.ai_service_schemas import PromptTask

class PromptManager:
    """Manages the loading and rendering of version-controlled prompt templates."""

    def __init__(self, template_dir: str = "app/prompts"):
        self.env = Environment(
            loader=FileSystemLoader(template_dir),
            autoescape=select_autoescape(['json'])
        )

    def get_prompt(self, task: PromptTask, context: Dict[str, Any]) -> str:
        """
        Loads a prompt template, renders it with the given context, and returns the final prompt string.
        """
        template_map = {
            PromptTask.ANALYZE_SEO_DATA_V1: "analyze_seo_data_v1.jinja2",
            PromptTask.GENERATE_META_TAGS_V1: "generate_meta_tags_v1.jinja2",
            # ... and so on for all other tasks
        }
        
        template_name = template_map.get(task)
        if not template_name:
            raise ValueError(f"No prompt template found for task: {task.value}")
            
        template = self.env.get_template(template_name)
        return template.render(context)

# Example Prompt Template
# File Location: backend/app/prompts/analyze_seo_data_v1.jinja2
"""
You are an expert SEO analyst. Analyze the following JSON data from a website scan and provide a concise, actionable summary.

Scan Data:
```json
{{ context.scan_data | tojson(indent=2) }}

Based on the data, perform the following tasks:
Provide a 1-2 sentence "Executive Summary" of the website's overall SEO health.
Identify the top 3 most critical issues that need immediate attention.
Calculate an "AI Citation Score" (an integer from 0-40).
Return your response ONLY as a valid JSON object with the following structure:
{
"executive_summary": "string",
"critical_issues": ["string issue 1", "string issue 2", "string issue 3"],
"ai_citation_score": integer
}
"""

### **4. `UnifiedAIService` Implementation**

This service is the core orchestrator for all AI operations.

**File Location:** `backend/app/services/unified_ai_service.py`
**File Content:**
```python
import logging
from sqlalchemy.orm import Session
from typing import Dict, Any

from app.core.config import settings
from app.core.exceptions import InsufficientCreditsError
from app.services.api_clients.vertexai_client import VertexAIClient
from app.services.credit_service import CreditService
from app.schemas.ai_service_schemas import AITaskRequest, AITaskResponse, PromptTask
from app.schemas.common_schemas import CreditActionType
from app.core.prompts import PromptManager

logger = logging.getLogger(__name__)

class EnterpriseUnifiedAIService:
    """
    A transactional service to orchestrate AI tasks and manage credits.
    It is the sole gateway to the VertexAIClient.
    """

    def __init__(self, db: Session):
        self.db = db
        self.vertex_client = VertexAIClient(settings)
        self.credit_service = CreditService(db)
        self.prompt_manager = PromptManager()

    def execute_ai_task(self, request: AITaskRequest) -> AITaskResponse:
        """
        Executes a given AI task within a single, atomic transaction.
        """
        reservation = None
        
        try:
            with self.db.begin_nested(): # Start a managed transaction
                # 1. Reserve Credits
                reservation = self.credit_service.reserve_credits(
                    organization_id=request.organization_id,
                    amount=request.estimated_credit_cost,
                    action_type=CreditActionType.AI_TASK,
                    description=f"AI Task: {request.task.value}",
                    user_id=request.user_id,
                    reference_id=request.project_id
                )

                # 2. Prepare the prompt
                prompt = self.prompt_manager.get_prompt(request.task, request.context)
                
                # 3. Execute the AI task (this is a synchronous call)
                # The VertexAIClient has its own resilience (retries, etc.)
                ai_result_text = self.vertex_client.generate_with_resilience(prompt)
                ai_result_data = self.vertex_client._parse_json_from_response(ai_result_text)

                if not ai_result_data:
                    raise Exception("AI task returned an invalid or empty response.")

                # 4. Consume Credits
                self.credit_service.consume_reservation(reservation.id, actual_cost=request.estimated_credit_cost)
            
            # The transaction is committed here if all steps succeed
            self.db.commit()

            logger.info(f"AI task {request.task.value} completed for project {request.project_id}")
            return AITaskResponse(
                success=True,
                data=ai_result_data,
                model_used="gemini-1.5-pro", # This could be dynamic later
                credits_consumed=request.estimated_credit_cost
            )

        except InsufficientCreditsError as e:
            self.db.rollback()
            logger.warning(f"AI Task for project {request.project_id} failed: {e}")
            return AITaskResponse(success=False, error=str(e), model_used="N/A", credits_consumed=0)
        
        except Exception as e:
            self.db.rollback()
            # If a reservation was made, it MUST be released.
            if reservation:
                self.credit_service.release_reservation(reservation.id)
                self.db.commit()

            logger.error(f"Critical error in AI task for project {request.project_id}: {e}", exc_info=True)
            return AITaskResponse(success=False, error="An internal AI service error occurred.", model_used="N/A", credits_consumed=0)

    5. Next Steps
With the UnifiedAIService established as our central AI brain, we have a powerful, abstract tool that other services can now use.
Next File: 6.2-Backend-Shared-Data-Processing.md will create a set of high-performance utility functions for common tasks like text cleaning and analysis, which will be used to prepare data before sending it to this AI service.
