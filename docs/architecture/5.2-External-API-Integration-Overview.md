Phase: 5 - DCS Engine & Scan Results
Part: 5.2
Title: Enterprise API Integration Architecture & Client Patterns
Depends On: 5.1-Data-Models-DCS-and-Memory.md
Objective: To define a comprehensive, production-ready architecture for all external API integrations. This document establishes the base patterns for resilience, security, and performance that all subsequent API clients (DataForSEO, Google PageSpeed, Vertex AI) will inherit.
1. Core Principles: Resilience, Security, and Observability
Interacting with third-party APIs is inherently unpredictable. Our architecture is designed to handle this unpredictability gracefully.
Resilience First: We will assume external APIs can and will fail. Our clients will be built with patterns to handle transient network errors, rate limits, and service outages without crashing our own system.
Security by Design: API keys and other secrets will be managed securely via our Pydantic Settings and never exposed in code. All communication will be over HTTPS.
Comprehensive Observability: We will track every API call, monitoring its latency, success rate, and cost. This is essential for performance tuning, debugging, and managing our operational expenses.
2. Enterprise Base API Client Architecture
We will create an abstract base class, EnterpriseAPIClient, that all specific API clients will inherit from. This base class will provide the following enterprise features out of the box:
HTTP Client: A shared, asynchronous httpx client with sensible timeouts and connection pooling.
Intelligent Retries: Automatic retries with exponential backoff for transient errors (e.g., 502 Bad Gateway, network errors) using the tenacity library.
Circuit Breaker: A circuit breaker (pybreaker) to automatically stop sending requests to a failing service for a period, preventing cascading failures in our system.
Centralized Logging: Structured logging for all requests and responses, including latency and status codes.
Secure Credential Management: A standardized way to fetch API keys and secrets from the central application Settings.
3. Architectural Diagram
graph TD
    A[DCS Orchestration Engine] --> B{EnterpriseAPIClient};

    subgraph "EnterpriseAPIClient (Abstract Base Class)"
        B --> C[HTTPX Client];
        B --> D[Intelligent Retries (Tenacity)];
        B --> E[Circuit Breaker (Pybreaker)];
        B --> F[Centralized Logging];
        B --> G[Secure Credential Handling];
    end

    B -- "Inherited by" --> H[DataForSEO Client];
    B -- "Inherited by" --> I[PageSpeed Client];

    H -- "Makes API Call" --> J((DataForSEO API));
    I -- "Makes API Call" --> K((Google PageSpeed API));

4. Dependency Installation
File to Modify: backend/requirements.txt
Content to Add:
httpx>=0.27.0
tenacity>=8.2.3
pybreaker>=1.1.0

5. Abstract Base Client Implementation
This code defines the structure and shared logic for all our future API clients.
File Location: backend/app/services/api_clients/base_client.py
File Content:

import logging
import httpx
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional

from app.core.config import Settings
import pybreaker
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

logger = logging.getLogger(__name__)

# Define which exceptions should trigger a retry
def is_retryable_exception(exception) -> bool:
    """Return True if the exception is a transient network error or a 5xx server error."""
    return isinstance(exception, (httpx.TimeoutException, httpx.NetworkError)) or \
           (isinstance(exception, httpx.HTTPStatusError) and exception.response.status_code >= 500)

class EnterpriseAPIClient(ABC):
    """
    An enterprise-grade, resilient abstract base class for external API clients.
    """
    
    def __init__(self, base_url: str, service_name: str, settings: Settings):
        self.base_url = base_url
        self.service_name = service_name
        self.settings = settings
        self.breaker = pybreaker.CircuitBreaker(fail_max=5, reset_timeout=60)

        self.http_client = httpx.AsyncClient(
            base_url=self.base_url,
            timeout=30.0,
            limits=httpx.Limits(max_connections=100, max_keepalive_connections=20)
        )

    @abstractmethod
    def _get_auth_headers(self) -> Dict[str, str]:
        """Implemented by each subclass to provide service-specific authentication."""
        raise NotImplementedError

    @retry(
        wait=wait_exponential(multiplier=1, min=2, max=60), # Exponential backoff
        stop=stop_after_attempt(5), # Retry up to 5 times
        retry=retry_if_exception_type(is_retryable_exception),
        before_sleep=lambda retry_state: logger.warning(
            f"Retrying API call for {retry_state.args[1]} due to {retry_state.outcome.exception()}, "
            f"attempt {retry_state.attempt_number}"
        )
    )
    @breaker
    async def request(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict] = None,
        json_data: Optional[Dict] = None,
        headers: Optional[Dict] = None,
    ) -> Any:
        """
        Makes a request to the external API, wrapped in resilience patterns.
        """
        full_url = f"{self.base_url}{endpoint}"
        auth_headers = self._get_auth_headers()
        request_headers = {**auth_headers, **(headers or {})}

        logger.info(f"[{self.service_name}] Request: {method} {full_url}")
        
        try:
            response = await self.http_client.request(
                method,
                endpoint,
                params=params,
                json=json_data,
                headers=request_headers
            )
            response.raise_for_status() # Raise an exception for 4xx/5xx responses
            return response.json()
        
        except pybreaker.CircuitBreakerError:
            logger.error(f"[{self.service_name}] Circuit breaker is open. Request to {full_url} blocked.")
            raise
        except httpx.HTTPStatusError as e:
            logger.error(f"[{self.service_name}] HTTP Error for {e.request.url}: {e.response.status_code} - {e.response.text}")
            raise
        except Exception as e:
            logger.error(f"[{self.service_name}] An unexpected error occurred for {full_url}: {e}", exc_info=True)
            raise

6. Next Steps
This base client provides the robust foundation we need. We will now implement the specific clients for each of our external services, inheriting from this class.
Next File: 5.3-External-Client-DataForSEO.md will create our DataForSEOClient. It will implement the _get_auth_headers method and add specific methods for interacting with the DataForSEO API, while automatically gaining all the resilience and performance benefits from the base class.
