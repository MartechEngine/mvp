Phase: 5 - DCS Engine and Data Foundation
Part: 5.13
Title: Backend Notification Service
Depends On: 2.6.1-Backend-Email-Service.md, 5.9-Backend-Real-Time-Progress-API.md
Objective: To implement a comprehensive notification system that handles real-time user engagement, system alerts, billing notifications, and scan completion updates. This service integrates multiple delivery channels including email, in-app notifications, and push notifications.

## 1. Core Principles

**Multi-Channel Delivery**: Support for email, in-app, push notifications, and future channels like SMS.
**User Preferences**: Granular user control over notification types and delivery methods.
**Real-Time & Async**: Immediate in-app notifications with async email/push delivery.
**Template-Based**: Consistent messaging with customizable templates and internationalization.

## 2. Notification Data Models

### Notification Template Model
```python
# File: backend/app/models/notification_template.py
from sqlalchemy import Column, String, Text, Boolean, Enum, JSON
from app.models.base import Base, BaseMixin
import enum

class NotificationType(str, enum.Enum):
    # System notifications
    SCAN_COMPLETED = "SCAN_COMPLETED"
    SCAN_FAILED = "SCAN_FAILED"
    SCAN_STARTED = "SCAN_STARTED"
    
    # Billing notifications
    CREDIT_LOW_WARNING = "CREDIT_LOW_WARNING"
    CREDIT_DEPLETED = "CREDIT_DEPLETED"
    SUBSCRIPTION_EXPIRING = "SUBSCRIPTION_EXPIRING"
    SUBSCRIPTION_RENEWED = "SUBSCRIPTION_RENEWED"
    PAYMENT_FAILED = "PAYMENT_FAILED"
    
    # Content notifications
    CONTENT_GENERATED = "CONTENT_GENERATED"
    ANALYSIS_READY = "ANALYSIS_READY"
    REPORT_AVAILABLE = "REPORT_AVAILABLE"
    
    # Account notifications
    EMAIL_VERIFIED = "EMAIL_VERIFIED"
    PASSWORD_CHANGED = "PASSWORD_CHANGED"
    PROFILE_UPDATED = "PROFILE_UPDATED"
    
    # Team notifications
    USER_INVITED = "USER_INVITED"
    USER_JOINED = "USER_JOINED"
    ROLE_CHANGED = "ROLE_CHANGED"

class NotificationChannel(str, enum.Enum):
    IN_APP = "IN_APP"
    EMAIL = "EMAIL"
    PUSH = "PUSH"
    SMS = "SMS"

class NotificationTemplate(Base, BaseMixin):
    __tablename__ = 'notification_templates'
    
    notification_type = Column(Enum(NotificationType), nullable=False)
    channel = Column(Enum(NotificationChannel), nullable=False)
    
    # Template content
    title_template = Column(String(255), nullable=False)
    body_template = Column(Text, nullable=False)
    action_url_template = Column(String(500), nullable=True)
    
    # Metadata
    icon = Column(String(100), nullable=True)  # Icon name for in-app notifications
    priority = Column(String(20), default='normal')  # low, normal, high, urgent
    
    # Configuration
    is_active = Column(Boolean, default=True)
    default_enabled = Column(Boolean, default=True)  # Default user preference
    
    # Unique constraint on type + channel
    __table_args__ = (
        UniqueConstraint('notification_type', 'channel', name='_notification_type_channel_uc'),
    )
```

### Notification Model
```python
# File: backend/app/models/notification.py
from sqlalchemy import Column, String, Text, DateTime, Boolean, Enum, ForeignKey, JSON
from sqlalchemy.orm import relationship
from app.models.base import Base, BaseMixin

class NotificationStatus(str, enum.Enum):
    PENDING = "PENDING"
    SENT = "SENT"
    DELIVERED = "DELIVERED"
    READ = "READ"
    FAILED = "FAILED"

class Notification(Base, BaseMixin):
    __tablename__ = 'notifications'
    
    # Core identification
    notification_type = Column(Enum(NotificationType), nullable=False)
    channel = Column(Enum(NotificationChannel), nullable=False)
    
    # Recipients
    user_id = Column(ForeignKey('users.id'), nullable=False)
    organization_id = Column(ForeignKey('organizations.id'), nullable=False)
    
    # Content
    title = Column(String(255), nullable=False)
    body = Column(Text, nullable=False)
    action_url = Column(String(500), nullable=True)
    
    # Metadata
    icon = Column(String(100), nullable=True)
    priority = Column(String(20), default='normal')
    context_data = Column(JSON, nullable=True)  # Additional data for the notification
    
    # Related entities
    project_id = Column(ForeignKey('projects.id'), nullable=True)
    scan_result_id = Column(ForeignKey('scan_results.id'), nullable=True)
    
    # Status tracking
    status = Column(Enum(NotificationStatus), default=NotificationStatus.PENDING)
    sent_at = Column(DateTime, nullable=True)
    delivered_at = Column(DateTime, nullable=True)
    read_at = Column(DateTime, nullable=True)
    
    # Delivery tracking
    external_id = Column(String(255), nullable=True)  # ID from external service (email, push)
    error_message = Column(Text, nullable=True)
    retry_count = Column(Integer, default=0)
    
    # Relationships
    user = relationship('User', back_populates='notifications')
    organization = relationship('Organization')
    project = relationship('Project')
    scan_result = relationship('ScanResult')
```

### User Notification Preferences Model
```python
# File: backend/app/models/user_notification_preferences.py
from sqlalchemy import Column, Boolean, ForeignKey, Enum
from sqlalchemy.orm import relationship
from app.models.base import Base, BaseMixin

class UserNotificationPreferences(Base, BaseMixin):
    __tablename__ = 'user_notification_preferences'
    
    user_id = Column(ForeignKey('users.id'), nullable=False)
    notification_type = Column(Enum(NotificationType), nullable=False)
    channel = Column(Enum(NotificationChannel), nullable=False)
    
    is_enabled = Column(Boolean, default=True)
    
    # Relationships
    user = relationship('User', back_populates='notification_preferences')
    
    # Unique constraint
    __table_args__ = (
        UniqueConstraint('user_id', 'notification_type', 'channel', 
                        name='_user_notification_type_channel_uc'),
    )
```

## 3. Notification Service Implementation

```python
# File: backend/app/services/notification_service.py
import logging
from typing import Dict, Any, Optional, List
from sqlalchemy.orm import Session
from datetime import datetime
from jinja2 import Template

from app.core.config import settings
from app.models.notification import Notification, NotificationStatus, NotificationChannel
from app.models.notification_template import NotificationTemplate, NotificationType
from app.models.user_notification_preferences import UserNotificationPreferences
from app.models.user import User
from app.services.email_service import EmailService
from app.tasks.notification_tasks import send_notification_async

logger = logging.getLogger(__name__)

class NotificationService:
    """
    Comprehensive notification service handling multiple delivery channels.
    """
    
    def __init__(self, db: Session):
        self.db = db
        self.email_service = EmailService(db)
    
    async def send_notification(self, notification_type: NotificationType,
                               user_id: str, context_data: Dict[str, Any],
                               channels: Optional[List[NotificationChannel]] = None,
                               project_id: Optional[str] = None,
                               scan_result_id: Optional[str] = None) -> List[Notification]:
        """
        Send notification across specified channels.
        """
        user = self.db.query(User).filter_by(id=user_id).first()
        if not user:
            logger.error(f"User not found: {user_id}")
            return []
        
        # Determine channels to use
        if channels is None:
            channels = self._get_user_enabled_channels(user_id, notification_type)
        
        notifications = []
        
        for channel in channels:
            # Check if user has this channel enabled
            if not self._is_channel_enabled(user_id, notification_type, channel):
                continue
            
            # Get template for this notification type and channel
            template = self._get_template(notification_type, channel)
            if not template:
                logger.warning(f"No template found for {notification_type} on {channel}")
                continue
            
            # Render notification content
            rendered_content = self._render_notification(template, context_data)
            
            # Create notification record
            notification = Notification(
                notification_type=notification_type,
                channel=channel,
                user_id=user_id,
                organization_id=user.organization_id,
                title=rendered_content['title'],
                body=rendered_content['body'],
                action_url=rendered_content.get('action_url'),
                icon=template.icon,
                priority=template.priority,
                context_data=context_data,
                project_id=project_id,
                scan_result_id=scan_result_id
            )
            
            self.db.add(notification)
            self.db.flush()  # Get the ID
            
            # Send notification based on channel
            if channel == NotificationChannel.IN_APP:
                # In-app notifications are immediately available
                notification.status = NotificationStatus.SENT
                notification.sent_at = datetime.utcnow()
            else:
                # Queue async delivery for other channels
                send_notification_async.delay(str(notification.id))
            
            notifications.append(notification)
        
        self.db.commit()
        return notifications
    
    async def send_scan_completed_notification(self, user_id: str, project_name: str,
                                              scan_result_id: str, dcs_score: float):
        """Send notification when DCS scan completes."""
        context_data = {
            'project_name': project_name,
            'scan_result_id': scan_result_id,
            'dcs_score': dcs_score,
            'scan_url': f"{settings.FRONTEND_URL}/projects/scans/{scan_result_id}"
        }
        
        await self.send_notification(
            NotificationType.SCAN_COMPLETED,
            user_id,
            context_data,
            scan_result_id=scan_result_id
        )
    
    async def send_credit_low_warning(self, user_id: str, current_credits: int,
                                     threshold: int):
        """Send notification when credits are running low."""
        context_data = {
            'current_credits': current_credits,
            'threshold': threshold,
            'billing_url': f"{settings.FRONTEND_URL}/billing"
        }
        
        await self.send_notification(
            NotificationType.CREDIT_LOW_WARNING,
            user_id,
            context_data
        )
    
    async def send_subscription_expiring_notification(self, user_id: str,
                                                     expires_in_days: int):
        """Send notification when subscription is expiring."""
        context_data = {
            'expires_in_days': expires_in_days,
            'billing_url': f"{settings.FRONTEND_URL}/billing"
        }
        
        await self.send_notification(
            NotificationType.SUBSCRIPTION_EXPIRING,
            user_id,
            context_data
        )
    
    def get_user_notifications(self, user_id: str, unread_only: bool = False,
                              limit: int = 50) -> List[Notification]:
        """Get notifications for a user."""
        query = self.db.query(Notification).filter(
            Notification.user_id == user_id,
            Notification.channel == NotificationChannel.IN_APP
        )
        
        if unread_only:
            query = query.filter(Notification.read_at.is_(None))
        
        return query.order_by(Notification.created_at.desc()).limit(limit).all()
    
    def mark_notification_as_read(self, notification_id: str, user_id: str) -> bool:
        """Mark a notification as read."""
        notification = self.db.query(Notification).filter(
            Notification.id == notification_id,
            Notification.user_id == user_id
        ).first()
        
        if notification and not notification.read_at:
            notification.read_at = datetime.utcnow()
            notification.status = NotificationStatus.READ
            self.db.commit()
            return True
        
        return False
    
    def mark_all_as_read(self, user_id: str) -> int:
        """Mark all notifications as read for a user."""
        count = self.db.query(Notification).filter(
            Notification.user_id == user_id,
            Notification.channel == NotificationChannel.IN_APP,
            Notification.read_at.is_(None)
        ).update({
            'read_at': datetime.utcnow(),
            'status': NotificationStatus.READ
        })
        
        self.db.commit()
        return count
    
    def get_unread_count(self, user_id: str) -> int:
        """Get count of unread notifications for a user."""
        return self.db.query(Notification).filter(
            Notification.user_id == user_id,
            Notification.channel == NotificationChannel.IN_APP,
            Notification.read_at.is_(None)
        ).count()
    
    def _get_user_enabled_channels(self, user_id: str, 
                                  notification_type: NotificationType) -> List[NotificationChannel]:
        """Get enabled channels for a user and notification type."""
        preferences = self.db.query(UserNotificationPreferences).filter(
            UserNotificationPreferences.user_id == user_id,
            UserNotificationPreferences.notification_type == notification_type,
            UserNotificationPreferences.is_enabled == True
        ).all()
        
        if preferences:
            return [pref.channel for pref in preferences]
        
        # If no preferences set, use defaults from templates
        templates = self.db.query(NotificationTemplate).filter(
            NotificationTemplate.notification_type == notification_type,
            NotificationTemplate.is_active == True,
            NotificationTemplate.default_enabled == True
        ).all()
        
        return [template.channel for template in templates]
    
    def _is_channel_enabled(self, user_id: str, notification_type: NotificationType,
                           channel: NotificationChannel) -> bool:
        """Check if a specific channel is enabled for user."""
        preference = self.db.query(UserNotificationPreferences).filter(
            UserNotificationPreferences.user_id == user_id,
            UserNotificationPreferences.notification_type == notification_type,
            UserNotificationPreferences.channel == channel
        ).first()
        
        if preference:
            return preference.is_enabled
        
        # If no preference set, check template default
        template = self._get_template(notification_type, channel)
        return template.default_enabled if template else False
    
    def _get_template(self, notification_type: NotificationType,
                     channel: NotificationChannel) -> Optional[NotificationTemplate]:
        """Get notification template."""
        return self.db.query(NotificationTemplate).filter(
            NotificationTemplate.notification_type == notification_type,
            NotificationTemplate.channel == channel,
            NotificationTemplate.is_active == True
        ).first()
    
    def _render_notification(self, template: NotificationTemplate,
                           context_data: Dict[str, Any]) -> Dict[str, str]:
        """Render notification content from template."""
        try:
            title = Template(template.title_template).render(**context_data)
            body = Template(template.body_template).render(**context_data)
            action_url = None
            
            if template.action_url_template:
                action_url = Template(template.action_url_template).render(**context_data)
            
            return {
                'title': title,
                'body': body,
                'action_url': action_url
            }
        except Exception as e:
            logger.error(f"Failed to render notification template: {e}")
            return {
                'title': 'Notification',
                'body': 'You have a new notification.',
                'action_url': None
            }
```

## 4. Async Notification Tasks

```python
# File: backend/app/tasks/notification_tasks.py
import logging
from celery import shared_task
from sqlalchemy.orm import Session

from app.core.database import SessionLocal
from app.models.notification import Notification, NotificationStatus, NotificationChannel
from app.services.email_service import EmailService
from app.services.push_notification_service import PushNotificationService

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3, default_retry_delay=300)
def send_notification_async(self, notification_id: str):
    """
    Async task to send notification via external channels.
    """
    db: Session = SessionLocal()
    
    try:
        notification = db.query(Notification).filter_by(id=notification_id).first()
        if not notification:
            logger.error(f"Notification not found: {notification_id}")
            return
        
        success = False
        
        if notification.channel == NotificationChannel.EMAIL:
            success = await self._send_email_notification(db, notification)
        elif notification.channel == NotificationChannel.PUSH:
            success = await self._send_push_notification(db, notification)
        elif notification.channel == NotificationChannel.SMS:
            success = await self._send_sms_notification(db, notification)
        
        if success:
            notification.status = NotificationStatus.SENT
            notification.sent_at = datetime.utcnow()
        else:
            notification.status = NotificationStatus.FAILED
            notification.retry_count += 1
            
            # Retry if not exceeded max retries
            if notification.retry_count < 3:
                raise self.retry(exc=Exception("Notification delivery failed"))
        
        db.commit()
        
    except Exception as exc:
        logger.error(f"Notification task failed: {exc}")
        if db.is_active:
            db.rollback()
        raise
    finally:
        db.close()

async def _send_email_notification(db: Session, notification: Notification) -> bool:
    """Send notification via email."""
    try:
        email_service = EmailService(db)
        
        # Use the notification content as email content
        # In a real implementation, you might want to use different email templates
        await email_service._queue_email(
            email_type=EmailType.NOTIFICATION,  # You'd need to add this type
            recipient_email=notification.user.email,
            template_vars={
                'title': notification.title,
                'body': notification.body,
                'action_url': notification.action_url,
                'user_name': notification.user.full_name
            },
            user_id=notification.user_id
        )
        
        return True
    except Exception as e:
        logger.error(f"Email notification failed: {e}")
        return False

async def _send_push_notification(db: Session, notification: Notification) -> bool:
    """Send push notification."""
    try:
        push_service = PushNotificationService()
        
        result = await push_service.send_notification(
            user_id=notification.user_id,
            title=notification.title,
            body=notification.body,
            data={
                'notification_id': str(notification.id),
                'action_url': notification.action_url,
                'type': notification.notification_type
            }
        )
        
        if result.success:
            notification.external_id = result.message_id
            return True
        else:
            notification.error_message = result.error_message
            return False
            
    except Exception as e:
        logger.error(f"Push notification failed: {e}")
        notification.error_message = str(e)
        return False

async def _send_sms_notification(db: Session, notification: Notification) -> bool:
    """Send SMS notification."""
    # Implementation for SMS notifications
    # This would integrate with services like Twilio
    logger.info(f"SMS notification not implemented: {notification.id}")
    return False
```

## 5. Notification API Endpoints

```python
# File: backend/app/api/v1/endpoints/notifications.py
import logging
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional

from app.core.database import get_db
from app.api.v1.dependencies.auth_deps import get_current_active_user
from app.models.user import User as UserModel
from app.services.notification_service import NotificationService
from app.schemas.common_schemas import APISuccessResponse

logger = logging.getLogger(__name__)
router = APIRouter()

@router.get("/", response_model=APISuccessResponse[List[dict]])
async def get_notifications(
    unread_only: bool = Query(False, description="Get only unread notifications"),
    limit: int = Query(50, ge=1, le=100, description="Number of notifications"),
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Get user notifications."""
    notification_service = NotificationService(db)
    
    notifications = notification_service.get_user_notifications(
        str(current_user.id), unread_only, limit
    )
    
    return APISuccessResponse(data=[{
        'id': str(notification.id),
        'type': notification.notification_type,
        'title': notification.title,
        'body': notification.body,
        'action_url': notification.action_url,
        'icon': notification.icon,
        'priority': notification.priority,
        'created_at': notification.created_at.isoformat(),
        'read_at': notification.read_at.isoformat() if notification.read_at else None,
        'context_data': notification.context_data
    } for notification in notifications])

@router.get("/unread-count")
async def get_unread_count(
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Get count of unread notifications."""
    notification_service = NotificationService(db)
    
    count = notification_service.get_unread_count(str(current_user.id))
    
    return APISuccessResponse(data={'unread_count': count})

@router.post("/{notification_id}/read")
async def mark_notification_read(
    notification_id: str,
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Mark a notification as read."""
    notification_service = NotificationService(db)
    
    success = notification_service.mark_notification_as_read(
        notification_id, str(current_user.id)
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Notification not found"
        )
    
    return APISuccessResponse(message="Notification marked as read")

@router.post("/mark-all-read")
async def mark_all_notifications_read(
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Mark all notifications as read."""
    notification_service = NotificationService(db)
    
    count = notification_service.mark_all_as_read(str(current_user.id))
    
    return APISuccessResponse(data={'marked_count': count})
```

## 6. Integration with Existing Services

Update DCS scan task to send notifications:

```python
# File: backend/app/tasks/dcs_tasks.py (modification)
from app.services.notification_service import NotificationService

@shared_task(bind=True, max_retries=3, default_retry_delay=300)
def run_dcs_scan(self, audit_id: str):
    db: Session = SessionLocal()
    notification_service = NotificationService(db)
    
    try:
        # ... existing scan logic ...
        
        if audit.status == AuditStatus.COMPLETED:
            # Send completion notification
            await notification_service.send_scan_completed_notification(
                user_id=str(audit.project.user_id),
                project_name=audit.project.name,
                scan_result_id=str(scan_result.id),
                dcs_score=scan_result.dcs_score or 0
            )
        
    except Exception as exc:
        # Send failure notification
        await notification_service.send_notification(
            NotificationType.SCAN_FAILED,
            str(audit.project.user_id),
            {'project_name': audit.project.name, 'error': str(exc)}
        )
        raise
```

## 7. Default Notification Templates

```python
# File: backend/app/core/notification_templates.py
from app.models.notification_template import NotificationTemplate, NotificationType, NotificationChannel

DEFAULT_TEMPLATES = {
    (NotificationType.SCAN_COMPLETED, NotificationChannel.IN_APP): {
        'title': 'Scan completed for {{ project_name }}',
        'body': 'Your DCS scan has completed with a score of {{ dcs_score }}. View results now.',
        'action_url': '{{ scan_url }}',
        'icon': 'check-circle',
        'priority': 'normal'
    },
    (NotificationType.SCAN_COMPLETED, NotificationChannel.EMAIL): {
        'title': 'DCS Scan Complete - {{ project_name }}',
        'body': 'Your DCS scan for {{ project_name }} has completed successfully with a score of {{ dcs_score }}. Click here to view the detailed results.',
        'action_url': '{{ scan_url }}',
        'priority': 'normal'
    },
    (NotificationType.CREDIT_LOW_WARNING, NotificationChannel.IN_APP): {
        'title': 'Credits running low',
        'body': 'You have {{ current_credits }} credits remaining. Consider purchasing more to continue using all features.',
        'action_url': '{{ billing_url }}',
        'icon': 'warning',
        'priority': 'high'
    }
}

def seed_notification_templates(db):
    """Seed default notification templates."""
    for (notification_type, channel), template_data in DEFAULT_TEMPLATES.items():
        existing = db.query(NotificationTemplate).filter_by(
            notification_type=notification_type,
            channel=channel
        ).first()
        
        if not existing:
            template = NotificationTemplate(
                notification_type=notification_type,
                channel=channel,
                title_template=template_data['title'],
                body_template=template_data['body'],
                action_url_template=template_data.get('action_url'),
                icon=template_data.get('icon'),
                priority=template_data.get('priority', 'normal')
            )
            db.add(template)
    
    db.commit()
```

## 8. Next Steps

This Notification Service provides:
- ✅ **Multi-channel delivery** (in-app, email, push, SMS)
- ✅ **User preference management** with granular controls
- ✅ **Template-based messaging** with Jinja2 rendering
- ✅ **Real-time in-app notifications** with async external delivery
- ✅ **Integration points** for all major user flows

**Next File**: Create enhanced monitoring and APM integration architecture to improve observability.
