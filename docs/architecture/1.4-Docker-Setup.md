Phase: 1 - Foundation & Core Infrastructure
Part: 1.4
Title: Enterprise Docker & Containerization Strategy
Depends On: 1.3-Production-Security-GCP.md
Objective: To create production-ready, secure, and optimized Docker images for both the backend and frontend. This file also defines a docker-compose.yml for a consistent and high-performance local development experience that uses these production-ready images as a base.
1. Enterprise Principle: Build Once, Deploy Anywhere
The Dockerfile for each service is designed to create a self-contained, secure, and optimized image suitable for a production deployment. Our local development environment, managed by docker-compose.yml, will use these same images but will add development-specific configurations (like mounting source code for hot-reloading) on top. This ensures that the environment we develop in is as close to production as possible, minimizing surprises during deployment.
2. Backend Dockerfile (Production-Ready)
This multi-stage Dockerfile creates a slim, secure image for the FastAPI application. It installs dependencies in a virtual environment and runs the application as a non-root user for enhanced security.
File Location: backend/Dockerfile
File Content:
# --- Stage 1: Builder ---
# This stage builds a virtual environment with all necessary dependencies.
FROM python:3.11-slim as builder

# Set environment variables to prevent generating .pyc files and ensure output is sent directly
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# Install OS-level dependencies required for compiling some Python packages
RUN apt-get update && apt-get install -y --no-install-recommends build-essential

# Create and activate a virtual environment
WORKDIR /opt/venv
RUN python -m venv .
ENV PATH="/opt/venv/bin:$PATH"

# Copy and install Python requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# --- Stage 2: Final Production Image ---
FROM python:3.11-slim

# Create a dedicated, non-root user for security
RUN addgroup --system --gid 1001 appgroup && \
    adduser --system --uid 1001 --ingroup appgroup appuser

# Set the working directory inside the app user's home
WORKDIR /home/appuser

# Copy the pre-built virtual environment from the builder stage
COPY --from=builder /opt/venv /opt/venv

# Copy the application code with ownership set to the non-root user
# This prevents the code from being owned by root
COPY --chown=appuser:appgroup ./app ./app

# Set the PATH environment variable to use the virtual environment's executables
ENV PATH="/opt/venv/bin:$PATH"

# Switch to the non-root user
USER appuser

# Expose the port the application will run on
EXPOSE 8000

# The default command to run the application in a production environment using Gunicorn.
# This will be used in production. Docker Compose will override this for local development.
CMD ["gunicorn", "-k", "uvicorn.workers.UvicornWorker", "app.main:app", "--bind", "0.0.0.0:8000"]

3. Frontend Dockerfile (Production-Ready)
This multi-stage Dockerfile builds the Next.js application and creates a minimal, optimized image containing only the necessary production artifacts, running as a non-root user.
File Location: frontend/Dockerfile
File Content:
# --- Stage 1: Dependency Installation ---
FROM node:18-alpine AS deps
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm ci

# --- Stage 2: Builder ---
# This stage builds the Next.js application.
FROM node:18-alpine AS builder
WORKDIR /usr/src/app
COPY --from=deps /usr/src/app/node_modules ./node_modules
COPY . .

# Build the Next.js application for production
RUN npm run build

# --- Stage 3: Final Production Image ---
FROM node:18-alpine
WORKDIR /usr/src/app

# Create a dedicated, non-root user for security
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 nextjs

# Copy only the necessary production artifacts from the builder stage
COPY --from=builder /usr/src/app/public ./public
COPY --from=builder --chown=nextjs:nodejs /usr/src/app/.next ./.next
COPY --from=builder /usr/src/app/node_modules ./node_modules
COPY --from=builder /usr/src/app/package.json ./package.json

# Switch to the non-root user
USER nextjs

# Expose the port the application will run on
EXPOSE 3000
ENV PORT 3000

# The default command to run the application in a production environment.
# This will be used in production. Docker Compose will override this for local development.
CMD ["npm", "start"]

4. Root Environment File for Docker Compose
Docker Compose requires a root .env file for PostgreSQL and Redis configuration. This is separate from the backend/.env file.
File Location: /.env
File Content:
# === Docker Compose Environment Variables ===
# These are used by docker-compose.yml for database configuration
# This is SEPARATE from backend/.env which contains application settings

# PostgreSQL Configuration
POSTGRES_USER=martech_user
POSTGRES_PASSWORD=secure_password
POSTGRES_DB=martechengine_dev

# Note: The backend/.env file contains the full DATABASE_URL that references these values
# Example: DATABASE_URL=postgresql://martech_user:secure_password@postgres:5432/martechengine_dev

5. Docker Compose for Local Development
This file orchestrates the entire stack for a smooth local development experience. It uses the production Dockerfiles as a base but mounts the local source code for live reloading.
File Location: /docker-compose.yml
File Content:
version: '3.8'

services:
  # Backend Service (FastAPI)
  backend:
    build:
      context: ./backend
    container_name: martech-backend-dev
    env_file:
      - ./backend/.env
    volumes:
      # Mount the application code for live reloading
      - ./backend/app:/home/appuser/app
    ports:
      - "8000:8000"
    # Override the production CMD for development with hot-reloading
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - martech-network

  # Frontend Service (Next.js)
  frontend:
    build:
      context: ./frontend
    container_name: martech-frontend-dev
    env_file:
      - ./frontend/.env.local
    volumes:
      # Mount the source code for live reloading, excluding node_modules
      - ./frontend:/usr/src/app
      - /usr/src/app/node_modules
      - /usr/src/app/.next
    ports:
      - "3000:3000"
    # Override the production CMD for development with hot-reloading
    command: npm run dev
    depends_on:
      - backend
    networks:
      - martech-network

  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: martech-postgres-dev
    environment:
      # These values must be set in the root .env file for docker-compose to read them
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - martech-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Redis Cache & Message Broker
  redis:
    image: redis:7-alpine
    container_name: martech-redis-dev
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - martech-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
    restart: unless-stopped

# Named volumes for persistent data
volumes:
  postgres_data:
  redis_data:

# Shared network for services
networks:
  martech-network:
    driver: bridge

5. Root .env for Docker Compose
A new .env file is required in the project root for Docker Compose to configure the PostgreSQL container.
File Location: /.env (This file is gitignored)
File Content (Example):

# Variables for Docker Compose services
POSTGRES_USER=martech_user
POSTGRES_PASSWORD=secure_password
POSTGRES_DB=martechengine_dev