Phase: 3 - Core Application & Project Management
Part: 3.7
Title: Frontend User Profile UI & Hooks
Depends On: 3.6-Backend-User-Profile-Service.md
Objective: To implement the frontend for user profile management. This includes creating React Query mutation hooks for updating profiles and changing passwords, developing the corresponding UI forms with validation, and orchestrating them within an "Account Settings" page.
1. Core Principle: Optimistic UI & Clear Feedback
For a smooth user experience, we will use optimistic updates when a user changes their profile information (like their name). The UI will update instantly, assuming success, and will only revert if the API call fails. For sensitive actions like password changes, we will provide clear, explicit feedback (success or error messages) without optimistic updates.
2. User Profile TypeScript Types & Schemas
First, we define the types and validation schemas for our profile management forms.
File Location: frontend/src/types/user.ts
File Content:
import { z } from 'zod';

export const profileUpdateSchema = z.object({
  full_name: z.string().min(2, { message: "Full name must be at least 2 characters." }),
});

export const passwordChangeSchema = z.object({
  current_password: z.string().min(1, { message: "Current password is required." }),
  new_password: z.string()
    .min(8, { message: "New password must be at least 8 characters." })
    .regex(/[A-Z]/, { message: "Must contain an uppercase letter." })
    .regex(/[a-z]/, { message: "Must contain a lowercase letter." })
    .regex(/\d/, { message: "Must contain a number." })
    .regex(/[!@#$%^&*(),.?":{}|<>]/, { message: "Must contain a special character." }),
  confirm_password: z.string().min(1, { message: "Please confirm your new password." }),
}).refine(data => data.current_password !== data.new_password, {
  message: "New password must be different from the current one.",
  path: ["new_password"],
}).refine(data => data.new_password === data.confirm_password, {
  message: "Passwords do not match.",
  path: ["confirm_password"],
});

export type ProfileUpdatePayload = z.infer<typeof profileUpdateSchema>;
export type PasswordChangePayload = z.infer<typeof passwordChangeSchema>;
3. Updates to the AuthService
We extend our frontend AuthService to include methods for calling the new user profile endpoints.
File to Modify: frontend/src/services/auth.service.ts
Code to Append:
// ... (existing AuthService content) ...
import { User } from '@/types/auth';
import { ProfileUpdatePayload, PasswordChangePayload } from '@/types/user';

// ... (inside the AuthService class) ...

  /**
   * Updates the current user's profile.
   */
  static async updateProfile(payload: ProfileUpdatePayload): Promise<User> {
    const response = await apiClient.put<ApiSuccessResponse<User>>('/users/me', payload);
    return response.data.data;
  }

  /**
   * Changes the current user's password.
   */
  static async changePassword(payload: PasswordChangePayload): Promise<void> {
    await apiClient.put('/users/me/password', payload);
  }

4. Custom Hooks for Profile Management
We create new mutation hooks for profile updates and password changes, encapsulating all the logic for API calls, caching, and notifications.
File Location: frontend/src/hooks/useProfile.ts
File Content:
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'react-hot-toast';

import { AuthService } from '@/services/auth.service';
import { User } from '@/types/auth';
import { ProfileUpdatePayload, PasswordChangePayload } from '@/types/user';
import { authKeys } from './useAuth'; // Import keys from our auth hook

export const useUpdateProfile = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: ProfileUpdatePayload) => AuthService.updateProfile(payload),
    // Optimistically update the user's name for a smooth UX
    onMutate: async (newProfileData) => {
      await queryClient.cancelQueries({ queryKey: authKeys.currentUser() });
      const previousUserData = queryClient.getQueryData<User>(authKeys.currentUser());
      if (previousUserData) {
        queryClient.setQueryData<User>(authKeys.currentUser(), { ...previousUserData, ...newProfileData });
      }
      return { previousUserData };
    },
    onError: (err, variables, context) => {
      // If the mutation fails, roll back to the previous data
      if (context?.previousUserData) {
        queryClient.setQueryData(authKeys.currentUser(), context.previousUserData);
      }
      toast.error(err instanceof Error ? err.message : 'Failed to update profile.');
    },
    onSettled: () => {
      // Always refetch the user data to ensure consistency
      queryClient.invalidateQueries({ queryKey: authKeys.currentUser() });
    },
    onSuccess: () => {
      toast.success("Profile updated successfully!");
    },
  });
};

export const useChangePassword = () => {
  return useMutation({
    mutationFn: (payload: PasswordChangePayload) => AuthService.changePassword(payload),
    onSuccess: () => {
      toast.success("Password changed successfully!");
    },
    onError: (error: Error) => {
      toast.error(error.message);
    },
  });
};
5. Account Settings Page and UI Components
Finally, we build the user interface.
File Location: frontend/src/app/(dashboard)/account/page.tsx
File Content:

"use client";

import { useCurrentUser } from '@/hooks/useAuth';
import { useUpdateProfile, useChangePassword } from '@/hooks/useProfile';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { useEffect } from 'react';
import { Loader2 } from 'lucide-react';

import { profileUpdateSchema, ProfileUpdatePayload, passwordChangeSchema, PasswordChangePayload } from '@/types/user';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Skeleton } from '@/components/ui/skeleton';
import { User } from '@/types/auth';

export default function AccountSettingsPage() {
  const { data: user, isLoading: isUserLoading } = useCurrentUser();

  if (isUserLoading) {
    return <AccountPageSkeleton />;
  }

  return (
    <div className="space-y-8 max-w-4xl mx-auto">
      <div>
        <h1 className="text-3xl font-bold tracking-tight">Account Settings</h1>
        <p className="text-muted-foreground">Manage your profile, password, and preferences.</p>
      </div>
      
      <div className="grid gap-8 md:grid-cols-2">
        <ProfileUpdateForm user={user} />
        <PasswordChangeForm />
      </div>
    </div>
  );
}

function ProfileUpdateForm({ user }: { user: User | undefined }) {
  const { mutate: updateProfile, isPending: isLoading } = useUpdateProfile();
  
  const form = useForm<ProfileUpdatePayload>({
    resolver: zodResolver(profileUpdateSchema),
    defaultValues: { full_name: user?.full_name || '' },
  });

  useEffect(() => {
    if (user) {
      form.reset({ full_name: user.full_name });
    }
  }, [user, form]);

  const onSubmit = (data: ProfileUpdatePayload) => updateProfile(data);
  
  return (
    <Card>
      <CardHeader><CardTitle>Profile</CardTitle><CardDescription>Update your personal details.</CardDescription></CardHeader>
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)}>
          <CardContent className="space-y-4">
            <FormItem><FormLabel>Email</FormLabel><Input disabled value={user?.email || ''} /></FormItem>
            <FormField control={form.control} name="full_name" render={({ field }) => (
              <FormItem><FormLabel>Full Name</FormLabel><FormControl><Input {...field} /></FormControl><FormMessage /></FormItem>
            )}/>
          </CardContent>
          <CardFooter>
            <Button type="submit" disabled={isLoading}>{isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}Save Changes</Button>
          </CardFooter>
        </form>
      </Form>
    </Card>
  );
}

function PasswordChangeForm() {
  const { mutate: changePassword, isPending: isLoading } = useChangePassword();
  
  const form = useForm<PasswordChangePayload>({
    resolver: zodResolver(passwordChangeSchema),
    defaultValues: { current_password: '', new_password: '' },
  });

  const onSubmit = (data: PasswordChangePayload) => {
    changePassword(data, { onSuccess: () => form.reset() });
  };
  
  return (
    <Card>
      <CardHeader><CardTitle>Change Password</CardTitle><CardDescription>Choose a strong new password.</CardDescription></CardHeader>
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)}>
          <CardContent className="space-y-4">
            <FormField control={form.control} name="current_password" render={({ field }) => (
              <FormItem><FormLabel>Current Password</FormLabel><FormControl><Input type="password" {...field} /></FormControl><FormMessage /></FormItem>
            )}/>
            <FormField control={form.control} name="new_password" render={({ field }) => (
              <FormItem><FormLabel>New Password</FormLabel><FormControl><Input type="password" {...field} /></FormControl><FormMessage /></FormItem>
            )}/>
          </CardContent>
          <CardFooter>
            <Button type="submit" disabled={isLoading}>{isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}Update Password</Button>
          </CardFooter>
        </form>
      </Form>
    </Card>
  );
}

const AccountPageSkeleton = () => (
  <div className="space-y-8 max-w-4xl mx-auto">
    <div><Skeleton className="h-10 w-64" /><Skeleton className="h-4 w-96 mt-2" /></div>
    <div className="grid gap-8 md:grid-cols-2"><Skeleton className="h-72 rounded-lg" /><Skeleton className="h-72 rounded-lg" /></div>
  </div>
);

6. Conclusion of Phase 3
This file concludes Phase 3. We have now built the complete, end-to-end functionality for a user to sign up, log in, create and manage projects, and update their own profile. This represents a solid Minimum Viable Product (MVP) of the core application framework.
Next File: 4.1-Data-Models-Billing-and-Credits.md will begin the critical Phase 4 (Monetization) by defining the database models required to handle plans, subscriptions, and financial transactions.
