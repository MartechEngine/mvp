Phase: 2 - User Identity & Authentication
Part: 2.6.3
Title: Backend Authentication Dependencies
Depends On: 2.6-Backend-Auth-and-User-API.md, 2.3-Backend-Security-JWT-Service.md
Objective: To implement the authentication dependency functions that provide secure user context extraction from JWT tokens for FastAPI endpoints.

## 1. Core Principles

**Token Validation**: Extract and validate JWT tokens from request headers.
**User Context**: Provide authenticated user objects to protected endpoints.
**Role-Based Access**: Support different authentication levels (active, verified, admin).
**Session Tracking**: Integrate with session management for security.

## 2. Authentication Dependencies Implementation

**File Location:** `backend/app/api/v1/dependencies/auth_deps.py`

**File Content:**
```python
import logging
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from typing import Optional
from jose import JWTError

from app.core.database import get_db
from app.core.security import decode_token
from app.core.exceptions import InvalidCredentialsError, PermissionDeniedError
from app.models.user import User
from app.models.user_session import UserSession, SessionStatus
from app.services.user_session_service import UserSessionService

logger = logging.getLogger(__name__)

# Security scheme for extracting Bearer tokens
security = HTTPBearer()

def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """
    Extract and validate the current user from JWT token.
    
    Args:
        credentials: Bearer token from Authorization header
        db: Database session
        
    Returns:
        User: The authenticated user object
        
    Raises:
        HTTPException: If token is invalid or user not found
    """
    try:
        # Decode the JWT token
        token_data = decode_token(credentials.credentials)
        if not token_data:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication token",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # Extract user ID from token
        user_id = token_data.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token payload",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # Get user from database
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # Optional: Validate session if session_id is in token
        session_id = token_data.get("session_id")
        if session_id:
            session_service = UserSessionService(db)
            sessions = session_service.get_user_sessions(str(user.id), active_only=True)
            
            # Check if the session is still valid
            valid_session = any(s.session_id == session_id for s in sessions)
            if not valid_session:
                logger.warning(f"Invalid session {session_id} for user {user.id}")
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Session expired or invalid",
                    headers={"WWW-Authenticate": "Bearer"},
                )
        
        return user
        
    except JWTError as e:
        logger.warning(f"JWT decode error: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication token",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except Exception as e:
        logger.error(f"Authentication error: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication failed",
            headers={"WWW-Authenticate": "Bearer"},
        )

def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """
    Ensure the current user is active.
    
    Args:
        current_user: User from get_current_user dependency
        
    Returns:
        User: The active user object
        
    Raises:
        HTTPException: If user is not active
    """
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is disabled"
        )
    return current_user

def get_current_verified_user(
    current_user: User = Depends(get_current_active_user)
) -> User:
    """
    Ensure the current user is verified (email confirmed).
    
    Args:
        current_user: User from get_current_active_user dependency
        
    Returns:
        User: The verified user object
        
    Raises:
        HTTPException: If user is not verified
    """
    if not current_user.is_verified:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Email verification required"
        )
    return current_user

def get_optional_current_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),
    db: Session = Depends(get_db)
) -> Optional[User]:
    """
    Extract current user from token if present, but don't require authentication.
    
    Args:
        credentials: Optional Bearer token from Authorization header
        db: Database session
        
    Returns:
        Optional[User]: The authenticated user object or None
    """
    if not credentials:
        return None
    
    try:
        return get_current_user(credentials, db)
    except HTTPException:
        # Silently ignore authentication errors for optional auth
        return None

def require_admin_user(
    current_user: User = Depends(get_current_verified_user)
) -> User:
    """
    Ensure the current user has admin privileges.
    
    Args:
        current_user: User from get_current_verified_user dependency
        
    Returns:
        User: The admin user object
        
    Raises:
        HTTPException: If user is not an admin
    """
    # Check if user has admin role (assuming is_admin field exists)
    if not getattr(current_user, 'is_admin', False):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin privileges required"
        )
    return current_user

def extract_session_id_from_token(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> Optional[str]:
    """
    Extract session ID from JWT token for logout operations.
    
    Args:
        credentials: Bearer token from Authorization header
        
    Returns:
        Optional[str]: Session ID if present in token
    """
    try:
        token_data = decode_token(credentials.credentials)
        if token_data:
            return token_data.get("session_id")
    except Exception:
        pass
    return None
```

## 3. Usage Examples

### Protected Endpoint
```python
@router.get("/profile")
def get_user_profile(
    current_user: User = Depends(get_current_verified_user)
):
    return {"user": current_user}
```

### Admin-Only Endpoint
```python
@router.delete("/users/{user_id}")
def delete_user(
    user_id: str,
    admin_user: User = Depends(require_admin_user)
):
    # Admin-only operation
    pass
```

### Optional Authentication
```python
@router.get("/public-data")
def get_public_data(
    current_user: Optional[User] = Depends(get_optional_current_user)
):
    # Behavior changes based on authentication status
    if current_user:
        return {"data": "personalized_content"}
    return {"data": "public_content"}
```

## 4. Security Features

**Token Validation**: Comprehensive JWT token validation with proper error handling.
**Session Verification**: Optional session validation for enhanced security.
**Role-Based Access**: Multiple authentication levels for different endpoint requirements.
**Graceful Degradation**: Optional authentication support for mixed public/private endpoints.
**Error Handling**: Consistent HTTP status codes and error messages.

## 5. Next Steps

With authentication dependencies implemented, the auth system now provides secure user context extraction for all protected endpoints.

**Next File:** The authentication system is now complete and ready for integration with the rest of the application.
