Phase: 1 - Foundation & Core Infrastructure
Part: 1.6
Title: Frontend Setup & React Query Configuration
Depends On: 1.5-Frontend-Architecture-Overview.md
Objective: To establish a production-ready configuration for @tanstack/react-query in our Next.js frontend. This setup includes a shared QueryClient instance, proper Server-Side Rendering (SSR) hydration, and conditionally-rendered development tools.
1. Dependency Installation
First, we need to install the necessary libraries for React Query.
Installation Command (run in the frontend directory):
npm install @tanstack/react-query @tanstack/react-query-devtools @tanstack/react-query-next-experimental react-hot-toast
2. Query Client Configuration
We will create a singleton instance of the QueryClient to be used across the application. This ensures consistency in caching and global configuration.
File Location: frontend/src/lib/react-query/client.ts (New File)
File Content:
import { QueryClient } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Set a default stale time for all queries to 5 minutes.
      // This means data will be considered fresh for 5 minutes before a background refetch is triggered.
      staleTime: 1000 * 60 * 5,
      // Only refetch data on window focus in production for a smoother user experience.
      refetchOnWindowFocus: process.env.NODE_ENV === 'production', 
    },
  },
});

export default queryClient;
3. React Query Provider with SSR Hydration
To support the Next.js App Router, we need a provider component that can handle state dehydration on the server and rehydration on the client. This prevents fetching data on the client that was already fetched during the server render.
File Location: frontend/src/app/providers.tsx (New File)
File Content:

'use client';

import { QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental';
import React from 'react';

import queryClient from '@/lib/react-query/client';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryStreamedHydration>
        {children}
      </ReactQueryStreamedHydration>
      {/* Devtools are only rendered in non-production environments for debugging */}
      {process.env.NODE_ENV !== 'production' && <ReactQueryDevtools initialIsOpen={false} />}
    </QueryClientProvider>
  );
}
4. Integrating the Provider into the Root Layout
Finally, we wrap our root layout with the Providers component to make the query client available to all components in the application.
File Location: frontend/src/app/layout.tsx (Modification)
File Content:
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import { Providers } from './providers'; // Import the new provider
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'MartechEngine',
  description: 'AI-Powered Marketing Intelligence',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        {/* Wrap the children with the Providers component */}
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
5. Key Design Decisions & Justifications
Singleton Client: Using a single QueryClient instance is crucial for @tanstack/react-query to function as a centralized data cache.
SSR Hydration: Using ReactQueryStreamedHydration is the modern, recommended approach for handling SSR in the Next.js App Router, ensuring optimal performance and preventing data re-fetching on page load.
Conditional Devtools: The ReactQueryDevtools are an invaluable debugging tool but should never be included in a production bundle. Checking process.env.NODE_ENV is the standard way to prevent this, minimizing bundle size and potential security risks.
This setup provides a complete, robust, and production-ready foundation for all data-fetching operations on the frontend.
