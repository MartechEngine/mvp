Phase: 3 - Core Application & Project Management
Part: 3.2
Title: Backend Project API Endpoints
Depends On: 3.1-Backend-Project-Service.md
Objective: To implement the FastAPI router and RESTful API endpoints for project management. This includes creating secure endpoints for all CRUD (Create, Read, Update, Delete) operations, using Pydantic schemas for request/response validation, and integrating the ProjectService to handle the business logic.
1. Core Principle: Thin & Declarative API Layer
The API endpoints will remain simple and declarative. They use FastAPI's powerful features to handle the heavy lifting, while delegating all business logic to the ProjectService.
Dependency Injection: Depends(get_db) provides a database session, and a new get_current_active_user dependency will secure the endpoints and provide the user context.
Request & Response Modeling: Pydantic schemas will automatically validate incoming data and serialize outgoing data.
Error Handling: The endpoints will catch the ValueError raised by the service for plan limit violations and convert it into a user-friendly HTTP 402 Payment Required response.
2. Project Pydantic Schemas
First, we need to define the Pydantic schemas that our API endpoints will use for request bodies and response models.
File Location: backend/app/schemas/project_schemas.py
File Content:

from pydantic import BaseModel, Field, HttpUrl, ConfigDict
from typing import Optional
from uuid import UUID
from datetime import datetime

from app.models.project import ProjectStatus

# --- Request Schemas ---

class ProjectCreate(BaseModel):
    """Schema for creating a new project. Sent in the request body."""
    name: str = Field(..., min_length=3, max_length=100)
    url: HttpUrl # Pydantic will validate this is a valid URL format

class ProjectUpdate(BaseModel):
    """Schema for updating an existing project. All fields are optional."""
    name: Optional[str] = Field(None, min_length=3, max_length=100)
    url: Optional[HttpUrl] = None
    status: Optional[ProjectStatus] = None

# --- Response Schemas ---

class Project(BaseModel):
    """The core schema for representing a project in API responses."""
    id: UUID
    name: str
    url: HttpUrl
    status: ProjectStatus
    owner_id: UUID
    organization_id: UUID
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)

    3. Project API Endpoints
This file contains the complete router for our project management endpoints.
File Location: backend/app/api/v1/endpoints/projects.py
File Content:
```python
import logging
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Any
from uuid import UUID

from app.core.database import get_db
from app.services.project_service import ProjectService
from app.api.v1.dependencies.auth_deps import get_current_active_user
from app.schemas.project_schemas import ProjectCreate, ProjectUpdate, Project as ProjectSchema
from app.schemas.user_schemas import User
from app.schemas.common_schemas import APISuccessResponse, PaginatedResponse
from app.models.user import User as UserModel
from app.services.credit_service import CreditService

logger = logging.getLogger(__name__)
router = APIRouter()
@router.post(
"/",
response_model=APISuccessResponse[ProjectSchema],
status_code=status.HTTP_201_CREATED,
summary="Create a new project"
)
def create_project(
project_in: ProjectCreate,
db: Session = Depends(get_db),
current_user: UserModel = Depends(get_current_active_user)
) -> Any:
"""
Creates a new project for the authenticated user's organization.
- Enforces subscription plan limits via the ProjectService.
"""
project_service = ProjectService(db)
try:
new_project = project_service.create_project(project_create=project_in, user=current_user)
return APISuccessResponse(data=new_project, message="Project created successfully.")
except ValueError as e:
# This error is raised by the service if the user is over their project limit.
raise HTTPException(
status_code=status.HTTP_402_PAYMENT_REQUIRED,
detail=str(e),
)
@router.get(
"/",
response_model=APISuccessResponse[List[ProjectSchema]],
summary="List user's projects"
)
def list_projects(
db: Session = Depends(get_db),
current_user: UserModel = Depends(get_current_active_user)
) -> Any:
"""
Retrieves a list of all projects associated with the authenticated user's organization.
"""
project_service = ProjectService(db)
projects = project_service.get_projects_for_user(user=current_user)
return APISuccessResponse(data=projects)
@router.get(
"/{project_id}",
response_model=APISuccessResponse[ProjectSchema],
summary="Get a specific project"
)
def get_project(
project_id: UUID,
db: Session = Depends(get_db),
current_user: UserModel = Depends(get_current_active_user)
) -> Any:
"""
Retrieves a single project by its ID, ensuring it belongs to the current user's organization.
"""
project_service = ProjectService(db)
project = project_service.get_project_by_id(project_id=project_id, user=current_user)
if not project:
raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Project not found")
return APISuccessResponse(data=project)
@router.put(
"/{project_id}",
response_model=APISuccessResponse[ProjectSchema],
summary="Update a project"
)
def update_project(
project_id: UUID,
project_in: ProjectUpdate,
db: Session = Depends(get_db),
current_user: UserModel = Depends(get_current_active_user)
) -> Any:
"""
Updates a project's details, ensuring it belongs to the current user's organization.
"""
project_service = ProjectService(db)
updated_project = project_service.update_project(
project_id=project_id, project_update=project_in, user=current_user
)
if not updated_project:
raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Project not found")
return APISuccessResponse(data=updated_project, message="Project updated successfully.")
@router.delete(
"/{project_id}",
status_code=status.HTTP_204_NO_CONTENT,
summary="Delete a project"
)
def delete_project(
project_id: UUID,
db: Session = Depends(get_db),
current_user: UserModel = Depends(get_current_active_user)
):
"""
Deletes a project (soft delete), ensuring it belongs to the current user's organization.
"""
project_service = ProjectService(db)
success = project_service.delete_project(project_id=project_id, user=current_user)
if not success:
raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Project not found")
return


### **4. Next Steps**

With the backend API for projects fully implemented, we have a complete loop for project management. The next step is to cross over to the frontend and build the client-side infrastructure to interact with these new endpoints.

*   **Next File:** `3.3-Frontend-Custom-Hooks-Pattern.md` will establish the architectural pattern for how we create all our React Query custom hooks, which is the final piece of our frontend's core data-fetching architecture.
