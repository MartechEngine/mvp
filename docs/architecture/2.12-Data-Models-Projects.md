Phase: 3 - Core Application & Project Management
Part: 3.1
Title: Data Models - Projects & Memberships
Depends On: 2.11-Frontend-Route-Protection.md
Objective: To define the core SQLAlchemy data models for Project and the ProjectMembership association table. This structure links projects to the multi-tenancy system, ensuring that all project data is properly scoped to an organization and its users.
1. Core Principle: Projects Belong to Organizations
In our multi-tenant architecture, the Organization is the primary owner of all resources. A Project is a resource that belongs to an Organization. Users gain access to a project through their membership in the organization. For the MVP, we will keep this simple, but this structure allows for more complex role-based access control (RBAC) in the future.
2. Project Data Model
This model represents a user's workspace or a domain they are analyzing.
File Location: backend/app/models/project.py
File Content:
import enum
from sqlalchemy import Column, String, ForeignKey, Enum
from sqlalchemy.orm import relationship

from app.models.base import Base, BaseMixin

class ProjectStatus(str, enum.Enum):
    """Enumeration for the status of a project."""
    ACTIVE = "ACTIVE"
    ARCHIVED = "ARCHIVED"
    PENDING_DELETION = "PENDING_DELETION"

class Project(Base, BaseMixin):
    __tablename__ = 'projects'

    name = Column(String, nullable=False)
    url = Column(String(2048), nullable=False)
    status = Column(Enum(ProjectStatus), nullable=False, default=ProjectStatus.ACTIVE)

    owner_id = Column(ForeignKey('users.id'), nullable=False)
    organization_id = Column(ForeignKey('organizations.id'), nullable=False)

    # Establish the many-to-one relationship from Project -> Organization
    organization = relationship('Organization', back_populates='projects')
    owner = relationship('User')

# To complete the bidirectional relationship, we must add the 'projects' back-reference
# to the Organization model.

**File to Modify:** `backend/app/models/organization.py`
**Content to Add:**
```python
# In backend/app/models/organization.py

# ... (existing imports and class definition) ...
class Organization(Base, BaseMixin):
    # ... (existing columns) ...

    # Add the one-to-many relationship from Organization -> Project
    projects = relationship(
        'Project',
        back_populates='organization',
        cascade='all, delete-orphan'
    )
    
3. Shared Role Enums Module (Avoiding Circular Imports)
To avoid circular import issues between models, we'll create a shared enums module.

**File Location:** `backend/app/models/enums.py`
**File Content:**
```python
import enum

class MemberRole(str, enum.Enum):
    """Enumeration for member roles in organizations and projects."""
    OWNER = "OWNER"
    ADMIN = "ADMIN"
    MEMBER = "MEMBER"
```

4. ProjectMembership Data Model (Future-Ready)
For the MVP, project access is implicitly granted to all members of an organization. However, to prepare for future role-based access control at the project level, we will define the ProjectMembership model now. This table will link a User directly to a Project with a specific role.

**File Location:** `backend/app/models/project_membership.py`
**File Content:**
```python
from sqlalchemy import Column, Enum, ForeignKey
from sqlalchemy.orm import relationship
from app.models.base import Base, BaseMixin
from app.models.enums import MemberRole  # Import from shared enums module

class ProjectMembership(Base, BaseMixin):
    __tablename__ = 'project_memberships'
    
    user_id = Column(ForeignKey('users.id'), primary_key=True)
    project_id = Column(ForeignKey('projects.id'), primary_key=True)
    
    # Using shared MemberRole enum for consistency across organization and project roles
    role = Column(Enum(MemberRole), nullable=False, default=MemberRole.MEMBER)
    
    user = relationship('User')
    project = relationship('Project')
```

**Note:** The existing `backend/app/models/membership.py` should also be updated to import `MemberRole` from `app.models.enums` instead of defining it locally, ensuring consistency across the codebase.


### **4. Alembic Migration**

After creating and updating these model files, we must generate a new database migration to apply the schema changes.

**Execution Command** (run in the `backend` directory):
```bash
alembic revision --autogenerate -m "Create project and project_membership models"
alembic upgrade head
5. Next Steps
With the database schema for projects now defined and linked to our tenancy model, we can proceed to build the business logic that will manage them.
Next File: 3.1-Backend-Project-Service.md will implement the ProjectService, which will handle all business logic for creating, retrieving, updating, and deleting projects, including enforcing plan-based limits.
