Phase: 2 - User Identity & Authentication
Part: 2.5
Title: Backend Authentication Service
Depends On: 2.4-Backend-Common-Schemas.md
Objective: To implement the AuthService, the central class for all authentication-related business logic. This service will handle user registration, including the atomic creation of a user and their initial organization, secure password verification, and the groundwork for token management.

## 1. Core Principle: Transactional Integrity

A new user registration is a multi-step database operation: creating a User, an Organization, and a Membership record. These operations must be atomic. If any step fails, all previous steps must be rolled back to prevent orphaned data (e.g., an organization with no owner). The service will ensure this by managing the database session and committing only once at the end of a successful workflow.

## 2. Custom Business Logic Exceptions

To provide clear error feedback to the API layer, we will define custom exceptions that represent specific business rule failures.

**File Location:** `backend/app/core/exceptions.py`

**File Content:**
```python
class AppError(Exception):
    """Base class for application-specific errors."""
    pass

class EmailAlreadyExistsError(AppError):
    """Raised when a user tries to register with an email that already exists."""
    pass

class InvalidCredentialsError(AppError):
    """Raised when a login attempt fails due to incorrect email or password."""
    pass

class InsufficientCreditsError(AppError):
    """Raised when an operation requires more credits than available."""
    pass

class ValidationError(AppError):
    """Raised when input validation fails."""
    pass

class NotFoundError(AppError):
    """Raised when a requested resource is not found."""
    pass

class PermissionDeniedError(AppError):
    """Raised when a user lacks permission for an operation."""
    pass
```

## 3. AuthService Implementation

This service encapsulates all the logic for registering and authenticating users.

**File Location:** `backend/app/services/auth_service.py`

**File Content:**
```python
import logging
from datetime import datetime
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError

from app.core.security import get_password_hash, verify_password
from app.core.exceptions import EmailAlreadyExistsError, InvalidCredentialsError, NotFoundError, ValidationError
from app.models.user import User
from app.models.organization import Organization
from app.models.membership import Membership, MemberRole
from app.schemas.auth_schemas import UserLogin
from app.schemas.user_schemas import UserCreate

logger = logging.getLogger(__name__)

class AuthService:
    """
    Service layer for all authentication-related business logic.
    
    This service handles the complete user authentication lifecycle including:
    - User registration with atomic organization creation
    - Secure password verification and authentication
    - Email verification workflow management
    - Password reset functionality
    - Organization and membership management
    
    All operations maintain transactional integrity and provide comprehensive
    error handling with business-specific exceptions.
    
    Attributes:
        db (Session): SQLAlchemy database session for all operations
    """

    def __init__(self, db: Session):
        """
        Initialize the AuthService with a database session.
        
        Args:
            db (Session): SQLAlchemy database session that will be used
                         for all database operations within this service
        """
        self.db = db

    def register_user(self, user_create: UserCreate) -> User:
        """
        Registers a new user and their initial organization in a single atomic transaction.
        
        This method implements the complete user onboarding workflow:
        1. Creates a new User record with hashed password
        2. Creates an Organization owned by the new user
        3. Establishes a Membership linking user to organization as OWNER
        4. Commits all changes atomically or rolls back on any failure
        
        The transaction ensures data consistency - if any step fails, all
        previous operations are automatically rolled back to prevent orphaned
        records or inconsistent state.
        
        Args:
            user_create (UserCreate): Pydantic schema containing:
                - email: User's email address (will be normalized to lowercase)
                - password: Plain text password (will be hashed securely)
                - full_name: User's display name
                - organization_name: Name for the user's initial organization
            
        Returns:
            User: The newly created and persisted user object with all
                  relationships established and committed to the database
            
        Raises:
            EmailAlreadyExistsError: If the email address is already registered
                                   in the system (enforced by unique constraint)
            ValidationError: If any input data fails validation requirements
            Exception: For any other database errors during the transaction
                      (connection issues, constraint violations, etc.)
        
        Example:
            >>> auth_service = AuthService(db)
            >>> user_data = UserCreate(
            ...     email="john@example.com",
            ...     password="secure_password123",
            ...     full_name="John Doe",
            ...     organization_name="Acme Corp"
            ... )
            >>> new_user = auth_service.register_user(user_data)
            >>> print(f"Created user: {new_user.email}")
        """
        try:
            # Step 1: Create the User record with secure password hashing
            # Note: Email is normalized to lowercase for consistent lookups
            hashed_password = get_password_hash(user_create.password)
            new_user = User(
                email=user_create.email.lower(),  # Normalize email for consistency
                hashed_password=hashed_password,   # Store securely hashed password
                full_name=user_create.full_name,
                is_verified=False,  # Users must verify email before full access
            )
            self.db.add(new_user)
            # Flush to assign database ID for foreign key relationships
            self.db.flush()

            # Step 2: Create the Organization with the new user as owner
            # Every user gets their own organization for multi-tenant isolation
            new_org = Organization(
                name=user_create.organization_name,
                owner_id=new_user.id  # Foreign key to the user created above
            )
            self.db.add(new_org)
            # Flush to assign organization ID for membership relationship
            self.db.flush()

            # Step 3: Create the Membership record linking user to organization
            # This establishes the user as OWNER of their organization
            membership = Membership(
                user_id=new_user.id,
                organization_id=new_org.id,
                role=MemberRole.OWNER  # Full administrative privileges
            )
            self.db.add(membership)
            
            # Step 4: Commit the entire transaction atomically
            # If this succeeds, all three records are persisted together
            # If this fails, all changes are automatically rolled back
            self.db.commit()
            
            # Refresh the user object to get updated relationships
            self.db.refresh(new_user)
            
            # Log successful registration for monitoring and debugging
            logger.info(
                f"Successfully registered user {new_user.email} "
                f"with organization '{new_org.name}' (ID: {new_org.id})"
            )
            
            # TODO: Dispatch async task to send verification email
            # This will be implemented in the email service integration
            
            return new_user

        except IntegrityError:
            self.db.rollback()
            logger.warning(f"Registration failed for email {user_create.email}: email already exists.")
            raise EmailAlreadyExistsError("A user with this email address already exists.")
        except Exception as e:
            self.db.rollback()
            logger.error(f"An unexpected error occurred during user registration: {e}", exc_info=True)
            raise

    def authenticate_user(self, user_login: UserLogin) -> User:
        """
        Authenticates a user by checking their email and password.
        
        Args:
            user_login (UserLogin): The Pydantic schema with login credentials.
            
        Returns:
            User: The authenticated user object.
            
        Raises:
            InvalidCredentialsError: If the email does not exist or the password is incorrect.
        """
        user = self.db.query(User).filter(User.email == user_login.email.lower()).first()

        if not user or not verify_password(user_login.password, user.hashed_password):
            logger.warning(f"Failed login attempt for email: {user_login.email}")
            raise InvalidCredentialsError("Incorrect email or password.")
            
        # TODO: Add a check here for `user.is_verified` once the email flow is complete.
        
        # TODO: In a later step, update a `last_login_at` timestamp.
        
        logger.info(f"User {user.email} authenticated successfully.")
        return user
    
    def resend_verification_email(self, email: str) -> bool:
        """
        Resend verification email to a user.
        
        Args:
            email: User's email address
            
        Returns:
            bool: True if email was sent successfully
            
        Raises:
            NotFoundError: If user with email doesn't exist
            ValidationError: If user is already verified
        """
        from app.services.email_service import EmailService
        from app.models.email_verification import EmailVerificationToken
        
        # Find user by email
        user = self.db.query(User).filter(User.email == email.lower()).first()
        if not user:
            logger.warning(f"Resend verification attempted for non-existent email: {email}")
            raise NotFoundError("User with this email address does not exist.")
        
        # Check if user is already verified
        if user.is_verified:
            logger.info(f"Resend verification attempted for already verified user: {email}")
            raise ValidationError("This email address is already verified.")
        
        try:
            # Invalidate any existing verification tokens for this user
            existing_tokens = self.db.query(EmailVerificationToken).filter(
                EmailVerificationToken.user_id == user.id,
                EmailVerificationToken.is_used == False
            ).all()
            
            for token in existing_tokens:
                token.is_used = True
            
            # Generate new verification token
            verification_token = EmailVerificationToken.generate_token(
                user_id=str(user.id),
                email=user.email
            )
            
            self.db.add(verification_token)
            self.db.commit()
            
            # Send verification email
            email_service = EmailService()
            success = email_service.send_verification_email(
                user=user,
                verification_token=verification_token.token_plain
            )
            
            if success:
                # Update reminder sent timestamp
                user.verification_reminder_sent_at = datetime.utcnow()
                self.db.commit()
                logger.info(f"Verification email resent successfully to: {email}")
                return True
            else:
                logger.error(f"Failed to resend verification email to: {email}")
                return False
                
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error resending verification email to {email}: {str(e)}")
            raise

## 4. Next Steps

With the core business logic for authentication now implemented, we are ready to expose this functionality to the outside world through a secure API.

**Next File:** `2.6-Backend-Auth-and-User-API.md` will create the FastAPI router and endpoints that will use this AuthService to handle HTTP requests for registration and login.
