Phase: 2 - User Identity & Authentication
Part: 2.7
Title: Frontend API Service Layer & Error Handling
Depends On: 2.6-Backend-Auth-and-User-API.md
Objective: To create a robust, centralized API client using Axios. This client will manage base URLs, set default headers, and, most importantly, use interceptors to globally handle authentication tokens and API error responses, making the rest of the application cleaner and more resilient.
1. Core Principle: Centralized API Logic
All HTTP requests to our backend will be made through a single, configured Axios instance. This is a critical pattern that allows us to:
Stay DRY (Don't Repeat Yourself): Avoid setting the base URL or content type headers in every single API call.
Handle Authentication Transparently: Automatically attach the JWT access token to the headers of every outgoing request.
Standardize Error Handling: Intercept all API error responses in one place. Instead of generic network errors, we can extract the specific error message from the backend's JSON response (e.g., "Email already exists") and propagate it through our application.
2. Dependency Installation
This service requires the Axios library.
Installation Command (run in the frontend directory):
npm install axios
3. Centralized apiClient Implementation
This file contains the configured Axios instance that will be used by all other services in the frontend.
File Location: frontend/src/lib/api/client.ts
File Content:
import axios, { AxiosError, InternalAxiosRequestConfig, AxiosResponse } from 'axios';
import { getAuthToken, getRefreshToken, setAuthTokens, clearAuthTokens } from '@/lib/utils/auth-storage'; // We will create this in the next file
import { ApiErrorResponse, ApiSuccessResponse } from '@/types/api';
import { TokenResponse } from '@/types/auth';

const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Track if we're currently refreshing to prevent multiple refresh attempts
let isRefreshing = false;
let failedQueue: Array<{
  resolve: (value?: any) => void;
  reject: (error?: any) => void;
}> = [];

// Process the queue of failed requests after token refresh
const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(({ resolve, reject }) => {
    if (error) {
      reject(error);
    } else {
      resolve(token);
    }
  });
  
  failedQueue = [];
};

// --- Request Interceptor ---
// This function will be called before every request is sent.
apiClient.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    // Retrieve the auth token from storage.
    const token = getAuthToken();
    if (token) {
      // If the token exists, add it to the Authorization header.
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    // Add device information headers for session tracking
    config.headers['X-Device-ID'] = localStorage.getItem('device_id') || generateDeviceId();
    config.headers['X-Device-Name'] = getDeviceName();
    config.headers['X-Device-Type'] = getDeviceType();
    
    return config;
  },
  (error) => {
    // Handle request errors (e.g., network issues before sending).
    return Promise.reject(error);
  }
);

// --- Response Interceptor with Token Refresh ---
// This function will be called for every response that is received.
apiClient.interceptors.response.use(
  (response: AxiosResponse) => {
    // For successful responses (2xx), just return the response.
    return response;
  },
  async (error: AxiosError) => {
    const originalRequest = error.config as InternalAxiosRequestConfig & { _retry?: boolean };
    
    // Handle 401 Unauthorized errors with token refresh
    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        // If we're already refreshing, queue this request
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        }).then(token => {
          if (originalRequest.headers) {
            originalRequest.headers.Authorization = `Bearer ${token}`;
          }
          return apiClient(originalRequest);
        }).catch(err => {
          return Promise.reject(err);
        });
      }
      
      originalRequest._retry = true;
      isRefreshing = true;
      
      const refreshToken = getRefreshToken();
      
      if (!refreshToken) {
        // No refresh token available, redirect to login
        clearAuthTokens();
        window.location.href = '/auth/login';
        return Promise.reject(error);
      }
      
      try {
        // Attempt to refresh the token
        const response = await axios.post<ApiSuccessResponse<TokenResponse>>(
          `${process.env.NEXT_PUBLIC_API_URL}/api/v1/auth/refresh`,
          { refresh_token: refreshToken },
          {
            headers: {
              'Content-Type': 'application/json',
              'X-Device-ID': localStorage.getItem('device_id') || generateDeviceId(),
              'X-Device-Name': getDeviceName(),
              'X-Device-Type': getDeviceType(),
            }
          }
        );
        
        const { access_token, refresh_token: newRefreshToken } = response.data.data;
        
        // Store the new tokens
        setAuthTokens({ access_token, refresh_token: newRefreshToken });
        
        // Update the original request with the new token
        if (originalRequest.headers) {
          originalRequest.headers.Authorization = `Bearer ${access_token}`;
        }
        
        // Process the queue of failed requests
        processQueue(null, access_token);
        
        // Retry the original request
        return apiClient(originalRequest);
        
      } catch (refreshError) {
        // Refresh failed, clear tokens and redirect to login
        processQueue(refreshError, null);
        clearAuthTokens();
        
        // Only redirect if we're not already on the login page
        if (window.location.pathname !== '/auth/login') {
          window.location.href = '/auth/login';
        }
        
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }
    
    // For other error responses (4xx, 5xx), we process them here.
    const apiError = error.response?.data as ApiErrorResponse;

    if (apiError && apiError.error) {
      // If the backend sent a structured error message, we use that.
      // This makes our UI error messages much more specific and user-friendly.
      return Promise.reject(new Error(apiError.error.message));
    }

    // Fallback for generic network errors or non-standard error responses.
    return Promise.reject(new Error(error.message || 'An unexpected network error occurred.'));
  }
);

// --- Device Information Utilities ---
function generateDeviceId(): string {
  const deviceId = 'device_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
  localStorage.setItem('device_id', deviceId);
  return deviceId;
}

function getDeviceName(): string {
  const userAgent = navigator.userAgent;
  
  // Simple device name detection
  if (/iPhone/.test(userAgent)) return 'iPhone';
  if (/iPad/.test(userAgent)) return 'iPad';
  if (/Android/.test(userAgent)) return 'Android Device';
  if (/Mac/.test(userAgent)) return 'Mac';
  if (/Windows/.test(userAgent)) return 'Windows PC';
  if (/Linux/.test(userAgent)) return 'Linux PC';
  
  return 'Unknown Device';
}

function getDeviceType(): string {
  const userAgent = navigator.userAgent;
  
  if (/Mobile|Android|iPhone/.test(userAgent)) return 'mobile';
  if (/iPad|Tablet/.test(userAgent)) return 'tablet';
  
  return 'desktop';
}

export { apiClient };

4. Example Usage in a react-query Mutation
With the interceptor in place, our react-query hooks (which we will build later) can now display meaningful error messages without any extra logic.
// This is a conceptual example for a future file (e.g., frontend/src/hooks/useAuth.ts)

export const useRegister = () => {
  return useMutation(authService.register, {
    onSuccess: (data) => {
      // ... handle successful registration
    },
    onError: (error: Error) => {
      // 'error.message' will now contain the specific message from the backend,
      // e.g., "A user with this email address already exists."
      // We can show this directly to the user in a toast notification.
      toast.error(error.message);
    },
  });
};

5. Next Steps
This apiClient is the foundation of our frontend's communication layer. It depends on a set of utility functions for managing auth tokens in the browser.
Next File: 2.8-Frontend-Auth-Storage-Utilities.md will create the simple, secure, and synchronous utility functions (getAuthToken, setAuthTokens, etc.) for managing JWTs in the browser's cookies.