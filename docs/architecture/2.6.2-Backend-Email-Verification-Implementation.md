Phase: 2 - User Identity & Authentication
Part: 2.6.2
Title: Backend Email Verification Implementation
Depends On: 2.6.1-Backend-Email-Service.md, 2.6-Backend-Auth-and-User-API.md, 8.1.3-Backend-Sentry-Error-Tracking-Integration.md
Objective: To implement a complete email verification system that ensures user email addresses are valid and verified before granting full platform access. This includes verification token generation, secure email delivery, token validation, and proper integration with the authentication flow.

## 1. Core Principles

**Security First**: Verification tokens are cryptographically secure with expiration and single-use enforcement.
**User Experience**: Clear verification emails with branded templates and helpful instructions.
**Resilient Design**: Handles email delivery failures gracefully with retry mechanisms.
**Audit Trail**: Complete logging and tracking of verification attempts for security analysis.

## 2. Email Verification Models

### Verification Token Model
```python
# File: backend/app/models/email_verification.py
from sqlalchemy import Column, String, DateTime, Boolean, Text, Integer, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime, timedelta
import secrets
import hashlib

from app.models.base import Base, BaseMixin

class EmailVerificationToken(Base, BaseMixin):
    __tablename__ = 'email_verification_tokens'
    
    user_id = Column(ForeignKey('users.id'), nullable=False, index=True)
    email = Column(String(255), nullable=False, index=True)
    
    token_hash = Column(String(128), nullable=False, unique=True, index=True)
    token_plain = None  # Never stored, only used during generation
    
    expires_at = Column(DateTime, nullable=False, index=True)
    is_used = Column(Boolean, default=False, nullable=False)
    used_at = Column(DateTime, nullable=True)
    
    attempts_count = Column(Integer, default=0, nullable=False)
    last_attempt_at = Column(DateTime, nullable=True)
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    
    user = relationship('User', back_populates='verification_tokens')
    
    @classmethod
    def generate_token(cls, user_id: str, email: str, expires_in_hours: int = 24) -> 'EmailVerificationToken':
        """Generate a new verification token."""
        token_plain = secrets.token_urlsafe(32)
        token_hash = hashlib.sha256(token_plain.encode()).hexdigest()
        
        token_record = cls(
            user_id=user_id,
            email=email.lower(),
            token_hash=token_hash,
            expires_at=datetime.utcnow() + timedelta(hours=expires_in_hours)
        )
        
        token_record.token_plain = token_plain
        return token_record
    
    def verify_token(self, token_plain: str) -> bool:
        """Verify if the provided token matches this record."""
        if self.is_used or datetime.utcnow() > self.expires_at:
            return False
        
        provided_hash = hashlib.sha256(token_plain.encode()).hexdigest()
        return secrets.compare_digest(self.token_hash, provided_hash)
    
    def mark_as_used(self, ip_address: str = None, user_agent: str = None):
        """Mark token as used."""
        self.is_used = True
        self.used_at = datetime.utcnow()
        if ip_address:
            self.ip_address = ip_address
        if user_agent:
            self.user_agent = user_agent
    
    @property
    def is_valid(self) -> bool:
        """Check if token is valid (not used and not expired)."""
        return not self.is_used and datetime.utcnow() <= self.expires_at
```

### User Model Updates
```python
# File: backend/app/models/user.py (additions)
from sqlalchemy.orm import relationship

class User(Base, BaseMixin):
    # ... existing fields ...
    
    is_verified = Column(Boolean, default=False, nullable=False)
    email_verified_at = Column(DateTime, nullable=True)
    verification_reminder_sent_at = Column(DateTime, nullable=True)
    
    verification_tokens = relationship('EmailVerificationToken', back_populates='user', cascade='all, delete-orphan')
    
    def mark_email_verified(self):
        """Mark user email as verified."""
        self.is_verified = True
        self.email_verified_at = datetime.utcnow()
    
    def needs_verification_reminder(self, reminder_interval_hours: int = 24) -> bool:
        """Check if user needs a verification reminder."""
        if self.is_verified:
            return False
        
        if not self.verification_reminder_sent_at:
            return True
        
        time_since_reminder = datetime.utcnow() - self.verification_reminder_sent_at
        return time_since_reminder.total_seconds() > (reminder_interval_hours * 3600)
```

## 3. Email Verification Service

### Core Verification Service
```python
# File: backend/app/services/email_verification_service.py
import logging
from typing import Optional, Dict, Any
from sqlalchemy.orm import Session
from datetime import datetime, timedelta

from app.models.user import User
from app.models.email_verification import EmailVerificationToken
from app.services.email_service import EmailService
from app.core.config import settings
from app.core.exceptions import ResourceNotFoundError, ValidationError, BusinessLogicError, RateLimitExceededError
from app.core.sentry_utils import track_business_event, add_error_context, sentry_trace

logger = logging.getLogger(__name__)

class EmailVerificationService:
    """Comprehensive email verification service with security and user experience focus."""
    
    def __init__(self, db: Session):
        self.db = db
        self.email_service = EmailService(db)
        
        self.token_expiry_hours = 24
        self.max_tokens_per_user = 5
        self.max_attempts_per_token = 3
        self.rate_limit_window_minutes = 15
        self.max_requests_per_window = 3
    
    @sentry_trace("email_verification_send")
    async def send_verification_email(self, user_id: str, ip_address: str = None, 
                                    user_agent: str = None) -> Dict[str, Any]:
        """Send email verification to user."""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            raise ResourceNotFoundError("User not found")
        
        if user.is_verified:
            track_business_event("verification_email_already_verified", {
                "user_id": user_id,
                "email": user.email
            })
            return {
                "status": "already_verified",
                "message": "Email is already verified"
            }
        
        # Check rate limiting
        self._check_rate_limit(user_id, ip_address)
        
        # Clean up old tokens
        self._cleanup_expired_tokens(user_id)
        
        # Check token limit
        active_tokens = self.db.query(EmailVerificationToken).filter(
            EmailVerificationToken.user_id == user_id,
            EmailVerificationToken.expires_at > datetime.utcnow(),
            EmailVerificationToken.is_used == False
        ).count()
        
        if active_tokens >= self.max_tokens_per_user:
            raise RateLimitExceededError("Too many active verification tokens")
        
        # Generate new token
        token = EmailVerificationToken.generate_token(
            user_id=user_id,
            email=user.email,
            expires_in_hours=self.token_expiry_hours
        )
        
        self.db.add(token)
        self.db.commit()
        self.db.refresh(token)
        
        try:
            # Send verification email
            verification_url = self._build_verification_url(token.token_plain)
            
            email_result = await self.email_service.send_email(
                to_email=user.email,
                template_name="email_verification",
                template_data={
                    "user_name": user.full_name,
                    "verification_url": verification_url,
                    "expiry_hours": self.token_expiry_hours,
                    "support_email": settings.SUPPORT_EMAIL
                },
                user_id=user_id,
                organization_id=str(user.organization_id) if user.organization_id else None
            )
            
            if email_result.get("success"):
                track_business_event("verification_email_sent", {
                    "user_id": user_id,
                    "email": user.email,
                    "token_id": str(token.id)
                })
                
                return {
                    "status": "sent",
                    "message": "Verification email sent successfully",
                    "expires_at": token.expires_at.isoformat()
                }
            else:
                logger.error(f"Failed to send verification email to {user.email}: {email_result}")
                raise BusinessLogicError("Failed to send verification email")
                
        except Exception as e:
            add_error_context("email_verification_error", {
                "user_id": user_id,
                "email": user.email,
                "token_id": str(token.id),
                "error": str(e)
            })
            raise
    
    @sentry_trace("email_verification_verify")
    async def verify_email_token(self, token_plain: str, ip_address: str = None, 
                                user_agent: str = None) -> Dict[str, Any]:
        """Verify email verification token."""
        if not token_plain:
            raise ValidationError("Verification token is required")
        
        # Hash the token to find the record
        import hashlib
        token_hash = hashlib.sha256(token_plain.encode()).hexdigest()
        
        # Find token record
        token = self.db.query(EmailVerificationToken).filter(
            EmailVerificationToken.token_hash == token_hash
        ).first()
        
        if not token:
            track_business_event("verification_token_not_found", {
                "token_hash": token_hash[:8] + "...",
                "ip_address": ip_address
            })
            raise ValidationError("Invalid verification token")
        
        # Increment attempts
        token.attempts_count += 1
        token.last_attempt_at = datetime.utcnow()
        if ip_address:
            token.ip_address = ip_address
        if user_agent:
            token.user_agent = user_agent
        
        # Check attempt limit
        if token.attempts_count > self.max_attempts_per_token:
            track_business_event("verification_token_max_attempts", {
                "user_id": str(token.user_id),
                "token_id": str(token.id),
                "attempts": token.attempts_count
            })
            raise ValidationError("Too many verification attempts")
        
        # Verify token
        if not token.verify_token(token_plain):
            if token.is_used:
                error_message = "Verification token has already been used"
            elif token.expires_at < datetime.utcnow():
                error_message = "Verification token has expired"
            else:
                error_message = "Invalid verification token"
            
            track_business_event("verification_token_invalid", {
                "user_id": str(token.user_id),
                "token_id": str(token.id),
                "reason": error_message
            })
            
            self.db.commit()  # Save attempt increment
            raise ValidationError(error_message)
        
        # Get user
        user = token.user
        if not user:
            raise ResourceNotFoundError("User not found")
        
        # Mark token as used
        token.mark_as_used(ip_address, user_agent)
        
        # Mark user as verified
        user.mark_email_verified()
        
        # Deactivate all other tokens for this user
        self.db.query(EmailVerificationToken).filter(
            EmailVerificationToken.user_id == user.id,
            EmailVerificationToken.id != token.id,
            EmailVerificationToken.is_used == False
        ).update({"is_used": True, "used_at": datetime.utcnow()})
        
        self.db.commit()
        
        # Track successful verification
        track_business_event("email_verification_successful", {
            "user_id": str(user.id),
            "email": user.email,
            "token_id": str(token.id),
            "verification_time": user.email_verified_at.isoformat()
        })
        
        # Send welcome email (optional)
        try:
            await self._send_welcome_email(user)
        except Exception as e:
            logger.warning(f"Failed to send welcome email to {user.email}: {e}")
        
        return {
            "status": "verified",
            "message": "Email verified successfully",
            "user": {
                "id": str(user.id),
                "email": user.email,
                "is_verified": user.is_verified,
                "verified_at": user.email_verified_at.isoformat()
            }
        }
    
    async def resend_verification_email(self, user_id: str, ip_address: str = None, 
                                      user_agent: str = None) -> Dict[str, Any]:
        """Resend verification email with rate limiting."""
        self._check_rate_limit(user_id, ip_address, stricter=True)
        return await self.send_verification_email(user_id, ip_address, user_agent)
    
    def get_verification_status(self, user_id: str) -> Dict[str, Any]:
        """Get user's email verification status and active tokens."""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            raise ResourceNotFoundError("User not found")
        
        # Get active tokens
        active_tokens = self.db.query(EmailVerificationToken).filter(
            EmailVerificationToken.user_id == user_id,
            EmailVerificationToken.expires_at > datetime.utcnow(),
            EmailVerificationToken.is_used == False
        ).all()
        
        return {
            "is_verified": user.is_verified,
            "email": user.email,
            "verified_at": user.email_verified_at.isoformat() if user.email_verified_at else None,
            "active_tokens_count": len(active_tokens),
            "last_token_expires_at": max([token.expires_at for token in active_tokens]).isoformat() if active_tokens else None,
            "needs_reminder": user.needs_verification_reminder()
        }
    
    def _check_rate_limit(self, user_id: str, ip_address: str = None, stricter: bool = False):
        """Check rate limiting for verification requests."""
        window_minutes = self.rate_limit_window_minutes
        max_requests = self.max_requests_per_window
        
        if stricter:
            max_requests = 1  # Only 1 resend per window
        
        # Check by user
        since_time = datetime.utcnow() - timedelta(minutes=window_minutes)
        recent_tokens = self.db.query(EmailVerificationToken).filter(
            EmailVerificationToken.user_id == user_id,
            EmailVerificationToken.created_at > since_time
        ).count()
        
        if recent_tokens >= max_requests:
            track_business_event("verification_rate_limit_exceeded", {
                "user_id": user_id,
                "ip_address": ip_address,
                "recent_requests": recent_tokens,
                "window_minutes": window_minutes
            })
            raise RateLimitExceededError(f"Too many verification requests. Please wait {window_minutes} minutes.")
    
    def _cleanup_expired_tokens(self, user_id: str):
        """Clean up expired tokens for user."""
        expired_count = self.db.query(EmailVerificationToken).filter(
            EmailVerificationToken.user_id == user_id,
            EmailVerificationToken.expires_at < datetime.utcnow()
        ).delete()
        
        if expired_count > 0:
            self.db.commit()
            logger.info(f"Cleaned up {expired_count} expired verification tokens for user {user_id}")
    
    def _build_verification_url(self, token: str) -> str:
        """Build verification URL for email."""
        return f"{settings.FRONTEND_URL}/verify-email?token={token}"
    
    async def _send_welcome_email(self, user: User):
        """Send welcome email after successful verification."""
        try:
            await self.email_service.send_email(
                to_email=user.email,
                template_name="welcome",
                template_data={
                    "user_name": user.full_name,
                    "dashboard_url": f"{settings.FRONTEND_URL}/dashboard",
                    "support_email": settings.SUPPORT_EMAIL
                },
                user_id=str(user.id),
                organization_id=str(user.organization_id) if user.organization_id else None
            )
        except Exception as e:
            logger.warning(f"Failed to send welcome email: {e}")
```

## 4. API Endpoints

### Email Verification API
```python
# File: backend/app/api/v1/endpoints/email_verification.py
import logging
from fastapi import APIRouter, Depends, HTTPException, status, Request, Query
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.api.v1.dependencies.auth_deps import get_current_active_user
from app.models.user import User as UserModel
from app.services.email_verification_service import EmailVerificationService
from app.schemas.common_schemas import APISuccessResponse
from app.core.exceptions import ValidationError, RateLimitExceededError, BusinessLogicError

logger = logging.getLogger(__name__)
router = APIRouter()

@router.post("/send", status_code=status.HTTP_200_OK)
async def send_verification_email(
    request: Request,
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Send email verification to current user."""
    verification_service = EmailVerificationService(db)
    
    try:
        result = await verification_service.send_verification_email(
            user_id=str(current_user.id),
            ip_address=request.client.host,
            user_agent=request.headers.get("user-agent")
        )
        
        return APISuccessResponse(data=result)
        
    except RateLimitExceededError as e:
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail=str(e)
        )
    except BusinessLogicError as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )

@router.post("/verify", status_code=status.HTTP_200_OK)
async def verify_email_token(
    request: Request,
    token: str = Query(..., description="Email verification token"),
    db: Session = Depends(get_db)
):
    """Verify email verification token."""
    verification_service = EmailVerificationService(db)
    
    try:
        result = await verification_service.verify_email_token(
            token_plain=token,
            ip_address=request.client.host,
            user_agent=request.headers.get("user-agent")
        )
        
        return APISuccessResponse(data=result)
        
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )

@router.get("/status")
async def get_verification_status(
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Get current user's email verification status."""
    verification_service = EmailVerificationService(db)
    
    result = verification_service.get_verification_status(str(current_user.id))
    return APISuccessResponse(data=result)

@router.post("/resend", status_code=status.HTTP_200_OK)
async def resend_verification_email(
    request: Request,
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Resend email verification to current user."""
    verification_service = EmailVerificationService(db)
    
    try:
        result = await verification_service.resend_verification_email(
            user_id=str(current_user.id),
            ip_address=request.client.host,
            user_agent=request.headers.get("user-agent")
        )
        
        return APISuccessResponse(data=result)
        
    except RateLimitExceededError as e:
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail=str(e)
        )
```

## 5. Integration with Auth Service

### Enhanced Auth Service
```python
# File: backend/app/services/auth_service.py (additions)
from app.services.email_verification_service import EmailVerificationService

class AuthService:
    def __init__(self, db: Session):
        self.db = db
        self.verification_service = EmailVerificationService(db)
    
    async def register_user(self, user_create: UserCreate, ip_address: str = None, 
                           user_agent: str = None) -> User:
        """Enhanced user registration with automatic email verification."""
        try:
            # ... existing registration logic ...
            
            # Send verification email automatically
            try:
                await self.verification_service.send_verification_email(
                    user_id=str(new_user.id),
                    ip_address=ip_address,
                    user_agent=user_agent
                )
                logger.info(f"Verification email sent to {new_user.email}")
            except Exception as e:
                # Don't fail registration if email sending fails
                logger.warning(f"Failed to send verification email to {new_user.email}: {e}")
            
            return new_user
            
        except Exception as e:
            self.db.rollback()
            raise
```

## 6. Configuration Updates

### Environment Variables
```python
# File: backend/app/core/config.py (additions)
class Settings(BaseSettings):
    # ... existing settings ...
    
    # Email Verification Configuration
    EMAIL_VERIFICATION_ENABLED: bool = True
    EMAIL_VERIFICATION_TOKEN_EXPIRY_HOURS: int = 24
    EMAIL_VERIFICATION_MAX_TOKENS_PER_USER: int = 5
    EMAIL_VERIFICATION_MAX_ATTEMPTS_PER_TOKEN: int = 3
    EMAIL_VERIFICATION_RATE_LIMIT_WINDOW_MINUTES: int = 15
    EMAIL_VERIFICATION_MAX_REQUESTS_PER_WINDOW: int = 3
    
    # Frontend URLs
    FRONTEND_URL: str = "http://localhost:3000"
    SUPPORT_EMAIL: str = "support@martechengine.com"
```

## 7. Database Migration

### Alembic Migration
```python
# File: backend/alembic/versions/add_email_verification.py
"""Add email verification tables

Revision ID: add_email_verification
Revises: previous_revision
Create Date: 2024-01-01 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = 'add_email_verification'
down_revision = 'previous_revision'
branch_labels = None
depends_on = None

def upgrade():
    # Create email_verification_tokens table
    op.create_table('email_verification_tokens',
        sa.Column('id', sa.String(36), nullable=False),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=False),
        sa.Column('user_id', sa.String(36), nullable=False),
        sa.Column('email', sa.String(255), nullable=False),
        sa.Column('token_hash', sa.String(128), nullable=False),
        sa.Column('expires_at', sa.DateTime(), nullable=False),
        sa.Column('is_used', sa.Boolean(), nullable=False),
        sa.Column('used_at', sa.DateTime(), nullable=True),
        sa.Column('attempts_count', sa.Integer(), nullable=False),
        sa.Column('last_attempt_at', sa.DateTime(), nullable=True),
        sa.Column('ip_address', sa.String(45), nullable=True),
        sa.Column('user_agent', sa.Text(), nullable=True),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('token_hash')
    )
    
    # Create indexes
    op.create_index('ix_email_verification_tokens_user_id', 'email_verification_tokens', ['user_id'])
    op.create_index('ix_email_verification_tokens_email', 'email_verification_tokens', ['email'])
    op.create_index('ix_email_verification_tokens_expires_at', 'email_verification_tokens', ['expires_at'])
    op.create_index('ix_email_verification_tokens_token_hash', 'email_verification_tokens', ['token_hash'])
    
    # Add columns to users table
    op.add_column('users', sa.Column('is_verified', sa.Boolean(), nullable=False, server_default='false'))
    op.add_column('users', sa.Column('email_verified_at', sa.DateTime(), nullable=True))
    op.add_column('users', sa.Column('verification_reminder_sent_at', sa.DateTime(), nullable=True))

def downgrade():
    # Remove columns from users table
    op.drop_column('users', 'verification_reminder_sent_at')
    op.drop_column('users', 'email_verified_at')
    op.drop_column('users', 'is_verified')
    
    # Drop indexes
    op.drop_index('ix_email_verification_tokens_token_hash')
    op.drop_index('ix_email_verification_tokens_expires_at')
    op.drop_index('ix_email_verification_tokens_email')
    op.drop_index('ix_email_verification_tokens_user_id')
    
    # Drop table
    op.drop_table('email_verification_tokens')
```

## 8. Next Steps

This Email Verification Implementation provides:
- ✅ **Secure token generation** with cryptographic security
- ✅ **Rate limiting protection** against abuse
- ✅ **Comprehensive error tracking** with Sentry integration
- ✅ **User-friendly email templates** with clear instructions
- ✅ **Audit trail** for security analysis
- ✅ **Automatic cleanup** of expired tokens

**Next Implementation**: Add search functionality to content and project management systems.
