Phase: 7 - Enterprise Readiness & Finalization
Part: 7.3 (Consolidated)
Title: Consolidated Implementation & Testing Strategy
Depends On: 7.2-Frontend-Testing-Infrastructure.md
Objective: To define the complete implementation and testing strategy for the entire application. This consolidated document outlines the patterns for backend integration tests, frontend unit/integration tests, E2E testing, and the architecture for critical backend systems like token refresh and subscription refills.
1. Backend Integration Testing Patterns
Principle: Test business workflows from the API layer down to the database, using the authenticated_client and data factories from our testing infrastructure.
Example: backend/tests/integration/test_project_flow.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from app.models import Project, User, Plan, Organization

# Assume factories for Plan and Project are added to tests/factories.py

@pytest.mark.integration
def test_create_project_success(authenticated_client: TestClient, db: Session, authenticated_user: User):
    """Tests that a user with a valid plan can create a project."""
    # Arrange: Ensure the user's org has a plan that allows project creation
    plan = PlanFactory.create(db=db, allowed_projects=5)
    authenticated_user.organization.plan = plan
    db.commit()

    project_payload = {"name": "My First Project", "url": "https://example.com"}

    # Act
    response = authenticated_client.post("/api/v1/projects/", json=project_payload)
    
    # Assert
    assert response.status_code == 201
    project_in_db = db.query(Project).filter_by(name="My First Project").first()
    assert project_in_db is not None
    assert project_in_db.organization_id == authenticated_user.organization_id

@pytest.mark.integration
def test_create_project_fails_when_plan_limit_exceeded(authenticated_client: TestClient, db: Session, authenticated_user: User):
    """Tests that project creation is blocked when the plan limit is reached."""
    # Arrange
    plan = PlanFactory.create(db=db, allowed_projects=1)
    authenticated_user.organization.plan = plan
    ProjectFactory.create(db=db, organization=authenticated_user.organization, owner=authenticated_user)
    db.commit()
    
    # Act
    response = authenticated_client.post("/api/v1/projects/", json={"name": "Second Project", "url": "https://test.com"})

    # Assert
    assert response.status_code == 402 # Payment Required
    assert "You have reached your limit" in response.json()["detail"]

2. Frontend Testing Patterns
Principle: Use jest.mock for unit tests and MSW for integration tests, leveraging our custom render utility.
Unit Test Example (Mocking Hooks): frontend/src/components/features/projects/CreateProjectModal.test.tsx
import { render, screen, fireEvent, waitFor } from '@/tests/utils';
import { CreateProjectModal } from './CreateProjectModal';
import * as projectHooks from '@/hooks/useProjects'; // Import the module

jest.mock('@/hooks/useProjects'); // Mock the entire module
const mockedUseCreateProject = jest.spyOn(projectHooks, 'useCreateProject');

describe('Unit: CreateProjectModal', () => {
  it('submits the form with correct data when fields are valid', async () => {
    const mockMutate = jest.fn();
    mockedUseCreateProject.mockReturnValue({ mutate: mockMutate, isPending: false } as any);

    render(<CreateProjectModal />);
    fireEvent.click(screen.getByRole('button', { name: /new project/i }));
    
    await userEvent.type(screen.getByLabelText(/project name/i), 'New Test Project');
    await userEvent.type(screen.getByLabelText(/website url/i), 'https://test.com');
    fireEvent.click(screen.getByRole('button', { name: /create project/i }));

    await waitFor(() => {
      expect(mockMutate).toHaveBeenCalledWith({ name: 'New Test Project', url: 'https://test.com' }, expect.any(Object));
    });
  });
});

Integration Test Example (Mocking API with MSW): frontend/src/app/(dashboard)/dashboard/page.test.tsx
import { render, screen, waitFor } from '@/tests/utils';
import { server } from '@/tests/mocks/server';
import { http, HttpResponse } from 'msw';
import MainDashboardPage from './page';

describe('Integration: MainDashboardPage', () => {
  it('displays project cards after successfully fetching data', async () => {
    // MSW handler provides the mock API response for this test
    server.use(
      http.get('*/projects/', () => {
        return HttpResponse.json({
          success: true,
          data: [{ id: '1', name: 'Test Project 1', url: 'https://test1.com' }],
        });
      })
    );

    render(<MainDashboardPage />);
    
    expect(await screen.findByText('Test Project 1')).toBeInTheDocument();
  });
});```

---

### **3. E2E Testing Strategy (Playwright)**

**Principle:** True black-box testing. Tests interact with the UI only. Test data is managed via dedicated, test-only API endpoints.

**Strategy:**
1.  **Test-Only API Endpoints:** Create `POST /api/v1/testing/seed` and `POST /api/v1/testing/reset` endpoints in the backend, enabled only in the `TESTING` environment.
2.  **Data Seeding:** Before each test, Playwright calls the `/reset` endpoint, then the `/seed` endpoint with a specific scenario (e.g., `{ user: { plan: 'FREE', projects: 1 } }`).
3.  **UI Interaction:** The test proceeds to interact with the UI (`page.goto`, `page.click`, etc.).
4.  **Mail Catcher:** For email verification, a `MailHog` container will be added to `docker-compose.test.yml`. The test will fetch the verification email from the MailHog API and navigate to the link.

---

### **4. Backend Token Refresh System**

**Principle:** A secure, stateful refresh token system using an indexed database table for fast, secure lookups.

**Architecture:**
1.  **Data Model:** A `UserSession` table will store a **hashed** version of the refresh token, user agent, IP address, and expiry. The `refresh_token_hash` column **must** have a unique index.
2.  **Login Flow:** Upon successful login, the `AuthService` generates an access/refresh token pair. It hashes the refresh token and stores the `UserSession` record in the database.
3.  **Refresh Flow:** The `/auth/refresh` endpoint receives a refresh token. The `AuthService` hashes it and performs a fast, indexed lookup in the `UserSession` table. If a valid, non-expired session is found, it issues a *new* access token.

---

### **5. Backend Subscription Refill System**

**Principle:** An automated, idempotent, and auditable background job for granting recurring monthly credits.

**Architecture:**
1.  **Scheduler:** **Celery Beat** will be configured to trigger a task daily.
2.  **Task Executor:** A **Celery Worker** will run the `process_monthly_refills` task.
3.  **Idempotent Logic:** The task will query for `Subscription` records where the billing anniversary has passed *and* the `last_refill_date` is before the anniversary. It uses `with_for_update(skip_locked=True)` to prevent race conditions.
4.  **Atomic Operation:** For each subscription found, the task will call the `CreditService` to grant credits and then update the `last_refill_date` within a single database transaction.

---

### **6. Backend Core Infrastructure Clients (Redis)**

**Principle:** Use FastAPI's native dependency injection and lifecycle events for managing infrastructure clients like Redis. Avoid untestable global singletons.

**Architecture:**
1.  **Lifecycle Management:** In `backend/app/main.py`, use the `lifespan` async context manager. On startup, create the Redis connection pool and attach it to `app.state.redis_client`. On shutdown, close the connection pool.
2.  **Dependency Provider:** Create a simple dependency provider function, e.g., `async def get_redis_client(request: Request)`, that yields the client from `request.app.state.redis_client`.
3.  **Usage:** Services and API routes receive the Redis client via FastAPI's `Depends` system, making them explicit and easily mockable in tests.

---

*This file concludes the core implementation and testing strategy for Phase 7.*