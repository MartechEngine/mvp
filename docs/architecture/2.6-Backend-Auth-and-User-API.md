Phase: 2 - User Identity & Authentication
Part: 2.6
Title: Backend Authentication & User API Endpoints

Objective: To implement the FastAPI router and RESTful API endpoints for authentication. This includes creating secure endpoints for user registration and login, using our custom exceptions for clear error handling, and integrating the AuthService to handle all business logic.
1. Core Principle: Thin & Declarative API Layer
The API endpoints are designed to be simple and "thin". Their only job is to handle the HTTP layer concerns, while all complex business logic is delegated to the service layer.
Dependency Injection: Depends(get_db) provides a database session.
Request & Response Modeling: Pydantic schemas are used to automatically validate incoming data and serialize outgoing data, ensuring the API contract is always met.
Centralized Error Handling: Instead of try...except blocks in every endpoint, we will define centralized exception handlers that map our custom service exceptions to the correct HTTP status codes.
2. Centralized Exception Handlers
This function will register our custom exception handlers with the FastAPI application.
File Location: backend/app/api/v1/exception_handlers.py
File Content:
from fastapi import Request, status
from fastapi.responses import JSONResponse

from app.core.exceptions import EmailAlreadyExistsError, InvalidCredentialsError
from app.schemas.common_schemas import APIErrorResponse, APIErrorDetail

def setup_exception_handlers(app):
    @app.exception_handler(EmailAlreadyExistsError)
    async def email_already_exists_handler(request: Request, exc: EmailAlreadyExistsError):
        return JSONResponse(
            status_code=status.HTTP_409_CONFLICT,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="AUTH_EMAIL_EXISTS",
                    message=str(exc)
                )
            ).model_dump()
        )

    @app.exception_handler(InvalidCredentialsError)
    async def invalid_credentials_handler(request: Request, exc: InvalidCredentialsError):
        return JSONResponse(
            status_code=status.HTTP_401_UNAUTHORIZED,
            content=APIErrorResponse(
                error=APIErrorDetail(
                    code="AUTH_INVALID_CREDENTIALS",
                    message=str(exc)
                )
            ).model_dump(),
            headers={"WWW-Authenticate": "Bearer"},
        )

Integration with main.py:
File to Modify: backend/app/main.py
Content to Add:
# In backend/app/main.py

# ... (other imports)
from app.api.v1.exception_handlers import setup_exception_handlers
from app.api.v1.endpoints import auth # Import the new auth router

# ... (FastAPI app initialization) ...

# Register custom exception handlers
setup_exception_handlers(app)

# Include API routers
app.include_router(auth.router, prefix=f"{settings.API_V1_PREFIX}/auth", tags=["Authentication"])

# ... (rest of the file)```

### **3. Database Dependency**

We need a reusable dependency to provide database sessions to our endpoints.

**File Location:** `backend/app/core/database.py`
**File Content:**
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from typing import Generator

from app.core.config import settings

engine = create_engine(str(settings.DATABASE_URL), pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db() -> Generator:
    """FastAPI dependency that provides a database session."""
    try:
        db = SessionLocal()
        yield db
    finally:
        db.close()

4. Authentication API Endpoints
This file contains the complete router for our authentication endpoints.
File Location: backend/app/api/v1/endpoints/auth.py
File Content:

from fastapi import APIRouter, Depends, HTTPException, status, Request, Query
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from typing import Any, List

from app.core.database import get_db
from app.core.security import create_access_token, create_refresh_token
from app.services.auth_service import AuthService
from app.api.v1.dependencies.auth_deps import get_current_verified_user
from app.schemas.auth_schemas import UserLogin, LoginResponse, Token, RefreshTokenRequest, LogoutRequest
from app.schemas.user_schemas import UserCreate, User as UserSchema
from app.schemas.common_schemas import APISuccessResponse

router = APIRouter()

# Security scheme for extracting Bearer tokens
security = HTTPBearer()

@router.post(
    "/register",
    response_model=APISuccessResponse[UserSchema],
    status_code=status.HTTP_201_CREATED,
    summary="Register a new user"
)
def register_user(
    user_in: UserCreate,
    db: Session = Depends(get_db)
) -> Any:
    """
    Handles user registration.
    - Creates a new user, their initial organization, and their ownership membership.
    - All error handling is managed by the centralized exception handlers.
    """
    auth_service = AuthService(db)
    # If auth_service.register_user raises EmailAlreadyExistsError,
    # the handler will catch it and return a 409 Conflict.
    new_user = auth_service.register_user(user_create=user_in)
    return APISuccessResponse(data=new_user, message="User registered successfully. Please check your email to verify your account.")

@router.post(
    "/login",
    response_model=APISuccessResponse[LoginResponse],
    summary="User Login"
)
def login_for_access_token(
    form_data: UserLogin,
    request: Request,
    db: Session = Depends(get_db)
) -> Any:
    """
    Handles user login and returns JWT tokens with session management.
    """
    from app.services.user_session_service import UserSessionService
    
    auth_service = AuthService(db)
    session_service = UserSessionService(db)
    
    user = auth_service.authenticate_user(user_login=form_data)
    
    # Extract device and location info from request
    device_info = {
        "device_id": request.headers.get("X-Device-ID"),
        "device_name": request.headers.get("X-Device-Name"),
        "device_type": request.headers.get("X-Device-Type", "unknown"),
        "user_agent": request.headers.get("User-Agent")
    }
    
    ip_address = request.client.host if request.client else None
    
    # Create session with refresh token
    session, refresh_token = session_service.create_session(
        user_id=str(user.id),
        device_info=device_info,
        ip_address=ip_address
    )
    
    # Create access token
    access_token = create_access_token(
        subject=str(user.id),
        additional_claims={"session_id": session.session_id}
    )
    
    token_data = Token(access_token=access_token, refresh_token=refresh_token)
    login_response = LoginResponse(token=token_data, user=user)
    
    return APISuccessResponse(data=login_response, message="Login successful")

@router.post(
    "/refresh",
    response_model=APISuccessResponse[Token],
    summary="Refresh Access Token"
)
def refresh_access_token(
    refresh_request: RefreshTokenRequest,
    request: Request,
    db: Session = Depends(get_db)
) -> Any:
    """
    Refresh an expired access token using a valid refresh token.
    """
    from app.services.user_session_service import UserSessionService
    
    session_service = UserSessionService(db)
    
    try:
        # Refresh the session
        session, new_refresh_token = session_service.refresh_session(
            refresh_token=refresh_request.refresh_token,
            ip_address=request.client.host if request.client else None
        )
        
        # Create new access token
        access_token = create_access_token(
            subject=str(session.user_id),
            additional_claims={"session_id": session.session_id}
        )
        
        token_data = Token(access_token=access_token, refresh_token=new_refresh_token)
        
        return APISuccessResponse(data=token_data, message="Token refreshed successfully")
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired refresh token",
            headers={"WWW-Authenticate": "Bearer"}
        )

@router.post(
    "/logout",
    status_code=status.HTTP_200_OK,
    summary="User Logout"
)
def logout(
    logout_request: LogoutRequest,
    current_user: UserSchema = Depends(get_current_verified_user),
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> Any:
    """
    Logout user by revoking their session.
    """
    from app.services.user_session_service import UserSessionService
    from app.core.security import decode_token
    
    session_service = UserSessionService(db)
    
    # Revoke specific session or all sessions
    if logout_request.revoke_all_sessions:
        revoked_count = session_service.revoke_all_user_sessions(
            user_id=str(current_user.id),
            reason="user_logout_all"
        )
        message = f"Logged out from all {revoked_count} sessions"
    else:
        session_id = logout_request.session_id
        if not session_id:
            # Extract session_id from JWT token claims
            try:
                token_data = decode_token(credentials.credentials)
                session_id = token_data.get("session_id") if token_data else None
            except Exception:
                session_id = None
            
            if not session_id:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Session ID not found in token or request"
                )
        
        success = session_service.revoke_session(
            session_id=session_id,
            user_id=str(current_user.id),
            reason="user_logout"
        )
        
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Session not found"
            )
        
        message = "Logged out successfully"
    
    return APISuccessResponse(data={"message": message})

@router.get(
    "/sessions",
    response_model=APISuccessResponse[List[dict]],
    summary="Get User Sessions"
)
def get_user_sessions(
    include_expired: bool = Query(False, description="Include expired sessions"),
    current_user: UserSchema = Depends(get_current_verified_user),
    db: Session = Depends(get_db)
) -> Any:
    """
    Get all sessions for the current user.
    """
    from app.services.user_session_service import UserSessionService
    
    session_service = UserSessionService(db)
    sessions = session_service.get_user_sessions(
        user_id=str(current_user.id),
        include_expired=include_expired
    )
    
    return APISuccessResponse(data=sessions)

@router.delete(
    "/sessions/{session_id}",
    status_code=status.HTTP_200_OK,
    summary="Revoke Specific Session"
)
def revoke_session(
    session_id: str,
    current_user: UserSchema = Depends(get_current_verified_user),
    db: Session = Depends(get_db)
) -> Any:
    """
    Revoke a specific session.
    """
    from app.services.user_session_service import UserSessionService
    
    session_service = UserSessionService(db)
    success = session_service.revoke_session(
        session_id=session_id,
        user_id=str(current_user.id),
        reason="user_revoke"
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )
    
    return APISuccessResponse(data={"message": "Session revoked successfully"})

@router.get(
    "/users/me",
    response_model=APISuccessResponse[UserSchema],
    summary="Get Current User Profile"
)
def get_current_user_profile(
    current_user: UserSchema = Depends(get_current_verified_user)
) -> Any:
    """
    Get the current authenticated user's profile information.
    This endpoint is used by the frontend to fetch user data after login.
    """
    return APISuccessResponse(
        data=current_user,
        message="User profile retrieved successfully"
    )

@router.put(
    "/users/me",
    response_model=APISuccessResponse[UserSchema],
    summary="Update Current User Profile"
)
def update_current_user_profile(
    user_update: dict,  # This would be a proper UserUpdate schema in practice
    current_user: UserSchema = Depends(get_current_verified_user),
    db: Session = Depends(get_db)
) -> Any:
    """
    Update the current authenticated user's profile information.
    Note: This is a placeholder implementation. A proper UserUpdate schema
    and service method should be implemented in Phase 3.
    """
    # TODO: Implement proper user update logic in Phase 3
    # For now, just return the current user
    return APISuccessResponse(
        data=current_user,
        message="User profile updated successfully"
    )

@router.put(
    "/users/me/password",
    status_code=status.HTTP_200_OK,
    summary="Change User Password"
)
def change_user_password(
    password_change: dict,  # This would be a proper PasswordChange schema
    current_user: UserSchema = Depends(get_current_verified_user),
    db: Session = Depends(get_db)
) -> Any:
    """
    Change the current authenticated user's password.
    Note: This is a placeholder implementation. Proper password change logic
    with validation should be implemented in Phase 3.
    """
    # TODO: Implement proper password change logic in Phase 3
    return APISuccessResponse(
        data={"message": "Password changed successfully"},
        message="Password updated successfully"
    )

5. Next Steps
With the backend API for authentication fully implemented, we have a complete loop for user registration and login. We will now cross over to the frontend to build the client-side infrastructure to interact with these new endpoints.
Next File: 2.7-Frontend-API-Service-Layer.md will establish the centralized Axios client and service layer that the frontend will use for all API communication.