Phase: 2 - User Identity & Authentication
Part: 2.4
Title: Backend Common Schemas for Auth & Tenancy
Depends On: 2.3-Backend-Security-JWT-Service.md
Objective: To finalize the complete and consistent set of Pydantic schemas for all data structures related to authentication and multi-tenancy. This document expands on the initial schemas from 2.1 to include representations for Organizations and Memberships, providing a complete data contract for the upcoming services and API endpoints.

## 1. Rationale for Schema Expansion

While `auth_schemas.py` defines the direct inputs and outputs for authentication, our services will often work with more complex, relational data (e.g., a user record that includes their role in an organization). These expanded schemas will serve as the data transfer objects (DTOs) within our application and as the response models for our API.

## 2. Expanded Pydantic Schemas

We will update our existing schema files to include these new, more detailed models.

**File Location:** `backend/app/schemas/user_schemas.py`

**File Content:**
```python
from pydantic import BaseModel, EmailStr, Field, ConfigDict
from typing import Optional, List
from uuid import UUID

from app.models.membership import MemberRole # Import the enum from the model

# --- Base Schemas ---

class UserBase(BaseModel):
    email: EmailStr
    full_name: str

class OrganizationBase(BaseModel):
    name: str

# --- Request Schemas ---

class UserCreate(UserBase):
    password: str = Field(..., min_length=8)
    organization_name: str = Field(..., min_length=2, description="The name of the user's initial organization.")

# --- Response Schemas ---

class User(UserBase):
    """Schema for a standard user profile response."""
    id: UUID
    is_active: bool
    is_verified: bool

    model_config = ConfigDict(from_attributes=True)


class Organization(OrganizationBase):
    """Represents an organization in API responses."""
    id: UUID
    owner_id: UUID

    model_config = ConfigDict(from_attributes=True)


class Membership(BaseModel):
    """Represents a user's membership within an organization."""
    role: MemberRole
    organization: Organization
    
    model_config = ConfigDict(from_attributes=True)

class UserWithMemberships(User):
    """A comprehensive user model including their organizational memberships."""
    memberships: List[Membership] = []
```

**File Location:** `backend/app/schemas/auth_schemas.py`

**File Content:**
```python
from pydantic import BaseModel, EmailStr
from .user_schemas import User # Import the detailed User schema

# --- Request Schemas ---

class UserLogin(BaseModel):
    """Schema for user login request."""
    email: EmailStr
    password: str

class RefreshTokenRequest(BaseModel):
    """Schema for refresh token request."""
    refresh_token: str

class LogoutRequest(BaseModel):
    """Schema for logout request."""
    refresh_token: str

# --- Response Schemas ---

class Token(BaseModel):
    """Schema for JWT token pair response."""
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

class LoginResponse(BaseModel):
    """The complete response for a successful login."""
    token: Token
    user: User
```

**File Location:** `backend/app/schemas/common_schemas.py`

**File Content:**
```python
from pydantic import BaseModel
from typing import Generic, TypeVar, Optional, Any

T = TypeVar('T')

class APIErrorDetail(BaseModel):
    """Schema for API error details."""
    code: str
    message: str
    field: Optional[str] = None

class APIErrorResponse(BaseModel):
    """Schema for API error responses."""
    error: APIErrorDetail

class APISuccessResponse(BaseModel, Generic[T]):
    """Schema for successful API responses."""
    data: T
    message: Optional[str] = None

class PaginationParams(BaseModel):
    """Schema for pagination parameters."""
    page: int = 1
    per_page: int = 20
    
    def __post_init__(self):
        if self.page < 1:
            self.page = 1
        if self.per_page < 1 or self.per_page > 100:
            self.per_page = 20

class PaginatedResponse(BaseModel, Generic[T]):
    """Schema for paginated API responses."""
    items: list[T]
    total: int
    page: int
    per_page: int
    pages: int
```

## 3. Key Design Decisions

**Composition:** We are composing schemas together (e.g., `UserWithMemberships` includes `User` and a list of `Membership` schemas). Pydantic handles this relational mapping from SQLAlchemy objects beautifully when `from_attributes=True` is set.

**Separation of Concerns:**
- `auth_schemas.py` is strictly for the process of authentication (login request, token response).
- `user_schemas.py` is for the entities involved (User, Organization, Membership). This keeps our schema files organized and focused.
- `common_schemas.py` provides reusable response wrappers and utility schemas.

**Enum Re-use:** We directly import the `MemberRole` enum from the SQLAlchemy model (`app.models.membership`) into our Pydantic schema. This ensures that the valid roles are defined in only one place, preventing any drift between our database and our API contract.

## 4. Next Steps

With a complete and robust set of Pydantic schemas defined, we have the final prerequisite for building our core business logic.

**Next File:** `2.6-Backend-Auth-and-User-API.md` will implement the API endpoints for authentication and user management.
