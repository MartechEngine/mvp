Phase: 5 - DCS Engine & Scan Results
Part: 5.4
Title: Enterprise Google PageSpeed API Client
Depends On: 5.3-External-Client-DataForSEO.md
Objective: To implement a secure, reliable, and production-ready API client for the Google PageSpeed Insights service. This client will be responsible for fetching Core Web Vitals, performance scores, and optimization opportunities for any given URL.
1. Core Principle: Standardizing Diverse APIs
The Google PageSpeed API uses a different authentication method (API Key in query parameter) and has a different response structure than the DataForSEO API. The purpose of this client is to abstract away these differences. It will provide a simple, standardized method like analyze_url, and the rest of our application will not need to know the specific implementation details of the Google API.
2. GooglePageSpeedClient Implementation
This class inherits from our base client and implements the necessary methods for the PageSpeed Insights API.
File Location: backend/app/services/api_clients/pagespeed_client.py
File Content:
import logging
from typing import Dict, Any, Optional

from app.services.api_clients.base_client import EnterpriseAPIClient
from app.core.config import Settings

logger = logging.getLogger(__name__)

class GooglePageSpeedClient(EnterpriseAPIClient):
    """
    An enterprise-grade client for the Google PageSpeed Insights API.
    Inherits resilience patterns (retries, circuit breaker) from the base class.
    """

    def __init__(self, settings: Settings):
        super().__init__(
            base_url="https://www.googleapis.com/pagespeedonline/v5",
            service_name="GooglePageSpeed",
            settings=settings
        )
        self.api_key = self.settings.GOOGLE_PAGESPEED_API_KEY.get_secret_value() if self.settings.GOOGLE_PAGESPEED_API_KEY else None

        if not self.api_key:
            logger.error("Google PageSpeed API key is not configured.")
            raise ValueError("Google PageSpeed API key must be configured.")

    def _get_auth_headers(self) -> Dict[str, str]:
        """Authentication for this API is via a query parameter, so no auth headers are needed."""
        return {}

    async def analyze_url(self, url: str, strategy: str = "mobile") -> Optional[Dict[str, Any]]:
        """
        Fetches a PageSpeed analysis for a URL.
        
        Args:
            url (str): The URL to analyze.
            strategy (str): The analysis strategy, either 'mobile' or 'desktop'.
            
        Returns:
            Optional[Dict[str, Any]]: The raw analysis result from the API, or None on failure.
        """
        if strategy not in ["mobile", "desktop"]:
            raise ValueError("Strategy must be either 'mobile' or 'desktop'.")

        params = {
            "url": url,
            "strategy": strategy,
            "key": self.api_key
        }
        
        # The 'request' method from the base class handles resilience (retries, circuit breaking).
        # The calling service (DCS Orchestrator) is responsible for handling exceptions after all retries.
        response_data = await self.request(
            method="GET",
            endpoint="/runPagespeed",
            params=params
        )
        
        return response_data

    def parse_analysis_result(self, result: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parses the raw, complex PageSpeed API response into a simple, structured format.
        This is a crucial abstraction step.
        
        Args:
            result (Dict[str, Any]): The raw JSON response from the API.
            
        Returns:
            Dict[str, Any]: A simplified dictionary with key performance metrics.
        """
        if not result or "lighthouseResult" not in result:
            return {}

        lh_result = result["lighthouseResult"]
        categories = lh_result.get("categories", {})
        audits = lh_result.get("audits", {})

        def get_metric(metric_id: str):
            return audits.get(metric_id, {}).get("numericValue")

        parsed_data = {
            "performance_score": int((categories.get("performance", {}).get("score", 0) or 0) * 100),
            "accessibility_score": int((categories.get("accessibility", {}).get("score", 0) or 0) * 100),
            "best_practices_score": int((categories.get("best-practices", {}).get("score", 0) or 0) * 100),
            "seo_score": int((categories.get("seo", {}).get("score", 0) or 0) * 100),
            "core_web_vitals": {
                "largest_contentful_paint": get_metric("largest-contentful-paint"),
                "cumulative_layout_shift": get_metric("cumulative-layout-shift"),
            },
            "other_metrics": {
                "first_contentful_paint": get_metric("first-contentful-paint"),
                "speed_index": get_metric("speed-index"),
                "time_to_interactive": get_metric("interactive"),
                "total_blocking_time": get_metric("total-blocking-time"),
            }
        }
        return parsed_data

3. Next Steps
We have now built the client for gathering website performance data. We have one more external client to build before we can construct our DCS Orchestration Engine.
Next File: 5.5-External-Client-Vertex-AI.md will create the VertexAIClient. This will be the client responsible for all our advanced AI analysis, including the "AI Citation Score" and summarizing the data collected by our other clients.